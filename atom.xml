<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neverland</title>
  
  <subtitle>你是我不愿醒来的梦啊&lt;br&gt;真是柔情一场</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ir1d.cf/"/>
  <updated>2019-04-24T16:31:40.245Z</updated>
  <id>https://ir1d.cf/</id>
  
  <author>
    <name>Ir1d</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>groupsNotes-0424</title>
    <link href="https://ir1d.cf/2019/04/24/groupsNotes-0424/"/>
    <id>https://ir1d.cf/2019/04/24/groupsNotes-0424/</id>
    <published>2019-04-24T11:51:56.000Z</published>
    <updated>2019-04-24T16:31:40.245Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li><a href="https://arxiv.org/pdf/1904.04971.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1904.04971.pdf</a> <ul><li>Soft Conditional Computation</li><li>这个挺有意思的，感觉最近这种dynamic network的工作很多</li></ul></li><li>cv里梯度一般是 1e-3 - 1e-8<ul><li>很少task用adam</li><li>大部分就momentum</li><li>一些生成模型用adam，还有一些pipeline较长的用</li><li>比如image classification呢 ? sgd</li><li>Detection,segmentation 都 sgd加momentum</li><li>Adam 泛化差</li><li>adam在gradient sparse时有很大优势，所以很多nlp task常用 （在同一次梯度反向传播的时候很多参数梯度很小或者都是0？）</li><li>噢噢，要是有空我讲讲Bengio的一篇文章，关于unsupervised pre-train影响的</li><li>对任意模型架构，通过P(X)去无监督学任意层的初始化表达</li><li><a href="http://www.jmlr.org/papers/volume11/erhan10a/erhan10a.pdf" target="_blank" rel="noopener">http://www.jmlr.org/papers/volume11/erhan10a/erhan10a.pdf</a></li><li>Unsupervised Feature Learning via Non-Parametric Instance Discrimination</li></ul></li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/CameraReady/0801.pdf" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_cvpr_2018/CameraReady/0801.pdf</a><ul><li>去年cvpr的一篇文章，idea挺简单也挺有意思的。通过instance-wise discrimination学到的feature做classification。</li></ul></li><li><a href="https://arxiv.org/pdf/1904.10281.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1904.10281.pdf</a></li><li><p><strong>Dynamic network</strong></p><ul><li><strong>weight prediction</strong></li><li>training loss 可以降，但是泛化效果没有 gain</li></ul></li><li><p>A series of paper from sensetime</p><ul><li><a href="https://arxiv.org/abs/1904.09739" target="_blank" rel="noopener">https://arxiv.org/abs/1904.09739</a></li><li>Switchable Whitening for Deep Representation Learning</li><li><a href="https://arxiv.org/abs/1807.09441" target="_blank" rel="noopener">https://arxiv.org/abs/1807.09441</a></li><li>Two at Once: Enhancing Learning and Generalization Capacities via IBN-Net</li><li><a href="https://arxiv.org/abs/1806.10779" target="_blank" rel="noopener">https://arxiv.org/abs/1806.10779</a></li><li>Differentiable Learning-to-Normalize via Switchable Normalization</li><li><a href="https://arxiv.org/abs/1609.09106" target="_blank" rel="noopener">https://arxiv.org/abs/1609.09106</a></li></ul></li><li><p>HyperNetworks</p><ul><li>Our main result is that hypernetworks can generate non-shared weights for LSTM and achieve near state-of-the-art results on a variety of sequence modelling tasks</li></ul></li><li><p>FaceNet: A Unified Embedding for Face Recognition and Clustering</p><ul><li><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Schroff_FaceNet_A_Unified_2015_CVPR_paper.pdf" target="_blank" rel="noopener">https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Schroff_FaceNet_A_Unified_2015_CVPR_paper.pdf</a></li></ul></li><li>Unsupervised Feature Learning via Non-Parametric Instance Discrimination<ul><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Wu_Unsupervised_Feature_Learning_CVPR_2018_paper.pdf" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_cvpr_2018/papers/Wu_Unsupervised_Feature_Learning_CVPR_2018_paper.pdf</a></li></ul></li><li>A Bottom-up Clustering Approach to Unsupervised Person Re-identification<ul><li><a href="http://xuanyidong.com/pdf/AAAI19-vana.pdf" target="_blank" rel="noopener">http://xuanyidong.com/pdf/AAAI19-vana.pdf</a></li></ul></li><li>Learning Deep Embeddings with Histogram Loss<ul><li><a href="http://papers.nips.cc/paper/6463-learning-deep-embeddings-with-histogram-loss" target="_blank" rel="noopener">http://papers.nips.cc/paper/6463-learning-deep-embeddings-with-histogram-loss</a></li></ul></li></ul><p>我觉得我今晚完全掉线了.. 急需好好补习一下..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1904.04971.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/pdf/1904.04971.pd
      
    
    </summary>
    
      <category term="paperReading" scheme="https://ir1d.cf/categories/paperReading/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>代组期中笔记</title>
    <link href="https://ir1d.cf/2019/04/24/%E4%BB%A3%E7%BB%84%E6%9C%9F%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2019/04/24/代组期中笔记/</id>
    <published>2019-04-24T07:53:22.000Z</published>
    <updated>2019-04-24T08:02:23.761Z</updated>
    
    <content type="html"><![CDATA[<p>本来以为会特别硬核.. 一直在抢救证明题.. 结果最后一堆算实例.. gggg</p><p>在群同态基本定理上建立的知识体系.. 却想不清楚它本身是怎么证明的了.. QAQ</p><p>熬夜抢救考试之后突击测 12 分钟跑简直要了命了.. 这么个阴天也能晒伤我真是服了= =</p><a id="more"></a><p>Ir1d XD+, [21.04.19 22:36]<br>子群判定定理<br>子群格</p><p>Ir1d XD+, [22.04.19 14:44]<br>同态的表示形式<br>群同态定理</p><p>Ir1d XD+, [22.04.19 20:24]<br>置换之积 从右向左</p><p><img src="https://i.loli.net/2019/04/24/5cc0165ec623a.png" alt="20190424155509.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016626b4d2.png" alt="20190424155513.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01666c4f40.png" alt="20190424155517.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0166a51296.png" alt="20190424155521.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0166f9c76a.png" alt="20190424155525.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01682210af.png" alt="20190424155544.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016865d6f6.png" alt="20190424155549.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01689cc3f6.png" alt="20190424155552.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0168d3af9b.png" alt="20190424155556.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016927f18e.png" alt="20190424155559.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016951fc90.png" alt="20190424155604.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016989fbe3.png" alt="20190424155607.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0169b9a5bc.png" alt="20190424155610.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0169f7caed.png" alt="20190424155613.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016a42b2b5.png" alt="20190424155618.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016a7a1c18.png" alt="20190424155621.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016abc53fd.png" alt="20190424155626.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016af2b3d9.png" alt="20190424155629.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016b2d4eb9.png" alt="20190424155633.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016dd8294b.png" alt="20190424155715.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016ba9b73f.png" alt="20190424155641.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016e599a0c.png" alt="20190424155724.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016e913680.png" alt="20190424155727.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016ec7f110.png" alt="20190424155731.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc016f6cdd72.png" alt="20190424155741.png"></p><p>于是期中就考完了吧.. 冷静分析一下其实这学期一直在翘课，期中复习得也很仓促.. 中间病得很厉害.. 然后是不是还有 challenge 翻车需要背锅.. 就很僵硬.. 下半学期也好不到哪里去吧.. 一万个大作业.. 三个 kaggle.. 然后还有 4 个 pre.. 一篇综述.. 希望期末可以认认真真地认认真真..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来以为会特别硬核.. 一直在抢救证明题.. 结果最后一堆算实例.. gggg&lt;/p&gt;
&lt;p&gt;在群同态基本定理上建立的知识体系.. 却想不清楚它本身是怎么证明的了.. QAQ&lt;/p&gt;
&lt;p&gt;熬夜抢救考试之后突击测 12 分钟跑简直要了命了.. 这么个阴天也能晒伤我真是服了= =&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="代数结构" scheme="https://ir1d.cf/tags/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>概统期中笔记</title>
    <link href="https://ir1d.cf/2019/04/24/%E6%A6%82%E7%BB%9F%E6%9C%9F%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2019/04/24/概统期中笔记/</id>
    <published>2019-04-24T07:48:40.000Z</published>
    <updated>2019-04-24T07:53:04.382Z</updated>
    
    <content type="html"><![CDATA[<p>我发现上回整理了这个 post 的模板之后根本就没写过 post.. gg</p><p>概统这波.. 讲道理没什么难度的.. 是我送了</p><a id="more"></a><p><img src="https://i.loli.net/2019/04/24/5cc0152fa8789.png" alt="20190424155005.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0154722af5.png" alt="20190424155029.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0154e5352e.png" alt="20190424155037.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01553b4472.png" alt="20190424155042.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0155a035d9.png" alt="20190424155048.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0156b0dd4b.png" alt="20190424155106.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01570610a6.png" alt="20190424155111.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01576523c5.png" alt="20190424155117.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc0157cb663e.png" alt="20190424155123.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc015810c873.png" alt="20190424155127.png"></p><p><img src="https://i.loli.net/2019/04/24/5cc01587600cb.png" alt="20190424155134.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我发现上回整理了这个 post 的模板之后根本就没写过 post.. gg&lt;/p&gt;
&lt;p&gt;概统这波.. 讲道理没什么难度的.. 是我送了&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="概率统计" scheme="https://ir1d.cf/tags/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>groupsNotes-0417</title>
    <link href="https://ir1d.cf/2019/04/17/groupsNotes-0417/"/>
    <id>https://ir1d.cf/2019/04/17/groupsNotes-0417/</id>
    <published>2019-04-17T08:37:25.000Z</published>
    <updated>2019-04-24T11:39:23.607Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录一下 Very very good Paper Reading Group 的讨论</li></ul><a id="more"></a><ul><li><a href="https://blog.csdn.net/haolexiao/article/details/65157026" target="_blank" rel="noopener">https://blog.csdn.net/haolexiao/article/details/65157026</a> 一种从离散概率分布里高效采样的方法 如果概率分布是固定的话，可以替换 np.random.choice</li><li>fastai 好香</li><li>OctConv<ul><li>这个也挺有意思的，把conv的channel分成高频和低频两个部分</li><li>低频的channel部分 feature map的size是 1/4</li><li>motivation是图像可以分成高低频两部分</li><li>可以看一下去年的一个dual cnn：两个branch处理图片，一个高频一个低频 </li><li>可能是因为，同计算量️下，有效计算量大了</li><li>Image to image translation 主要在image generation上用的多</li></ul></li><li><a href="https://arxiv.org/pdf/1904.06690.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1904.06690.pdf</a><ul><li>scc: 试过用bert做推荐的，那时候跑出来结果和transformer是一样的</li></ul></li><li>neural nearst neighboor <a href="https://arxiv.org/pdf/1810.12575.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1810.12575.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录一下 Very very good Paper Reading Group 的讨论&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="paperReading" scheme="https://ir1d.cf/categories/paperReading/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>Precision-Recall 曲线</title>
    <link href="https://ir1d.cf/2019/02/27/Precision-Recall-%E6%9B%B2%E7%BA%BF/"/>
    <id>https://ir1d.cf/2019/02/27/Precision-Recall-曲线/</id>
    <published>2019-02-27T10:39:14.000Z</published>
    <updated>2019-04-24T08:08:01.704Z</updated>
    
    <content type="html"><![CDATA[<ul><li>绘制 Precision-Recall 曲线过程中的一些思考</li></ul><a id="more"></a><p>也不能说是思考吧… 菜爆了好吗…</p><p>现象是我在画一个 object detection 的算法的 pr 曲线,画出来之后发现他好像 recall ~ 0 的时候, precision 不到 1…然而一般在网上看到的那种 pr 曲线是过 (recall=0, precision=1) 这个点的…</p><p>这里面怎么回事呢?</p><p>思考 pr 曲线是怎么测的?</p><p>我们枚举一个 confidence 的 thresh, 就得到很多 (precision, recall) 的数对.</p><p>这个 confidence 什么时候接近 y 轴呢?换言之,什么时候 recall 很小呢?</p><p>一个例子是我预测的就很少,自然 recall 也小.</p><p>为什么 precision 一般是 1 呢? 因为预测少的时候 confidence 是枚举到了很大的位置,这时的预测基本上都是准的..</p><p>那我测的这个为什么不是 1 呢? 它 confidence 最高的那个 box 就是错的, 而因为我枚举的 thresh 是每次增 0.001,所以 0.999 这一档并不都是准的…</p><h2 id="upd"><a href="#upd" class="headerlink" title="upd"></a>upd</h2><p>读这个的时候意识到好像哪里不太对 <a href="https://github.com/Cartucho/mAP/blob/master/main.py#L489" target="_blank" rel="noopener">https://github.com/Cartucho/mAP/blob/master/main.py#L489</a></p><p>简而言之实际上不需要 confidence 是 0/1 之间的，我们只需要对 confidence 排个序就好了。</p><p>思考这个枚举 confidence 的过程，是一个我们逐渐考虑更多的 bounding box 样本的过程.. 所以和我们排个序之后从上到下逐渐处理更多的样本是本质一样的过程.. 所以搞个前缀和就好了= =</p><p>还是挺 make sense 的，可惜我想了这么长时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;绘制 Precision-Recall 曲线过程中的一些思考&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="precision-recall" scheme="https://ir1d.cf/tags/precision-recall/"/>
    
  </entry>
  
  <entry>
    <title>Photoshop 脚本 again</title>
    <link href="https://ir1d.cf/2019/02/27/Photoshop-%E8%84%9A%E6%9C%AC-again/"/>
    <id>https://ir1d.cf/2019/02/27/Photoshop-脚本-again/</id>
    <published>2019-02-27T10:36:26.000Z</published>
    <updated>2019-02-27T10:47:07.588Z</updated>
    
    <content type="html"><![CDATA[<ul><li>搞了个脚本来把 arw 转成 png</li></ul><a id="more"></a><p>本来用 mogrify 然后 xargs 一下跑满 8 核超爽,然后突然发现这个好像 ubuntu 上面读 arw (RAW图片) 的那个工具读出来尺寸不对… 本来是 6000x4000 的图,它给读成 6024x4024,转了几天的都白转了…</p><p>于是开动 Photoshop</p><p>本来录了个动作,然后批处理一波</p><p>没想到这个批处理跑上几个小时之后自己就停了…</p><p>心态崩了,于是把上回的脚本拿来改改</p><p>(to be released)</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;搞了个脚本来把 arw 转成 png&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="photoshop" scheme="https://ir1d.cf/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>Single Shot MultiBox Detector 笔记</title>
    <link href="https://ir1d.cf/2019/02/15/Single-Shot-MultiBox-Detector-%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2019/02/15/Single-Shot-MultiBox-Detector-笔记/</id>
    <published>2019-02-15T04:10:06.000Z</published>
    <updated>2019-02-15T04:10:56.623Z</updated>
    
    <content type="html"><![CDATA[<ul><li>SSD - Single Shot MultiBox Detector</li></ul><a id="more"></a><h2 id="主要解决什么问题"><a href="#主要解决什么问题" class="headerlink" title="主要解决什么问题"></a>主要解决什么问题</h2><p>解决 bounding box proposal 太慢的问题，作者表示我们可以干掉这一阶段，同时准确性也差不多好</p><h2 id="解决的思路"><a href="#解决的思路" class="headerlink" title="解决的思路"></a>解决的思路</h2><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h2 id="改进（？）"><a href="#改进（？）" class="headerlink" title="改进（？）"></a>改进（？）</h2><h2 id="other-comment"><a href="#other-comment" class="headerlink" title="other comment"></a>other comment</h2>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;SSD - Single Shot MultiBox Detector&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>Faster RCNN</title>
    <link href="https://ir1d.cf/2019/02/14/Faster-RCNN/"/>
    <id>https://ir1d.cf/2019/02/14/Faster-RCNN/</id>
    <published>2019-02-14T13:58:34.000Z</published>
    <updated>2019-02-14T16:32:24.743Z</updated>
    
    <content type="html"><![CDATA[<ul><li>来记一下 Faster RCNN 吧…… 免得没看多少又忘光了</li></ul><a id="more"></a><h2 id="主要解决什么问题"><a href="#主要解决什么问题" class="headerlink" title="主要解决什么问题"></a>主要解决什么问题</h2><p>目标检测之前都在用 selective search，实在是太慢了。</p><h2 id="解决的思路"><a href="#解决的思路" class="headerlink" title="解决的思路"></a>解决的思路</h2><p>这篇工作搞了个 Region Proposal Network，把生成 proposal 的工作交给 GPU，可以加速</p><p><img src="https://i.loli.net/2019/02/14/5c6574ea53f7b.png" alt="20190214220216.png"></p><p>无处不在的 Attention……</p><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h3><p><img src="https://i.loli.net/2019/02/14/5c6585693b966.png" alt="20190214231238.png"></p><p>用一个 3x3 的滑动窗口去处理 feature，然后把它送进一个 box-regression 和一个 box-classification 网络（都是全连接的）。<br>cls 和 reg 网络实际上用的是 1x1 卷积。</p><p>在滑动的过程中，每一点上，造九个 box 出来（3种大小 x 3种尺寸）。</p><p>不能训练左右的 anchor，否则由于负样本过多可能模型对正样本不是那么敏感。</p><p>新的层用标准差为 0.01 的高斯分布初始化，之前的其它层用 imagenet 上的分类网络 pretrain</p><h3 id="训练方式"><a href="#训练方式" class="headerlink" title="训练方式"></a>训练方式</h3><p>想要共享 RPN 和 Fast RCNN 之间的 feature</p><p>Alternating：先 RPN，再用 proposal 去训练 Fast RCNN。得到的网络再去初始化 RPN。迭代地来</p><p>Approximate Joint：一起训练，每一轮 SGD 里，先得到proposal，然后假装它是固定的，来训练 Fast RCNN。</p><p>作者表示这种做法忽视了 RPN 网络生成的bounding box 的坐标的梯度（后面直接用了，梯度没有传播），因此只是近似的方法</p><p>Non-Approximate Joint：</p><p>需要一个 <code>RoI warping</code> 层来解决上面梯度的问题。。感觉意思是搞了个梯度不会丢失的 ROI pooling 层？</p><p>4-Step Alternating：</p><ol><li>先训 RPN（用 ImageNet 上 pretrain的 model，在一个 region proposal task 上面 fine-tune）</li><li>用 Fast RCNN 训练一个独立的 detection 网络（利用上一步得到的 proposal）。注：这个也是 ImageNet pretrain，这一步之后两个网络还没有共享卷积层。</li><li>用 detector network 来初始化 RPN 的训练，但是固定住共享的卷积层的权重，只 fine-tune RPN 中独立的层。（现在这两个网络有共享的卷积层了。</li><li>最后继续固定那几个层的权重，fine-tune 只在 Fast-RCNN 里的层。</li></ol><h3 id="nms"><a href="#nms" class="headerlink" title="nms"></a>nms</h3><p>non-maximum suppression，用来消灭重复的 porposal regions（根据 cls 分数来评定）。paper 里写的 IoU threshold 竟然是 0.7……</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h2 id="改进（？）"><a href="#改进（？）" class="headerlink" title="改进（？）"></a>改进（？）</h2><h2 id="other-comment"><a href="#other-comment" class="headerlink" title="other comment"></a>other comment</h2><p><a href="http://closure11.com/rcnn-fast-rcnn-faster-rcnn%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/" target="_blank" rel="noopener">http://closure11.com/rcnn-fast-rcnn-faster-rcnn%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;来记一下 Faster RCNN 吧…… 免得没看多少又忘光了&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>Face Detection Demo 评测</title>
    <link href="https://ir1d.cf/2019/02/11/Face-Detection-Demo-%E8%AF%84%E6%B5%8B/"/>
    <id>https://ir1d.cf/2019/02/11/Face-Detection-Demo-评测/</id>
    <published>2019-02-11T13:00:24.000Z</published>
    <updated>2019-02-11T15:51:07.811Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Face Detection 代码测试</li></ul><a id="more"></a><p>总体来说其实 doc 都蛮清楚，搞了这么久其实还是自己基本功不够扎实</p><p>Google 真好用.webp</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><a href="https://github.com/mahyarnajibi/SSH" target="_blank" rel="noopener">https://github.com/mahyarnajibi/SSH</a></p><p>编译 <code>caffe-ssh</code> 之后要把 <code>caffe-ssh/python</code> 塞进 <code>PYTHONPATH</code>，方法是 <code>echo $PYTHONPATH=xxx</code></p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p><a href="https://github.com/sciencefans/RSA-for-object-detection" target="_blank" rel="noopener">https://github.com/sciencefans/RSA-for-object-detection</a></p><p>需要 matlab。</p><p>跑的时候可能需要自己 <code>addpath</code>，一个是加那个 <code>caffemex</code> 下面的 <code>matlab</code> 文件夹（类似上面的 pycaffe），另一个是要加 <code>predict/utils/bin</code> 这个目录，因为底下有 <code>nms_mex</code> 这个东西……</p><p><code>caffemex</code> 编译的时候如果 <code>make test</code> 如果报错是正常的，好像是因为魔改版的 caffe 加了新层没有加上配套的测试用例</p><h2 id="face-py-faster-rcnn"><a href="#face-py-faster-rcnn" class="headerlink" title="face-py-faster-rcnn"></a>face-py-faster-rcnn</h2><p>这个比 Detectron 要扎心得多……</p><p><a href="https://github.com/playerkk/face-py-faster-rcnn" target="_blank" rel="noopener">https://github.com/playerkk/face-py-faster-rcnn</a></p><p>他那个远古的 caffe-faster-rcnn 有问题，搜索一波得知使用 <code>merge -X theirs</code> 这种方式把新的 caffe 合进来就行（caffe 那个仓库就行，不是非得要 pytorch 里的那个）</p><p>它 README 拉到最下面才是那个 face 上面训的 model，不然前面那堆 model 其实都是直接在 wider 上面训的（印象中）</p><p>然后那个 <code>tools/demo.py</code> 里面找 model 的时候可能有些不尽人意，用的时候就写死成本机绝对路径就好了</p><h2 id="HR-ER"><a href="#HR-ER" class="headerlink" title="HR_ER"></a>HR_ER</h2><p>需要 matlab 环境</p><p><a href="https://github.com/peiyunh/tiny" target="_blank" rel="noopener">https://github.com/peiyunh/tiny</a></p><p>编译 matconvnet 的时候请务必指定 cudaRoot 和 cudnnRoot，否则可能看起来很正常然而 <code>CUDNN_STATUS_BAD_PARAM</code> 或者 <img src="https://i.loli.net/2019/02/11/5c618449c3b2e.png" alt="20190211221848.png"></p><p>其实应该这样的啦<br><img src="https://i.loli.net/2019/02/11/5c61845b33874.png" alt="20190211221907.png"></p><p>后面都海星，注意那个 <code>cd utils</code> 是指的是 tiny 下面的那个 utils = =</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Face Detection 代码测试&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>OI Wiki 相关的技能点</title>
    <link href="https://ir1d.cf/2019/02/09/OI-Wiki-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E8%83%BD%E7%82%B9/"/>
    <id>https://ir1d.cf/2019/02/09/OI-Wiki-相关的技能点/</id>
    <published>2019-02-09T06:43:08.000Z</published>
    <updated>2019-04-24T08:09:48.446Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录下吧，免得吹逼的时候忘记了（×</li></ul><a id="more"></a><ol><li>python-markdown + mkdocs 的方案（当时还不知道有 vuepress）</li><li>找到 remarkjs 来做 lint，而且搞了几个自用的插件，似乎和 pymdownx 还算是兼容</li><li>魔改 gitment，后换用 gitalk</li><li>大量修改 mkdocs-material 的主题（React）</li><li>搭建 elasticsearch 替换原有搜索（比 Algolia Docsearch 不知道高到哪里去了）</li><li>nginx 配置 brotil，gzip，用 acme.sh 签证书，配置 patch、一系列优化</li><li>用 mathjax-node 配置服务器端渲染 mathjax （mathjax-ssr 雾）</li><li>配置 gulp 来压缩构建产物等一系列操作（感谢 @Margatroid 大佬 carry）</li><li>配置 instantClick（感谢 @frank 大佬 carry）</li></ol><pre><del>10. 这玩意肯定能凑出来十条的</del></pre><ol><li>搞了个 lintbot，自动对 pr 做 lint</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录下吧，免得吹逼的时候忘记了（×&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="oiwiki" scheme="https://ir1d.cf/tags/oiwiki/"/>
    
  </entry>
  
  <entry>
    <title>mkdocs 配置 Elasticsearch</title>
    <link href="https://ir1d.cf/2019/01/23/mkdocs-%E9%85%8D%E7%BD%AE-Elasticsearch/"/>
    <id>https://ir1d.cf/2019/01/23/mkdocs-配置-Elasticsearch/</id>
    <published>2019-01-23T13:40:16.000Z</published>
    <updated>2019-01-24T06:38:29.997Z</updated>
    
    <content type="html"><![CDATA[<ul><li>mkdocs 配置 Elasticsearch</li></ul><a id="more"></a><p>按照 <a href="https://imququ.com/post/elasticsearch.html" target="_blank" rel="noopener">https://imququ.com/post/elasticsearch.html</a></p><p>除了 elasticsearch.yml 里不需要再配置 analyzer，现在新版本是在建 index 的时候放到 setting 字段里 <a href="https://github.com/elastic/elasticsearch/issues/2630" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/issues/2630</a></p><p>分词插件在 <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p><p>ubuntu 上面按照官网的来直接 apt 装，比 docker 还方便（雾）</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>用 express 封装了一下搜索和查询结果（main.js）</p><p>关于 cors，还是被坑了一下，在 oi-wiki.org 搜的时候，存到了 cache 里，再用别的域名搜的时候，就会被 cors 给拦住。需要加上 <code>add_header &#39;Vary&#39; &quot;Origin&quot;;</code>，来告诉 client side 这个 cors 的域名可能会有多种情况。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>主要改的 <code>assets/javascripts/components/Material/Search/Result.jsx</code>，因为不想每打一个字就发一个请求，就给 delay 了一下，参见 <a href="https://github.com/Ir1d/mkdocs-material/tree/es" target="_blank" rel="noopener">https://github.com/Ir1d/mkdocs-material/tree/es</a></p><h2 id="es-配置"><a href="#es-配置" class="headerlink" title="es 配置"></a>es 配置</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>（init.js）</p><p><code>client.bulk</code> 是个好东西</p><h3 id="搭配-github-webhook"><a href="#搭配-github-webhook" class="headerlink" title="搭配 github webhook"></a>搭配 github webhook</h3><p>用的是 <code>modified</code> 和 <code>remoed</code> 字段，过程和导入类似。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>分别是 <code>h1</code>, <code>h2</code>, <code>content</code>（全文）, <code>url</code>（方便前端直接调，其实写在 express 也行，当时没考虑那么多）</p><p>由于全文之前是 markdown 文档，这里是用 <code>strip-markdown-math</code> 给 markdown 格式删一删（不过还剩了很多空行没删掉= =），由于 <code>strip-markdown</code> 不删掉数学公式（<code>remark-math</code> 是外部插件），所以我就封装（fork）了下。</p><p>相关代码：<a href="https://gist.github.com/Ir1d/eb1cc5d749be93238f3a4118156e5b5b" target="_blank" rel="noopener">https://gist.github.com/Ir1d/eb1cc5d749be93238f3a4118156e5b5b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;mkdocs 配置 Elasticsearch&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mkdocs" scheme="https://ir1d.cf/tags/mkdocs/"/>
    
      <category term="Elasticsearch" scheme="https://ir1d.cf/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Photoshop 脚本</title>
    <link href="https://ir1d.cf/2019/01/10/Photoshop-%E8%84%9A%E6%9C%AC/"/>
    <id>https://ir1d.cf/2019/01/10/Photoshop-脚本/</id>
    <published>2019-01-10T15:07:06.000Z</published>
    <updated>2019-01-10T15:12:21.849Z</updated>
    
    <content type="html"><![CDATA[<ul><li>11 月末写了个 ps 脚本来整理图片…… 一直没来得及记录</li></ul><a id="more"></a><p>需求是给每组图片对齐，拍的时候误差不是很大，对齐就用自动对齐就行。可惜图片数量太多，大概 4k 张，一组 5-7 张，手动来怕是要难受死。</p><p>用 ps 来操作的话，大概就是打开文件到图层，对齐，然后导出各图层至文件。开始的时候还试用现成的那个导入文件到堆栈，可惜和后面的操作接不上= = 不过那个导出图片的还是好用的 XD</p><p>对齐之后遇到了个问题，会对齐出来白边，然而我需要从这组图中找到一个尽量大的有色矩形。。。折腾了好久也没弄明白，最后搜到刚好前几天有人发布了一个解决方案。爽爆：<a href="https://developer71240.github.io/crop-to-opaque/" target="_blank" rel="noopener">https://developer71240.github.io/crop-to-opaque/</a></p><p>（不过人家禁止再分发，所以我的 gist 里面删掉了那部分，把人家的那段粘进 crop 函数就好啦）</p><p>Gist：<a href="https://gist.github.com/Ir1d/14af313f15d3fc91b23e70897daa2ca4" target="_blank" rel="noopener">https://gist.github.com/Ir1d/14af313f15d3fc91b23e70897daa2ca4</a></p><p>总体来说 Ps 的脚本体验及其糟糕…… 文档奇差，不过海星吧，印象中它是扩展了某种 jsx，然后直接去看那种 jsx 的 api 就星。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;11 月末写了个 ps 脚本来整理图片…… 一直没来得及记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Photoshop" scheme="https://ir1d.cf/tags/Photoshop/"/>
    
      <category term="jsx" scheme="https://ir1d.cf/tags/jsx/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 笔记</title>
    <link href="https://ir1d.cf/2018/12/09/LeetCode-%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2018/12/09/LeetCode-笔记/</id>
    <published>2018-12-09T06:00:55.000Z</published>
    <updated>2018-12-09T10:46:23.130Z</updated>
    
    <content type="html"><![CDATA[<ul><li>LeetCode 笔记</li></ul><p>工具用的是 leetcode-cli，可惜这货在网站上登录之后本地 cli 存的 session 就掉了，又得重新登录</p><a id="more"></a><ul><li>342</li></ul><p>判断一个数是不是 4 的幂次。我们知道 2 的幂次的话是：<code>x &amp;&amp; (x &amp; (x - 1)) == 0</code>，4 的话只需要额外看一下二进制表示里所有的 1 都在最高位就行。</p><ul><li>405</li></ul><p>十进制转十六进制，想到可以 sprintf 一波，最简单</p><ul><li>665</li></ul><p>最长上升子序列：lower_bound<br>最长不下降子序列：upper_bound</p><ul><li>594</li></ul><p>求一个最长的子序列，使得它的最大值和最小值的差恰好为 1。</p><p>注意是子序列，所以就找相邻的两个数的出现次数之和的最大值咯</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;LeetCode 笔记&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工具用的是 leetcode-cli，可惜这货在网站上登录之后本地 cli 存的 session 就掉了，又得重新登录&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="https://ir1d.cf/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>CF950F Treeland Tour</title>
    <link href="https://ir1d.cf/2018/12/07/CF950F-Treeland-Tour/"/>
    <id>https://ir1d.cf/2018/12/07/CF950F-Treeland-Tour/</id>
    <published>2018-12-07T11:53:03.000Z</published>
    <updated>2019-04-24T08:09:31.854Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一个点有权值的无根树，求一个链，使得这个链上的点权的 lis 长度最大</li></ul><a id="more"></a><p>说起来是我打的第一次 cf 吧……</p><p>很科学的做法：</p><p><a href="https://www.cnblogs.com/cxhscst2/p/7219887.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxhscst2/p/7219887.html</a></p><p>通过一次 dfs 把它转换成从子树向上合并答案的过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;一个点有权值的无根树，求一个链，使得这个链上的点权的 lis 长度最大&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="codeforces" scheme="https://ir1d.cf/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2002</title>
    <link href="https://ir1d.cf/2018/12/07/POJ-2002/"/>
    <id>https://ir1d.cf/2018/12/07/POJ-2002/</id>
    <published>2018-12-07T10:15:40.000Z</published>
    <updated>2018-12-07T10:16:55.776Z</updated>
    
    <content type="html"><![CDATA[<ul><li>POJ 2002</li></ul><a id="more"></a><p>平面上一堆点，数能组成多少个正方形</p><p>枚举一条边（而不是枚举对角线</p><p>现在有了坐标怎么判断是否是正方形呢？</p><p>先看 4 边长相等，再看两个对角线相等。</p><p>数算这题写了好久。。好难过</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;POJ 2002&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="POJ" scheme="https://ir1d.cf/tags/POJ/"/>
    
  </entry>
  
  <entry>
    <title>g++ -Og 作用</title>
    <link href="https://ir1d.cf/2018/11/25/g-Og-%E4%BD%9C%E7%94%A8/"/>
    <id>https://ir1d.cf/2018/11/25/g-Og-作用/</id>
    <published>2018-11-25T14:46:45.000Z</published>
    <updated>2018-11-25T14:47:49.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>g++ -Og</code></li></ul><a id="more"></a><p>来自 <code>man g++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Options for Debugging Your Program</span><br><span class="line">       To tell GCC to emit extra information for use by a debugger, in almost</span><br><span class="line">       all cases you need only to add -g to your other options.</span><br><span class="line"></span><br><span class="line">       GCC allows you to use -g with -O.  The shortcuts taken by optimized</span><br><span class="line">       code may occasionally be surprising: some variables you declared may</span><br><span class="line">       not exist at all; flow of control may briefly move where you did not</span><br><span class="line">       expect it; some statements may not be executed because they compute</span><br><span class="line">       constant results or their values are already at hand; some statements</span><br><span class="line">       may execute in different places because they have been moved out of</span><br><span class="line">       loops.  Nevertheless it is possible to debug optimized output.  This</span><br><span class="line">       makes it reasonable to use the optimizer for programs that might have</span><br><span class="line">       bugs.</span><br><span class="line"></span><br><span class="line">       If you are not using some other optimization option, consider using -Og</span><br><span class="line">       with -g.  With no -O option at all, some compiler passes that collect</span><br><span class="line">       information useful for debugging do not run at all, so that -Og may</span><br><span class="line">       result in a better debugging experience.</span><br><span class="line">       -g  Produce debugging information in the operating system&apos;s native</span><br><span class="line">           format (stabs, COFF, XCOFF, or DWARF).  GDB can work with this</span><br><span class="line">           debugging information.</span><br><span class="line">           On most systems that use stabs format, -g enables use of extra</span><br><span class="line">           debugging information that only GDB can use; this extra information</span><br><span class="line">           makes debugging work better in GDB but probably makes other</span><br><span class="line">           debuggers crash or refuse to read the program.  If you want to</span><br><span class="line">           control for certain whether to generate the extra information, use</span><br><span class="line">           -gstabs+, -gstabs, -gxcoff+, -gxcoff, or -gvms (see below).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -Og&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="g++" scheme="https://ir1d.cf/tags/g/"/>
    
  </entry>
  
  <entry>
    <title>集合论…</title>
    <link href="https://ir1d.cf/2018/11/20/%E9%9B%86%E5%90%88%E8%AE%BA%E2%80%A6/"/>
    <id>https://ir1d.cf/2018/11/20/集合论…/</id>
    <published>2018-11-20T07:32:15.000Z</published>
    <updated>2018-11-20T07:35:42.217Z</updated>
    
    <content type="html"><![CDATA[<p>集图期中…… 范围是集合论</p><p>巧妙避开考点</p><p>时间比较紧，也没有整理多少出来，基本上直接在书上画了 = =</p><p>本文基本没有参考价值</p><p>嗯…… peano 系统…… F是单射！！</p><p>说起来还有件值得思考的事情，为什么可以在期中速成一门课的内容，而没有开学的时候就速成一波呢？</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/10709657/48658198-a6c98580-ea78-11e8-914a-659008b4ec9c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658199-af21c080-ea78-11e8-9d38-35ecd851235c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658228-1475b180-ea79-11e8-8246-5b91b5b2bd53.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658329-e2fde580-ea7a-11e8-93e6-f2e5ea2bbbb9.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658337-0032b400-ea7b-11e8-99b0-d4983e1133f8.png" alt="image"></p><p>第二类 stirling 计算<br>哈斯图要求 y 覆盖 x 的时候才连边，覆盖的意思是x &lt; y但是中间不存在z</p><p>n元集，多少个偏序关系：1, 1, 3, 19, 219(n=0,1,2,3,4)</p><p>传递集那一套理论<br>康托定理</p><p><img src="https://user-images.githubusercontent.com/10709657/48716632-b7cdee80-ec52-11e8-85ea-5eedb18f1c3f.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48716875-4478ac80-ec53-11e8-9fd3-1651eef6e7eb.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48717187-d8e30f00-ec53-11e8-9381-273bf6d0e89d.png" alt="image"></p><p>对称闭包会破坏传递性</p><p><img src="https://user-images.githubusercontent.com/10709657/48718497-7b9c8d00-ec56-11e8-9269-400cc42e0dd0.png" alt="image"></p><p>自然映射: f:A→A/R, f(a)=[a]R, R为A上等价关系</p><p><a href="https://zhidao.baidu.com/question/49517936.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/49517936.html</a></p><p>NxN -&gt; N 的映射<br><img src="https://user-images.githubusercontent.com/10709657/48718938-4ba1b980-ec57-11e8-875c-37bbd0ecda82.png" alt="image"></p><p>Cantor编码</p><p><img src="https://user-images.githubusercontent.com/10709657/48722516-29ac3500-ec5f-11e8-98f8-7ff5694bb70a.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集图期中…… 范围是集合论&lt;/p&gt;
&lt;p&gt;巧妙避开考点&lt;/p&gt;
&lt;p&gt;时间比较紧，也没有整理多少出来，基本上直接在书上画了 = =&lt;/p&gt;
&lt;p&gt;本文基本没有参考价值&lt;/p&gt;
&lt;p&gt;嗯…… peano 系统…… F是单射！！&lt;/p&gt;
&lt;p&gt;说起来还有件值得思考的事情，为什么可以在期中速成一门课的内容，而没有开学的时候就速成一波呢？&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="集合论与图论" scheme="https://ir1d.cf/tags/%E9%9B%86%E5%90%88%E8%AE%BA%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ics期中整理</title>
    <link href="https://ir1d.cf/2018/11/14/ics%E6%9C%9F%E4%B8%AD%E6%95%B4%E7%90%86/"/>
    <id>https://ir1d.cf/2018/11/14/ics期中整理/</id>
    <published>2018-11-14T03:59:59.000Z</published>
    <updated>2018-11-17T06:51:05.229Z</updated>
    
    <content type="html"><![CDATA[<p>可以说是巧妙地避开了考点吧，觉得还是对大家有点帮助的（</p><p>范围是 csapp 的 2-6 章。</p><p>upd: hcl 背错了，身败名裂</p><a id="more"></a><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>0：<br><img src="https://user-images.githubusercontent.com/10709657/48384428-48716f80-e725-11e8-97f5-74e0ad470460.png" alt="image"></p><p>补码：最高有效位是 -2^{w-1}<br>反码：最高有效位是 -(2^{w-1}-1)<br>原码：最高有效位是符号位，决定其余位的正负</p><p>short -&gt; unsigned 先改变大小，再完成有符号数到无符号数 —&gt; (unsigned)sx == (unsigned)(int)sx</p><p>算术右移补最高位，逻辑右移补 0</p><p>检测无符号数加法的溢出 P62</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uok</span> <span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">unsigned</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum &gt;= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有符号数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = x + y;</span><br><span class="line">  <span class="keyword">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos_over = x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> !neg_over &amp;&amp; !pos_over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补码加法构成阿贝尔群，可交换可结合</p><p>减法溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意测试 TMIN</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    (y == INT_MIN) &amp;&amp; (res = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// if (y == INT_MIN) res = 0;</span></span><br><span class="line">    <span class="keyword">int</span> sub = x - y;</span><br><span class="line">    <span class="keyword">int</span> pos_over = x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sub &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; sub &gt; <span class="number">0</span>;</span><br><span class="line">    res = res &amp;&amp; !(pos_over || neg_over);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-x == ~x+1</code> 对任意整数值一样</p><p>无符号和补码乘法，虽然完整的乘积的位级表示可能会不同，但是截断后乘积的位级表示是相同的</p><p><img src="https://user-images.githubusercontent.com/10709657/48301101-01b42780-e523-11e8-9b78-706ef72b86c9.png" alt="image"></p><p>无论无符号还是补码、是否溢出，<code>(x &lt;&lt; 4) - (x &lt;&lt; 1)</code> 都和 <code>(x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1)</code>相等</p><p>补码除法 <code>x &gt;&gt; k</code> 产生 下取整 <code>x/2^k</code><br>正常除法应该对负数上取整</p><p><img src="https://user-images.githubusercontent.com/10709657/48301231-75efca80-e525-11e8-96fc-e0af015bfd48.png" alt="image"></p><p>符号、尾数、阶码<br>1 8 23 （float）<br>1 11 52 （double）<br><img src="https://user-images.githubusercontent.com/10709657/48303065-8fead680-e540-11e8-93bb-389679fccc29.png" alt="image"></p><p>规格化<br>(1+f)<em>2^{exp-127}<br>非规格化<br>f</em>2^(-126)<br>正无穷：s = 0, exp=1111111, f = 0;<br>负无穷：s = 1, exp=1111111, f = 0;</p><p>可表示数越靠近原点约稠密</p><p><strong>P80</strong><br>最小的非规格化数 exp = 0, f = 1;<br>最大的非规格化数 exp = 0, f = 1111;<br>最小的规格化数 exp = 1, f = 0;<br>最大的规格化数 exp = 1110, f = 111;<br>无穷大 0 exp = 1111, f = 0;</p><p><img src="https://user-images.githubusercontent.com/10709657/48303175-fb817380-e541-11e8-9eef-21abb4597fbe.png" alt="image"></p><p>P83 - 2.49<br>P84 - 2.52<br>P87 - 2.54</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>P118 ATT与 intel汇编代码格式<br>float 4 double 8<br>P121 操作数格式<br>传送指令的两个操作数不能都指向内存位置<br>movz 把目的中的剩余字节填充为0，movs则是符号扩展<br>任何为寄存器生成32位值的指令都会把该寄存器的高位部分设为0，比如 movl，而其他时候只会更新目的操作数指定的那些寄存器字节或内存位置。<br>cltq: 把 eax 符号扩展到 rax 编码更紧凑<br>movabsq 传送绝对的四字<br>指示地址寄存器必须是 r开头，不能 <code>movb $1, (%eax)</code><br>movsbl 符号扩展<br>movzbl 0扩展<br>char -&gt; int: movsbl<br>int -&gt; char: movb<br>栈向下增长，栈顶元素地址最低<br>leaq直接操作 x，而movq操作地址 x 处的值<br>移位量可以是一个立即数，或者放在单字节寄存器 <code>%cl</code>中:sarq算术移位（填符号位），shrq逻辑移位（填0）<br>对应的 salq<br>移位操作的目的操作数可以使寄存器/内存地址<br>cqto<br><img src="https://user-images.githubusercontent.com/10709657/48312488-4ce53d80-e5ea-11e8-928d-7a0db84f0cae.png" alt="image"><br>一个参数存在 rax，另一个作为操作数给出，然后乘积：高64位在rdx，低64位在rax。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int128 <span class="keyword">uint128_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upord</span><span class="params">(uint128 *dest, <span class="keyword">uint64_t</span> x, <span class="keyword">uint64_t</span> y)</span> </span>&#123;</span><br><span class="line">  *dest = x * (<span class="keyword">uint128_t</span>) y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cqto,把 rax的符号扩展到rdx的所有位</p><p><img src="https://user-images.githubusercontent.com/10709657/48312544-2e337680-e5eb-11e8-9af8-95b82f391d76.png" alt="image"><br>leaq 不改变条件吗，inc和deq会设置溢出和零标志，但不改变进位。移位操作的仅为标志设置为最后一个被移除的位，溢出标志设为 0</p><p><code>cmp s1, s2 ==&gt; s2 - s1</code><br><code>test s1, s2 ==&gt; s1 &amp; s2</code><br>这两个只设置条件吗，不改变任何其他寄存器</p><p><img src="https://user-images.githubusercontent.com/10709657/48312556-8e2a1d00-e5eb-11e8-98ea-3f819ef8aaf0.png" alt="image"></p><p>条件跳转只能是直接跳转</p><p>直接跳转？？间接？？</p><p>T_ran = T_ok + 0.5T_MP（MP是预测错误）</p><p>cmove 条件传送</p><p>continue 会跳到当前循环迭代的结尾</p><p><code>&amp;&amp;</code> 创建一个指向代码为止的指针</p><p>函数调用时，通过寄存器，过程可以传递最多6个整数值<br>P调用Q时，把返回地址当做是 P的栈帧的一部分，因为它存放的是与P相关的状态<br>char 1字节 8位 short 2字节 16位 int 4字节 32位<br>switch ……<br>long至少要和int一样大，书上似乎认为 long 是8<br>用 leaq 生成到某个位置的指针<br>%rbx, %rbp, %r12-%r15为被调用者保存寄存器，当P调用Q时，Q必须保存这些寄存器的值<br>其他寄存器除了 %rsp，都是调用者保存寄存器，意味着任何函数都能修改他们，P调用Q的时候Q可以随意修改这个寄存器<br>返回数组值：操作类型为int，涉及四字节操作;movl和%eax<br>返回指针：操作类型为<code>int*</code>，涉及八字节：leaq，%rax<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> r3[<span class="number">3</span>];</span><br><span class="line">r3 a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></p><p>二维数组<br>$&amp;d[i][j] = x_d + L(Ci+j)$</p><p>sal 算术右移（填符号位），shl 逻辑右移（填0）<br>数据对齐：要求k字节类型对象的地址必须是k的倍数</p><p>malloc 返回一个通用指针 <code>void*</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> *p)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>*); <span class="comment">// 函数指针。</span></span><br></pre></td></tr></table></figure></p><p>rsp不能放第二个位置<br><code>(xxx, %rsp) 不合法</code></p><p>指针的差结果是两个地址之差除以该数据类型的大小</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>程序员可见的状态：<br><img src="https://user-images.githubusercontent.com/10709657/48349544-76bc6400-e6bf-11e8-80b5-a475021c371d.png" alt="image"><br><code>pushq %rsp</code>放的是原值<br><code>popq %rsp</code>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addq $8, %rsp</span><br><span class="line">mrmovq 8(%rsp), %rsp</span><br><span class="line">//如果后加的话就把 rsp的值又改了</span><br></pre></td></tr></table></figure></p><p><code>pushq %rsp</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq REG, -8(%rsp)</span><br><span class="line">subq $8, %rsp</span><br><span class="line">// 先减的话就不能把正确的值塞到栈里</span><br></pre></td></tr></table></figure></p><p>向寄存器的写入受时钟信号控制<br>寄存器文件有内部存储</p><p>valP在取指阶段得到<br>执行阶段设置条件码。写回阶段最多可以写两个结果到寄存器文件</p><p>程序寄存器的新值取自：vapP,下一条指令的地址，valC，调用指令或跳转指令指定的目标地址，valM，从内存读取的返回地址<br>组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播<br>每个时钟周期，程序计数器都会装载新的指令地址。只有在执行整数运算指令时，才会装载条件码寄存器。只有在执行rmmovq，pushq，call时，才会写数据内存。<br>只有 popq 会用到寄存器文件的两个写端口，为了把值放到 %esp，M端口优先级高于E<br>alu的输出是valE的信号<br>从头到尾执行一条指令所需时间为延迟，吞吐量为倒数<br>流水线的延迟是最大的一部分的延迟加上流水线寄存器的延迟<br>SEQ的延迟是各阶段之和加上流水线寄存器的延迟<br>转发：5个源：e_valE,m_valM,M_valE,W_valM,W_valE；2个转发目的：valA, valB<br>由流水线中最深的指令引起的异常，优先级最高<br>访存/写回阶段的指令异常时，流水线控制逻辑禁止更新条件码寄存器或是数据内存<br>出现异常时，信息只是简单地存放在流水线寄存器的状态字段中，异常事件不会对流水线中的指令流有任何影响。在写回阶段，流水线控制逻辑发现出现了异常，并停止执行。<br>只有 call 和跳转指令需要 valp 而这些指令不需要valA<br><img src="https://user-images.githubusercontent.com/10709657/48357545-d4f34200-e6d3-11e8-8b72-86ff6be7dabc.png" alt="image"><br>处于最早流水线阶段中的转发源具有较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令<br>只有 <code>popq %rsp</code> 关心访存和写回的转发优先级，因为只有他同时写两个寄存器</p><p><img src="https://user-images.githubusercontent.com/10709657/48360102-7204a980-e6d9-11e8-9355-7a296ec49959.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/10709657/48360114-76c95d80-e6d9-11e8-865f-6c4b74fe4be6.png" alt="image"><br>CPI是流水线平均吞吐量的倒数，单位是时钟周期，不是微微秒</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>关键路径是在循环的反复执行过程中形成的数据相关链<br>CPE 镁元素的周期数<br>编译器回家社函数有副作用，程序员需要显示完成代码移动<br>减少过程调用<br>消除不必要的内存引用<br>延迟界限：下一条指令开始前，这条必须结束 — 数据相关<br>吞吐量界限：处理器功能单元的原始计算能力<br>循环寄存器之间的操作链决定了限制性能的数据相关<br>比较和分支操作不直接影响程序中的数据流<br>练习题5.6 n次乘法，n次加法，<code>i--</code>不在关键路径上<br>循环展开<br>使用多个累计变量 —- 多路并行<br>重新结合变换，增加了可以并行执行的操作数量<br>大多数编译器不会尝试的对浮点运算做重新结合，因为这些运算不保证是可结合的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 慢</span><br><span class="line">acc = (acc OP data[i]) OP data[i + 1];</span><br><span class="line">// 快</span><br><span class="line">acc = acc OP (data[i] OP data[i + 1]);</span><br></pre></td></tr></table></figure></p><p>练习题 5.8 最快的是 A3A4<br>寄存器溢出<br>分支预测和预测错误出发<br>不要过分关心可预测的分支<br>书写适合用条件传送实现的代码<br>消除连续的函数调用，将计算移到循环外<br>消除不必要的内存引用，引入临时变量来保存中间结果<br>低级优化，结构化代码以利用硬件功能</p><ul><li>展开循环</li><li>使用多个累计变量、重新结合，提高指令级并行</li><li>用功能性的风格重写条件操作，使得编译采用条件数据传送</li></ul><p><img src="https://user-images.githubusercontent.com/10709657/48364664-f5c39380-e6e3-11e8-9c27-ccbdb713bc6d.png" alt="image"></p><p>B不对是因为可能A和B指向的是同一块内存区域</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>寻道时间和旋转延迟 4ms，传送时间 <code>0.02ms（1/RPM/（每磁道平均扇区数）*60）</code><br>读SSD比写要快，随机读写的性能差别由底层闪存基本属性决定<br>数据以页为单位读写，只有在一页所属的块整个被擦除之后，才能写这一页。一个快在 100000 次重复写之后会磨损坏。<br>SRAM比DRAM快，DRAM比磁盘快，SRAM比DRAM贵，DRAM比磁盘贵，SSD位于DRAM和磁盘之间<br>循环有很好地时间（循环体会被执行多次）和空间局部性<br>数组有空间局部性<br>数据以块为大小在第k层和k+1层之间来回复制的<br>随机替换策略、LRU策略（最近最少被使用）</p><p><img src="https://user-images.githubusercontent.com/10709657/48365499-0d9c1700-e6e6-11e8-94db-70a19bb24200.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48365524-2278aa80-e6e6-11e8-9c78-c10c5ea590bb.png" alt="image"><br>E=1 — 直接映射高速缓存</p><h2 id="补"><a href="#补" class="headerlink" title="补"></a>补</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp *%rax #目标为寄存器中的值</span><br><span class="line">jmp *(%rax) #以寄存器中的值作为读地址，从内存中读出跳转目标</span><br></pre></td></tr></table></figure><p>CISC指令数量较多，有些指令的执行周期很长 ，<br>编码是可变长度的，支持复杂的寻址方式，栈密<br>集的过程链接，代码长度一般较短，取址部件更复杂。<br>RISC指令较少，没有执行周期很长的指令，编码固定长度，<br>只有简单的寻址方式，寄存器密集的过程链接，代码长度<br>较长，没有条件码<br><img src="https://user-images.githubusercontent.com/10709657/48426375-9d52cb80-e7a1-11e8-8fd3-79bd33c97822.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以说是巧妙地避开了考点吧，觉得还是对大家有点帮助的（&lt;/p&gt;
&lt;p&gt;范围是 csapp 的 2-6 章。&lt;/p&gt;
&lt;p&gt;upd: hcl 背错了，身败名裂&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ics" scheme="https://ir1d.cf/tags/ics/"/>
    
      <category term="csapp" scheme="https://ir1d.cf/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>数算期中整理</title>
    <link href="https://ir1d.cf/2018/11/14/%E6%95%B0%E7%AE%97%E6%9C%9F%E4%B8%AD%E6%95%B4%E7%90%86/"/>
    <id>https://ir1d.cf/2018/11/14/数算期中整理/</id>
    <published>2018-11-14T03:56:17.000Z</published>
    <updated>2018-11-14T03:59:44.305Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一些 ppt 上和复习过程中觉得自己不够扎实的</p><p>其实压中了几个题，可惜还是疏忽了…… 算法填空竟然 CE 了。</p><p>没看到那个栈中元素是指针。。</p><a id="more"></a><ol><li>判断序列是否是出栈序列</li><li>中缀表达式转后缀表达式</li><li>栈 队列 互相模拟</li></ol><p>编辑距离<br>kmp<br>N个节点的树有多少种<br>试证明，在具有n(n&gt;=1)个结点的k叉树中，有n(k-1)+1个指针是空的。<br>出栈序列计数 卡特兰数<br>通配符匹配<br>N0 = N2+1<br>堆是一颗完全二叉树节点的层次序列<br>带权并查集 扩展 kmp kmp 的应用 kmp 自动机<br>堆  P120<br>已知二叉树的先序序列和中序序列，可以唯一确定一棵二叉树<br><img src="https://user-images.githubusercontent.com/10709657/47954102-44c14880-dfc1-11e8-9fd4-c2d38505a26b.png" alt="image"></p><p><a href="https://wenku.baidu.com/view/ec8f638dbb68a98271fefafe.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ec8f638dbb68a98271fefafe.html</a><br><a href="https://wenku.baidu.com/view/aa6845d30029bd64793e2c2e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/aa6845d30029bd64793e2c2e.html</a><br><img src="https://user-images.githubusercontent.com/10709657/47990818-73efcb00-e123-11e8-93ff-223859eb5e7b.png" alt="image"><br>要减一</p><p>k叉哈夫曼树 (n-1)%(k-1)==0 否则补虚拟节点<br>书上的 kmp 板子</p><p>非递归 dfs<br><img src="https://user-images.githubusercontent.com/10709657/47996962-41e76480-e135-11e8-91e2-9dd3be4ab7e3.png" alt="image"></p><p>两个队列模拟栈<br>队列、栈、堆与数据结构的存储结构无关<br> 在一个具有n个结点的有序单链表中插入一个新结点并仍保持其有序的时间复杂度为 O(N)<br>表达式求值，和栈顶运算符优先级相同的话也要弹出（比如减号会把加号弹出</p><p>BST 的删除 P118</p><p><img src="https://user-images.githubusercontent.com/10709657/48001194-cab8cd00-e142-11e8-8d8c-924bacd88c77.png" alt="image"></p><p>出栈序列计数：1/(n+1) *C(2n,n)种</p><p><img src="https://user-images.githubusercontent.com/10709657/48070074-02db1100-e212-11e8-9b46-e31857a91385.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48005022-56cff200-e14d-11e8-84f4-a71fb711feec.png" alt="image"></p><p>堆向下调整的时候是把小的儿子换上来</p><p><img src="https://user-images.githubusercontent.com/10709657/48005677-fd68c280-e14e-11e8-88a8-c8c51f056b1a.png" alt="image"></p><p>队列模拟栈 每一时刻ab只有一个为空<br><img src="https://user-images.githubusercontent.com/10709657/48007203-1626a780-e152-11e8-91ef-f883cd5a0c15.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一些 ppt 上和复习过程中觉得自己不够扎实的&lt;/p&gt;
&lt;p&gt;其实压中了几个题，可惜还是疏忽了…… 算法填空竟然 CE 了。&lt;/p&gt;
&lt;p&gt;没看到那个栈中元素是指针。。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法课程" scheme="https://ir1d.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Comparative Study on Generative Adversarial Networks</title>
    <link href="https://ir1d.cf/2018/10/20/Comparative-Study-on-Generative-Adversarial-Networks/"/>
    <id>https://ir1d.cf/2018/10/20/Comparative-Study-on-Generative-Adversarial-Networks/</id>
    <published>2018-10-20T13:21:14.000Z</published>
    <updated>2018-10-20T15:26:03.673Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Comparative Study on Generative Adversarial Networks</li></ul><a id="more"></a><h2 id="Comparative-Study-on-Generative-Adversarial-Networks"><a href="#Comparative-Study-on-Generative-Adversarial-Networks" class="headerlink" title="Comparative Study on Generative Adversarial Networks"></a>Comparative Study on Generative Adversarial Networks</h2><p>这篇 comparative study 试图比较原版和各种不同修改版的 GAN 的异同之处。</p><p><img src="https://i.loli.net/2018/10/20/5bcb4887b26c3.png" alt=""><br><img src="https://i.loli.net/2018/10/20/5bcb4887963a5.png" alt=""></p><p>$D(x)$ 是 x 来自原始数据而不是 $p_g$ 的概率。D 要最大化 $logD(x)$，而 G 要最小化 $log(1-D(G(z)))$。但是这样做的话 G 的梯度不适合用来训练，就把 objective function 修改一下，变成让D最大化 $logD(G(z))$</p><p><img src="https://i.loli.net/2018/10/20/5bcb4887a4bc9.png" alt=""></p><h3 id="CGAN"><a href="#CGAN" class="headerlink" title="CGAN"></a>CGAN</h3><p><img src="https://i.loli.net/2018/10/20/5bcb4887eabd6.png" alt=""><br>Conditional Generative Adversarial Network，简称 CGAN，这里把噪声 z 和条件 y 同时送进 G。<br><img src="https://i.loli.net/2018/10/20/5bcb488794302.png" alt=""></p><h3 id="LAPGAN"><a href="#LAPGAN" class="headerlink" title="LAPGAN"></a>LAPGAN</h3><p>Laplacian Pyramid of Adversarial Networks，简称 LAPGAN，这里构建了一个拉普拉斯金字塔，金字塔的每一层是一个 CGAN</p><h3 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h3><p>Deep Convolutional Generative Adversarial Networks，主要特点是：去掉了全连接和 pooling 层，全部使用卷积层；在 G 和 D 中都使用了 BN；在 G 中，除了最后一层，每一层之后都跟了 ReLU，而在 D 中，每一层后面跟了 LeakyReLU。</p><p><img src="https://i.loli.net/2018/10/20/5bcb48889218d.png" alt=""></p><h3 id="Adversarial-Autoencoder"><a href="#Adversarial-Autoencoder" class="headerlink" title="Adversarial Autoencoder"></a>Adversarial Autoencoder</h3><p><img src="https://i.loli.net/2018/10/20/5bcb48887eb9e.png" alt=""></p><h3 id="GRAN"><a href="#GRAN" class="headerlink" title="GRAN"></a>GRAN</h3><h3 id="InfoGAN"><a href="#InfoGAN" class="headerlink" title="InfoGAN"></a>InfoGAN</h3><p><img src="https://i.loli.net/2018/10/20/5bcb48885d134.png" alt=""></p><p>Imformation maximizing GANs，InfoGAN 把输入的 noise vector 分成两部分，一个是看做噪声z，一个是当做 latent code（c），然后把 z 和 c 同时输入给 G。在判别器的输出部分也进行了调整，同时输出一个 $c’$。</p><p>Q 网络用于判别结果对应的类别（c），实现上和 D 的结构相同，最后接一个全连接层输出</p><h3 id="BiGAN"><a href="#BiGAN" class="headerlink" title="BiGAN"></a>BiGAN</h3><p><img src="https://i.loli.net/2018/10/20/5bcb488896667.png" alt=""><br>Bidirectional Generative Adversarial Networks。</p><p><img src="https://i.loli.net/2018/10/20/5bcb4888b3219.png" alt=""></p><p>它有个特点是可以保证得到全局最小值。</p><p>BiGAN 引入了一个 E 网络，把输入图转换成 latent vector，然后把图片和 vector 一起送给 D 进行分类。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Comparative Study on Generative Adversarial Networks&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
</feed>
