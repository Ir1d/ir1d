<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neverland</title>
  
  <subtitle>你是我不愿醒来的梦啊&lt;br&gt;真是柔情一场</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ir1d.cf/"/>
  <updated>2018-07-10T12:40:01.777Z</updated>
  <id>https://ir1d.cf/</id>
  
  <author>
    <name>Ir1d</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Daily Notes 7.10</title>
    <link href="https://ir1d.cf/2018/07/10/dailynotes-4/"/>
    <id>https://ir1d.cf/2018/07/10/dailynotes-4/</id>
    <published>2018-07-09T16:43:38.000Z</published>
    <updated>2018-07-10T12:40:01.777Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Imagenet classification with deep convolutional neural networks</li></ul><a id="more"></a><h2 id="Imagenet-classification-with-deep-convolutional-neural-networks"><a href="#Imagenet-classification-with-deep-convolutional-neural-networks" class="headerlink" title="Imagenet classification with deep convolutional neural networks"></a>Imagenet classification with deep convolutional neural networks</h2><p>本文提出的 AlexNet，突破性地在 ImageNet 数据集上取得了极好的效果。作者特别自信地表示如果更快的 GPU 和更大的数据集出现，他们可以得到更好地结果。</p><p>我注意到一点很有趣的事情，他们处理数据的时候是直接把短边变成 256，然后直接裁中间的那部分。感觉这样很有可能导致最后的输入图像里只有部分信息，不知道是不是都这么做的。（感觉也没有别的办法了？总不能先跑一遍 detection？）另外，他们把图像的像素减去了数据集像素的平均值。</p><p>网络总共有8层，其中有5个卷积层和3个全连接层。</p><p>文中提出使用 ReLU 是不饱和的非线性函数，在梯度下降的时候训练速度要快。像$f(x)=tanh(x)$ 和 $f(x)=(1+e^{-x})^{-1}$是饱和的非线性函数（从图像可以看出）。</p><p>由于网络结构太大显存放不下，本文作者在两个 GPU 上面并行地跑。其中本文要求 GPU 只在特定的层才相互交换信息，来控制信息交换的代价在整个计算过程中的占比。</p><p>Local Response Normalization，翻译过来是局部响应归一化。首先又夸了 ReLU 的好处是不需要对输入数据做归一化因为它不饱和 —— 只要给 ReLU 的输入是正的，它的梯度就不为0。然后作者表示发现 local normalization 操作一下之后可以让网络有更好的泛化效果。注意$a_{x,y}^{i}$表示的是在$(x, y)$这个位置操作第i个卷积核的结果。局部归一化就是对每一个a，用相邻的n个卷积核结果来归一化。</p><script type="math/tex; mode=display">b_{x, y}^{i} = a_{x, y}^{i} / {\left( k + \alpha \sum_{j=max(0, i-n/2)}^{min(N-1, i+n/2)}(a_{x, y}^{j})^2 \right)}^ \beta</script><p>其中 $k,n,\alpha, \beta$ 是超参数，在 validation set 上面决定的。这里作者并没有给数据减去它们的平均值。这个操作放在一部分 ReLU 层之后。好像说是 LRN 效果并不明显，在日后新网络结构中使用很少</p><p>作者表示发现如果允许池化层池化的部分又重叠，可以让网络不那么容易就过拟合、并减少错误率。</p><p>网络目标是最大化一个多项式的 logistic 回归，相当于是最大化数据输出的正确类别的可能性的平均值</p><p>文中使用的数据增强方法只需要很少的计算，这样增强之后多出来的数据不需要提前放到硬盘上。实现中用 CPU 来增强数据， GPU 同时训练上一批数据，所以对计算资源没有影响。第一种增强的方法是从<code>256 x 256</code>的图片中随机的取<code>224 x 224</code>的块，然后也加入水平翻转后的结果，这样就把数据集扩大为原来的2048倍。测试的时候也是取出来四个角落和中心的<code>224 x 224</code>的块以及他们的水平翻转，把这十张图的结果求平均当做是原图的测试结果。</p><p>第二种数据增强的方法是改变输入数据 RGB 通道亮度。文中对每张图片都做 PCA，$p_1, p_2, p_3$是特征向量，$\lambda_1, \lambda_2, \lambda_3$是特征值。每次图像被用来训练的时候，都重新生成三个$\alpha_i$，然后把原图上的每个像素加上$[p_1, p_2, p_3][\alpha_1 \lambda_1, \alpha_2 \lambda_2, \alpha_3 \lambda_3]^T$。这里面的$\alpha_i$是从一个均值为0，标准差为0.1的高斯随机数发生器产生，注意这里对于同一张图在同一次训练过程中使用同一组$\alpha_i$。作者表示这样操作可以使得学到的物体特征不受亮度和光照颜色的影响，captures an important property of natural images。文中表示实验结果证明可以减少错误率。</p><p>同时还使用了 dropout，就是让前两个全连接层的神经元有一定概率（文中0.5）不参与前向和反向传播。这样每次数据输入进来的时候，神经网络都给出一个不一样的结构，但是这些结构是共享权重的。这种操作可以减少神经元之间的依赖，因为如此下来神经元不能依赖于某个其他神经元的存在来处理信息，也就迫使神经元尝试学习到更加强大的可以和其他神经元的随机子集共同工作的特征。在测试的时候，本文中使用全部的节点，只不过把它们的输出都乘上0.5，</p><h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><blockquote><p>Toeplitz matrix</p></blockquote><p>a.k.a diagonal-constant matrix.</p><p>主对角线上的元素相等，$A<em>{i,j} = A</em>{i+1,j+1}$</p><p>不一定是个方阵</p><blockquote><p>Factorial Distribution</p></blockquote><p>要求一组变量中变量之间没有相互作用</p><p>$P(x|y) = P(x)$</p><blockquote><p>non-saturating neurons</p></blockquote><p>不饱和神经元，就是说梯度不接近0，还可以有效地调整权重</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Imagenet classification with deep convolutional neural networks&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="summer2018" scheme="https://ir1d.cf/categories/summer2018/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu防止打字误触触摸板</title>
    <link href="https://ir1d.cf/2018/07/09/ubuntu%E9%98%B2%E6%AD%A2%E6%89%93%E5%AD%97%E8%AF%AF%E8%A7%A6%E8%A7%A6%E6%91%B8%E6%9D%BF/"/>
    <id>https://ir1d.cf/2018/07/09/ubuntu防止打字误触触摸板/</id>
    <published>2018-07-09T06:05:33.000Z</published>
    <updated>2018-07-09T06:06:36.009Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:atareao/atareao</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install touchpad-indicator</span><br></pre></td></tr></table></figure><p>ref: <a href="http://ubuntuhandbook.org/index.php/2018/04/install-touchpad-indicator-ubuntu-18-04-lts/" target="_blank" rel="noopener">http://ubuntuhandbook.org/index.php/2018/04/install-touchpad-indicator-ubuntu-18-04-lts/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="操作" scheme="https://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="ubuntu" scheme="https://ir1d.cf/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Daily Notes 7.9</title>
    <link href="https://ir1d.cf/2018/07/09/dailynotes-3/"/>
    <id>https://ir1d.cf/2018/07/09/dailynotes-3/</id>
    <published>2018-07-09T00:07:32.000Z</published>
    <updated>2018-07-10T12:39:56.525Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Image De-raining Using a Conditional Generative Adversarial Network</li><li>Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks</li><li>Image-to-Image Translation with Conditional Adversarial Networks</li></ul><a id="more"></a><h2 id="Image-De-raining-Using-a-Conditional-Generative-Adversarial-Network"><a href="#Image-De-raining-Using-a-Conditional-Generative-Adversarial-Network" class="headerlink" title="Image De-raining Using a Conditional Generative Adversarial Network"></a>Image De-raining Using a Conditional Generative Adversarial Network</h2><p>本文提出了用conditional-GAN来生成无雨背景的方法</p><p><img src="https://i.loli.net/2018/07/09/5b42bd0d27da8.png" alt="ID-GAN的网络结构"></p><p>生成器从雨图中学习生成无雨背景，然后判别器来判断是真实背景还是生成的</p><p>然后提出损失函数中不应只有 perceptual loss，还应当加入 per-pixel 的 loss 和 adversarial loss 一起，不过文中并没有提到三个loss的权重是怎么学出来的</p><p>最后提到缺点是不能处理图像上的白块，猜测可能是数据集中没有出现类似情况导致的，以及指出数据集难以包含整个 rain streak 的可能情况</p><h2 id="Unsupervised-Representation-Learning-with-Deep-Convolutional-Generative-Adversarial-Networks"><a href="#Unsupervised-Representation-Learning-with-Deep-Convolutional-Generative-Adversarial-Networks" class="headerlink" title="Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks"></a>Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks</h2><p>本文介绍了从大量无标签数据集中学习可重复使用的特征表示的一些结果</p><p>文中也展示在图像数据集上用无监督的方法也可以得到很有趣的层次信息</p><p>文中总结了优化GAN的一些方法：</p><ul><li>在判别器用 strided convolution, 在生成器用 fractional convolution 来代替所有的 pooling 层</li><li>在判别器和生成器中用 batch normalization</li><li>用更深的结构来替换掉全连接的隐藏层</li><li>生成器里除了最后一层都用 ReLU 来做 activation，最后一层用 Tanh</li><li>判别器里所有层都用 LeakyReLU 做 activation （激活函数）</li></ul><h2 id="Image-to-Image-Translation-with-Conditional-Adversarial-Networks"><a href="#Image-to-Image-Translation-with-Conditional-Adversarial-Networks" class="headerlink" title="Image-to-Image Translation with Conditional Adversarial Networks"></a>Image-to-Image Translation with Conditional Adversarial Networks</h2><p>很多视觉的 task 可以看作是在把输入图像翻译成输出图像，本文提出的 cGAN 技术可以学到这种翻译的对应关系，也学到一个对应的 loss function 来训练这个对应关系。最为著名的应用是 pix2pix。</p><p>conditional GAN 学习一个 structured loss，惩罚网络的输出在结构上的不同。</p><p>这里的 conditional 的最大区别在于，输入的 edge map 也要喂给判别器。同时文中提出，使用 L1 距离代替 L2 距离来要求生成器的输出和 groud truth 更近，可以鼓励减少模糊。</p><p><code>U-net</code>看起来就是加上了 skip connection 的 encoder-decoder network 。比如给图片上色的时候，突出的边缘的位置信息是输入和输出共享的，如果直接把它们从输入层传到输出层（避免经过 bottle neck），情况会好很多。具体来说，<code>U-net</code>形式里面把第 i 层和第 n-i 层里所有的通道都通过 skip connection 直接连接起来</p><p>PatchGAN，就是每次对结构的惩罚是在一个 patch 的层级来操作的。就是对整个图而言，是每次考虑一个 <code>n * n</code> 的 patch 是真的还是假的。实验证明，甚至 n 和整个图的大小相比可以很小。这样下来判别器相当于把图片看作是一个 Markov random field，其中假设了距离超过一个 patch 的直径的像素点之间是独立的。这样的 PatchGAN 可以看作是一种 材质/风格 的 loss</p><p>文中还提到了一些优化，比如生成器要最大化$log\ D(x, G(x, z))$而不是最小化$log\ (1 - D(x, G(x, z)))$；另外在训练判别器的时候，把目标函数除以 2，用来减小 D 相对于 G 学习的速度，然后每次 D 下降一步，G 也下降一步。</p><p>文中还有个很神奇的地方，作者表示在 inference time，生成网络和训练的时候是完全一样使用的，就是说这里面的 dropout 部分在测试的时候也没有移除。</p><h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><blockquote><p>image patch</p></blockquote><p>图像块的意思= =</p><blockquote><p>Leaky ReLUs</p></blockquote><p>leaky ReLU 的特点是在 $x \leq 0$ （inactive）的时候允许有一个小的正梯度（0.01）</p><p>而 Parametric ReLU 在这里更进一步，让那个正梯度变成一个参数，在神经网络反向传播的时候可以得到更新</p><p>注意在$a \leq 1$的时候，PReLU 相当于 $max(x, ax)$，这个形式和 maxout 网络有一定关联</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Image De-raining Using a Conditional Generative Adversarial Network&lt;/li&gt;
&lt;li&gt;Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks&lt;/li&gt;
&lt;li&gt;Image-to-Image Translation with Conditional Adversarial Networks&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="summer2018" scheme="https://ir1d.cf/categories/summer2018/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
      <category term="GAN" scheme="https://ir1d.cf/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>Daily Notes 7.8</title>
    <link href="https://ir1d.cf/2018/07/08/dailynotes-2/"/>
    <id>https://ir1d.cf/2018/07/08/dailynotes-2/</id>
    <published>2018-07-07T23:40:44.000Z</published>
    <updated>2018-07-10T12:39:52.373Z</updated>
    
    <content type="html"><![CDATA[<p>什么也没读，沉迷标数据不能自拔</p><a id="more"></a><p>作息过于糟糕，下午回去看数分结果很快就睡着了，还是闹钟免疫的那种。。。。</p><h2 id="Joint-Bi-layer-Optimization-for-Single-image-Rain-Streak-Removal"><a href="#Joint-Bi-layer-Optimization-for-Single-image-Rain-Streak-Removal" class="headerlink" title="Joint Bi-layer Optimization for Single-image Rain Streak Removal"></a>Joint Bi-layer Optimization for Single-image Rain Streak Removal</h2><p>本文做的是去除单张照片上雨纹的工作，具体来说是尝试把一张照片分成有雨和无雨的两层。整个最优化过程是同时把雨纹的细节从无雨层去掉，和把无雨的信息从雨纹层去掉.</p><p>拿到一张图，文中方法首先尝试确定 rain-dominated 的区域，然后利用这部分区域来确定雨的方向，并提取出 rain-patch，之后用 joint bi-layer optimization 方法来迭代地得到两层。</p><p>我怎么有个问题。。感觉一张图里的 rain streak 完全有可能角度差得很大啊？ 比如前景和后景完全可以反向</p><h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><blockquote><p>Frobenius norm</p></blockquote><p>a.k.a Euclidean norm, $\left\lVert A \right\rVert = \sqrt{\sum<em>{i=1}^m{\sum</em>{j=1}^n{|a_{ij}|^2}}}$</p><blockquote><p>fidelity term</p></blockquote><p>保真项</p><blockquote><p>Jensen’s inequality</p></blockquote><p>The mean value of a convex function is never lower than the value of the convex function applied to the mean. </p><script type="math/tex; mode=display">\begin{align}- \log p(x) &= - \log \int p(x,y) dy \\&= - \log \int q(y\vert x) \frac{p(y,x)}{q(y\vert x)}dy \\&\leq - \int q(y\vert x) \log \frac{p(y,x)}{q(y\vert x)} dy\end{align}</script><blockquote><p>L0 regularization</p></blockquote><p>l0 norm 是统计数组中的非零元素</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么也没读，沉迷标数据不能自拔&lt;/p&gt;
    
    </summary>
    
      <category term="summer2018" scheme="https://ir1d.cf/categories/summer2018/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>Daily Notes 7.7</title>
    <link href="https://ir1d.cf/2018/07/07/dailynotes-1/"/>
    <id>https://ir1d.cf/2018/07/07/dailynotes-1/</id>
    <published>2018-07-06T16:41:13.000Z</published>
    <updated>2018-07-09T08:48:02.888Z</updated>
    
    <content type="html"><![CDATA[<p>学数学 + 下午睡过头了</p><a id="more"></a><h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><blockquote><p> Checkerboard Artifacts </p></blockquote><p>Checkerboard Pattern 是黑白格交替的图案</p><p>神经网络生成的图像在细节处往往会出现像素点颜色交替的现象</p><p>ref: <a href="https://distill.pub/2016/deconv-checkerboard/" target="_blank" rel="noopener">https://distill.pub/2016/deconv-checkerboard/</a></p><p>transposed-conv 时出现 overlap 会导致这种现象</p><blockquote><p>Sobel operator</p></blockquote><p>用于 edge detection</p><p><a href="https://en.wikipedia.org/wiki/Sobel_operator" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sobel_operator</a></p><blockquote><p>skip connection</p></blockquote><p>用在 resnet 里面</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学数学 + 下午睡过头了&lt;/p&gt;
    
    </summary>
    
      <category term="summer2018" scheme="https://ir1d.cf/categories/summer2018/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>Daily Notes 7.6</title>
    <link href="https://ir1d.cf/2018/07/06/dailynotes/"/>
    <id>https://ir1d.cf/2018/07/06/dailynotes/</id>
    <published>2018-07-06T11:22:15.000Z</published>
    <updated>2018-07-09T08:48:27.020Z</updated>
    
    <content type="html"><![CDATA[<p><del>经久不衰</del>的 Daily Notes 系列又来了！</p><p>今天读的这篇：Perceptual Losses for Real-Time Style Transfer and Super-Resolution</p><!-- nore --><h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><p>记录一些今天关注的内容</p><blockquote><p>Transposed - conv</p></blockquote><p>就是把卷积层反过来的感觉，</p><p>可视化效果：<a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="noopener">https://github.com/vdumoulin/conv_arithmetic</a></p><blockquote><p>stride</p></blockquote><p>cs231n 的课程页面上写得很清楚，就是步长</p><blockquote><p>GAN basics</p></blockquote><p>略</p><blockquote><p>Dilated Convolutions</p></blockquote><p>ref: <a href="https://www.inference.vc/dilated-convolutions-and-kronecker-factorisation/" target="_blank" rel="noopener">Dilated Convolutions and Kronecker Factored Convolutions</a></p><p>它的一大优点是可以指数级地扩大感受域（receptive field），而参数是对数级的。这带来一个问题，需要加条件才能保证可以参数共享。</p><p>上文中表示需要卷积操作相当于<code>Kronecker product</code>才行</p><blockquote><p>CNN channel </p></blockquote><p><a href="https://blog.csdn.net/sscc_learning/article/details/79814146" target="_blank" rel="noopener">【CNN】理解卷积神经网络中的通道 channel - CSDN博客</a></p><blockquote><p>置信区间</p></blockquote><p>展现的是，这个总体参数的真实值有一定概率落在与该测量结果有关的某对应区间</p><blockquote><p>SSIM — Structural SIMilarity</p></blockquote><p>衡量两幅图像相似度，其值越大越好，最大为1</p><p>ref: <a href="https://blog.csdn.net/edogawachia/article/details/78756680" target="_blank" rel="noopener">https://blog.csdn.net/edogawachia/article/details/78756680</a></p><blockquote><p>PSNR — Peak signal-to-noise ratio</p></blockquote><p>峰值信噪比,是一种评价图像的客观标准</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def cal_psnr(im1, im2):</span><br><span class="line">    mse = (np.abs(im1 - im2) ** 2).mean()</span><br><span class="line">    psnr = 10 * np.log10(255 * 255 / mse)</span><br><span class="line">    return psnr</span><br></pre></td></tr></table></figure><blockquote><p>Fractionally-strided convolution</p></blockquote><p>ref: <a href="https://towardsdatascience.com/types-of-convolutions-in-deep-learning-717013397f4d" target="_blank" rel="noopener">https://towardsdatascience.com/types-of-convolutions-in-deep-learning-717013397f4d</a></p><p>就是之前提到的反卷积，这东西别名太多</p><p>为什么叫分数步长呢？</p><p>我们通过在原矩阵中间补0来使得正向的卷积结果相当于是反向的卷积，这是在原矩阵中的步长就可能是分数了</p><h2 id="Perceptual-Loss-—-《Perceptual-Losses-for-Real-Time-Style-Transfer-and-Super-Resolution》"><a href="#Perceptual-Loss-—-《Perceptual-Losses-for-Real-Time-Style-Transfer-and-Super-Resolution》" class="headerlink" title="Perceptual Loss — 《Perceptual Losses for Real-Time Style Transfer and Super-Resolution》"></a>Perceptual Loss — 《Perceptual Losses for Real-Time Style Transfer and Super-Resolution》</h2><p>很多工作都可以看作是对图像进行转换操作 —— 输入一张图，输出转换后的一张图</p><p>按像素比较的loss function 不能捕捉全局的（？perceptual）信息</p><p>perceptual loss function 不比较对应位置像素的信息，而是比较high-level的信息，比如预先训练好的卷积神经网络中的特征表示（feature representations）</p><p>本文的工作是训练了一个用perceptual loss训练一个单向的（feed forward）网络，又快又好</p><p>本文主要关注图片风格转换和单张图的超分辨率重建（四倍和八倍）</p><p><code>Feed-forward image transformation</code> 翻译过来是前馈神经网络</p><p>高品质的风格转换要求对较大的区域进行一致的，而本文方法使得感受域变大。</p><p><code>Residual Connections</code> ，认为可以方便地让网络学到恒等变换，这对风格转换很重要，因为大多数地方输出和输入是相同的。</p><p><code>Loss Function</code>有两部分，一个是<code>Feature Reconstruction Loss</code>，另一个是<code>Style Reconstruction Loss</code>。</p><p>前者是feature representation的欧几里得距离除以feature map的大小（$C <em> H </em> W$）。最小化第一个损失函数可以保留视觉内容和整体空间上的结构，但是颜色、纹理和具体的形状不一定保留。</p><p>后者在内容不同是进行惩罚，也惩罚风格上的不同。表达式是大小为$C * C$的Gram矩阵的L2距离。</p><p>注意到很有趣的一点，结果中人像比较清晰但是背景并不清晰。一种可能的解释是VGG-16的特征大多是在人像和动物上训练的，我们的风格转换网络是在学习保留VGG-16学到的特征，这样我们的网络学到的背景的信息比较少</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;del&gt;经久不衰&lt;/del&gt;的 Daily Notes 系列又来了！&lt;/p&gt;
&lt;p&gt;今天读的这篇：Perceptual Losses for Real-Time Style Transfer and Super-Resolution&lt;/p&gt;
&lt;!-- nore --&gt;
&lt;
      
    
    </summary>
    
      <category term="summer2018" scheme="https://ir1d.cf/categories/summer2018/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>扎心的2018年上半场小结</title>
    <link href="https://ir1d.cf/2018/07/02/2018%E4%B8%8A%E5%8D%8A%E5%9C%BA/"/>
    <id>https://ir1d.cf/2018/07/02/2018上半场/</id>
    <published>2018-07-02T09:52:31.000Z</published>
    <updated>2018-07-02T10:32:10.307Z</updated>
    
    <content type="html"><![CDATA[<p>迟到的总结…… hmmmmm</p><a id="more"></a><p>转过年是上学期的期末考试，扎心的三科考完就回家了。</p><p>寒假很长，做了个六重，装了很多次caffe，此外似乎也没干什么正经事</p><p>开学，选的课比较少，想要好好弄弄成绩</p><p>帮忙重构科协的网站</p><p>参与ICPC总决赛的工作</p><p>然后就是校赛</p><p>漫长的期中坚持了一个月</p><p>甚至如果算上史纲的学期论文可以认为期中和期末连着的</p><p>考试周的前几天完成了大部分课程，码了一周多的dp去考程设</p><hr><p>看起来很没有营养的上半场，收获大概是python技能增强，对Java的热情逐渐失去，Node.js的东西已经可以上手写了；另一方面是成绩更加扎心了，要更加努力才行。</p><p>蹭了不少pr进各种仓库，以后要避免莫名其妙就花了那么多时间的情况了</p><p>freecodecamp也刷了不少，感觉这个项目有点转型了，还是安心leetcode去吧XD</p><hr><p>接下来的日子，要很努力很努力才行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迟到的总结…… hmmmmm&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>泛做</title>
    <link href="https://ir1d.cf/2018/06/27/cssx/%E6%B3%9B%E5%81%9A/"/>
    <id>https://ir1d.cf/2018/06/27/cssx/泛做/</id>
    <published>2018-06-27T08:01:24.000Z</published>
    <updated>2018-06-30T01:58:09.021Z</updated>
    
    <content type="html"><![CDATA[<p>Educational Codeforces Round 45 的 B 和 C 不错 (CF #996)</p><a id="more"></a><blockquote><p>B. Micro-World</p></blockquote><p>给一列数</p><p>每个<code>a[i]</code>可以覆盖<code>[a[i] + 1 .. a[i] + k]</code> 这个区间</p><p>如果有<code>a[j]</code>在这个区间里，那么称<code>i</code>可以被<code>j</code>吃掉，问最后最少剩几个</p><p>这个区间描述的关系是被吃的指向吃的，所以应该反过来，用<code>a[j]</code>引出<code>[a[j] - k, a[j] - 1]</code>这个区间，这时的含义是<code>j</code>可以吃覆盖的区间里的。答案就是没有被覆盖的<code>a[i]</code>的个数</p><p>把每个区间起点打标记<code>+1</code>，终点后一个位置<code>-1</code>，求个前缀和。如果一个位置是<code>0</code>那么就是没被覆盖过的</p><blockquote><p>C. Bracket Sequences Concatenation Problem</p></blockquote><p>给一堆括号序列，问有多少二元组，拼起来之后算是合法的</p><p>核心在于如何求一个括号序列左侧需要补多少左括号和右侧需要补多少右括号才合法</p><p>尝试过程略去，说一下结论</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f(i, <span class="number">0</span>, n) <span class="keyword">if</span> (buf[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">  ++r[idx];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (r[idx]) --r[idx];</span><br><span class="line">  <span class="comment">// 这里是需要不减成负的</span></span><br><span class="line">  <span class="comment">// 如果会变成负的，那多出来的右括号是留给左侧，左侧用左括号补上的</span></span><br><span class="line">  <span class="comment">// 就不需要右侧管了，所以要保证计数器不减成0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>POJ 1191 棋盘分割</p></blockquote><p>方差的式子可以拆开</p><script type="math/tex; mode=display">\sigma = \sqrt{\frac{\sum_{i=1}^n(x_i - \bar x)^2}{n}} \\\\ = \sqrt{\frac{S}{n}}</script><p>\begin{align}<br>S &amp; = \sum_{i=1}^n(x_i - \bar x)^2 \\<br>&amp; = \sum(x_i^2-2x_i\bar{x}+\bar{x}^2) \\<br>&amp; = \sum{x_i^2} - \sum{2x_i\bar{x}} + n{\bar{x}^2} \\<br>&amp; = \sum{x_i^2} - 2n\bar{X} + n\bar{x}^2 \\<br>&amp; = \sum{x_i^2} - n\bar{X}<br>\end{align}</p><p>用<code>dp[n][x1][y1][x2][y2]</code>表示这块区域切<code>n</code>刀</p><p>记忆化搜索，前缀和预处理</p><blockquote><p>张三丰的传人</p></blockquote><p>后三种剪枝其实是在说一件事，题目要求分组，但是组内不要求顺序。</p><p>但是dfs肯定是有设定了顺序的，所以剪枝方案说：第一个如果不行，换了也不行，直接减掉；最后一个如果不行，换了也不行；</p><p>当然我们从长到短枚举就人为给了数据一个顺序，这样的话就可以避免了重复枚举，不会在已知不可能的情况多次尝试、浪费时间</p><blockquote><p>康拓展开</p></blockquote><p>可以用来求排列的序号，比如问1..5的第16个排列是哪一个</p><p>也可以对给出的一组排列问它在所有的排列里排第几</p><p><a href="https://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutation_index.html" target="_blank" rel="noopener">https://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutation_index.html</a></p><p>$ans = \sum_{i=1}^{n}{(a[i]右侧比a[i]小的数的个数) * (n - i)!)}$</p><p>逆向就是每次除以一个阶乘，余数继续。每次的商就是会有多少个数比这一位的数要小。可选的数字集合每次在变</p><p>用线段树搞一下就是nlogn查询了吧 (没写)</p><p>思考：如果允许元素重复呢？ 换言之，并不是严格意义上的排列</p><p><a href="https://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutation_index_ii.html" target="_blank" rel="noopener">https://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutation_index_ii.html</a></p><p>后面乘的阶乘除以重复那部分 $\frac{(\sum{a_i})!}{\Pi{(a_i!)}}$ 这样的</p><blockquote><p>POJ 1037: A decorative fence</p></blockquote><p><code>c[i][k][0/1]</code> 是前i个木棒中以第k短的开头，然后这一个是 下降/上升 的方案数</p><p>边界：<code>c[1][1][0] = c[1][1][1] = 1</code></p><p>后面还要计算第C个方案是啥，类似于排列计数</p><p>依次假设第<code>x</code>短的木棒放在那，然后看此时的方案数是否<code>&gt;= c</code></p><p>如果否，就用第<code>x + 1</code>短的木棒</p><blockquote><p>LIS 计数 <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1376" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1376</a></p></blockquote><p><a href="http://www.cnblogs.com/dirge/p/5958808.html" target="_blank" rel="noopener">http://www.cnblogs.com/dirge/p/5958808.html</a></p><p>考虑一个$O(n^2)$的算法</p><p>用<code>a[i]</code>表示原数组，<code>l[i]</code>表示以i结尾的LIS长度，<code>dp[i]</code>表示最长的这个的个数</p><p>我们每次处理<code>a[i]</code>如果它可以接在<code>a[j]</code>后面，那么<code>l[i] = max(l[j]) + 1</code></p><p>然后我们同时可以发现，如果<code>l[i] &gt; l[j] + 1</code>，那么，<code>dp[i] = dp[j]</code>，因为最长的长度更新了，要重新计数；<br>如果<code>l[i] == l[j] + 1</code>，那么更新进去，<code>dp[i] += dp[j]</code>.</p><p>用树状数组维护每一块的（用块里的数结尾的）LIS长度和对应个数</p><p>树上第i个位置代表的是以值i结尾的LIS的最长长度和对应个数</p><p>处理<code>a[i]</code>的时候，先看之前的用小于<code>a[i]</code>的数结尾的（这里是二维偏序）LIS的长度和对应个数</p><p>然后把长度更新</p><p>再插回树状数组里。</p><p><a href="https://github.com/Ir1d/Fantasy/blob/master/51NOD/1376.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/51NOD/1376.cpp</a></p><blockquote><p>POJ 1390 方盒游戏</p></blockquote><p>就是考虑最右侧的块，有两种选择，要么直接消了，要么把它左边消了，等着合并。</p><p>注意第二种方案不是和左边一起直接消了，而应该递归进入子问题</p><p>所以<code>dp[i][j]</code>并不够用，要加一维，用<code>dp[i][j][len]</code>，表示把<code>[i .. j]</code>这段，和与<code>a[j]</code>相等且长度为<code>len</code>的一块合并的最大得分</p><p>左边的同色大块可能有很多个，到底和哪个合并最好，不知道，只能枚举</p><p>upd: 细节是要先游程编码，然后对编码之后的序列搜能方便一些。程设2018考了个类似的，死活没调出来</p><blockquote><p>HDU 1423 LCIS</p></blockquote><p><a href="https://www.cnblogs.com/Howe-Young/p/5082611.html" target="_blank" rel="noopener">https://www.cnblogs.com/Howe-Young/p/5082611.html</a></p><p>用<code>dp[i][j]</code>表示str1和str2分别以i和j结尾的LCIS，第一维空间可以省掉</p><p>如果<code>s1[i] == s2[j]</code>更新一下答案，用什么更新呢？</p><p>就是先预处理出来<code>s1[i]</code>对应的，<code>s2[j] &lt; s1[i]</code>且让<code>dp[j]</code>最大的<code>j</code></p><p>由于<code>i</code>在外层固定，所以循环的时候按顺序记一下这个<code>j</code>就好了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Educational Codeforces Round 45 的 B 和 C 不错 (CF #996)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="https://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>算导 动态规划部分 笔记</title>
    <link href="https://ir1d.cf/2018/06/25/%E7%AE%97%E5%AF%BCdp%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2018/06/25/算导dp笔记/</id>
    <published>2018-06-25T14:59:18.000Z</published>
    <updated>2018-06-27T13:15:07.505Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划应用于子问题重叠的情况</p><a id="more"></a><ol><li>要去刻画最优解的结构特征</li><li>尝试递归地定义最优解的值（就是我们常说的考虑从<code>i - 1</code>转移到<code>i</code>）</li><li>计算最优解</li><li>利用计算出的信息构造一个最优解</li></ol><h1 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h1><p>给定一段钢条，和不同长度的价格，问如何切割使得总价格最大</p><p>为了求解规模为<code>n</code>的原问题，我们先求解形式完全一样，但规模更小的子问题。<br>即当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。<br>我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。</p><blockquote><p>最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解</p></blockquote><p>动态规划的两种实现方法</p><ul><li>带备忘的自顶向下法 （记忆化搜索）</li><li>自底向上法 （将子问题按规模排序，类似于递推）</li></ul><p>算导用子问题图上按照逆拓扑序求解问题，引出记忆化搜索。</p><p>重构解（输出方案）：转移的时候记录最优子结构的位置</p><h1 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h1><p>给出n个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算</p><p>（认为$p <em> q$的矩阵与$q</em>r$的矩阵相乘代价是$p<em>q</em>r$）</p><p>完全括号化方案是指要给出谁先和谁乘</p><h1 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h1><p>两个要素：</p><h2 id="1-最优子结构"><a href="#1-最优子结构" class="headerlink" title="1. 最优子结构"></a>1. 最优子结构</h2><p>具有最优子结构也可能是适合用贪心的方法求解</p><p>注意要确保我们考察了最优解中用到的所有子问题</p><ol><li>证明问题最优解的第一个组成部分是做出一个选择</li><li>对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。</li><li>给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间</li><li>证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li></ol><p>要保持子问题空间尽量简单，只在必要时扩展</p><p>最优子结构的不同体现在两个方面：</p><ol><li>原问题的最优解中涉及多少个子问题</li><li>确定最优解使用哪些子问题时，需要考察多少种选择</li></ol><p>子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边</p><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>无权最短路径</p></blockquote><p>具有最优子结构性质</p><blockquote><p>无权最长（简单）路径</p></blockquote><p>此问题不具有，是NP完全的</p><p>区别在于，要保证子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解。</p><p>相关 —— 求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用</p><h2 id="2-子问题重叠"><a href="#2-子问题重叠" class="headerlink" title="2. 子问题重叠"></a>2. 子问题重叠</h2><p>子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。</p><h2 id="重构最优解"><a href="#重构最优解" class="headerlink" title="重构最优解"></a>重构最优解</h2><p>存表记录最优分割的位置，就不用重新按照代价来重构</p><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>子序列允许不连续</p><p>每个<code>c[i][j]</code>只依赖于<code>c[i - 1][j]</code>、<code>c[i][j - 1]</code>和<code>c[i - 1][j - 1]</code></p><p>记录最优方案的时候可以不需要额外建表（优化空间），因为重新选择一遍（转移过程）也是$O(1)$的</p><h1 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h1><p>给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小</p><p>考虑当一棵子树成为了一个节点的子树时，答案（期望搜索代价）有何变化？</p><p>由于每个节点的深度都增加了1，这棵子树的期望搜索代价的增加值应为所有概率之和</p><blockquote><p>tD / eD 动态规划：<br>状态空间是$O(n^t)$的，每一项依赖其他$O(n^e)$项</p></blockquote><h1 id="经典问题（来自习题）"><a href="#经典问题（来自习题）" class="headerlink" title="经典问题（来自习题）"></a>经典问题（来自习题）</h1><h2 id="DAG-中的最长简单路径"><a href="#DAG-中的最长简单路径" class="headerlink" title="DAG 中的最长简单路径"></a>DAG 中的最长简单路径</h2><p>$dp[i] = max(dp[j] + 1), ((j, i) \in E)$</p><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><script type="math/tex; mode=display">dp[i][i + len] =\begin{cases}dp[i + 1][i + len - 1] + 2,  & \text{if $s[i] == s[i + len]$} \\[2ex]max(dp[i + 1][i + len], dp[i][i + len - 1]), & \text{else}\end{cases}</script><p>边界：$dp[i][i] = 1$</p><p>注意：$dp[i][j]$ 表示的是闭区间</p><p>也可以转化为LCS问题，只需要把a串反转当做b，对a和b求lcs即可</p><p>证明在： <a href="https://www.zhihu.com/question/34580085/answer/59539708" target="_blank" rel="noopener">https://www.zhihu.com/question/34580085/answer/59539708</a></p><p>注意区分子串（要求连续）的问题</p><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>$O(n^2)$：$dp[i] = max(dp[j] + 1), s(j + 1 .. i) 是回文$</p><p>$(O(n))$： Manacher</p><blockquote><p>Manacher</p></blockquote><p>$p[i]$ 表示从<code>i</code>向两侧延伸（当然要保证两侧对应位置相等）的最大长度</p><p>为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的）<code>#</code>，开头加一个<code>$</code></p><p>这样得到的回文串长度就保证是奇数了</p><p>考虑如果按顺序得到了$p[1 .. i - 1]$，如何计算$p[i]$的值</p><p>如果之前有一个位置比如说是<code>id</code>，有<code>p[id] + id &gt; i</code> 那么<code>i</code>这个位置是被覆盖了的，根据<code>id</code>处的对称性，我们找<code>p[id * 2 - i]</code>延伸的部分被<code>p[id]</code>延伸的部分所覆盖的那段，显然这段对称回去之后是可以从<code>i</code>处延伸出去的长度。</p><p>如果找不到呢？就先让<code>p[i] = 1</code>吧。</p><p>之后再暴力延伸一下。</p><p>可以证明是$O(n)$的</p><p>至于如何找是否有这么一个<code>id</code>呢？递推的时候存一个<code>max</code>就好了</p><p>代码在：<a href="https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp</a></p><h2 id="双调欧几里得旅行商问题"><a href="#双调欧几里得旅行商问题" class="headerlink" title="双调欧几里得旅行商问题"></a>双调欧几里得旅行商问题</h2><p>好像出成了某一年程设期末</p><p>upd：其实是<a href="/2018/06/23/cssx/程设期末推荐练习/">推荐练习</a>里面的</p><p>off-topic：惊了，原来 hexo 内链是可以这么写的：<code><a href="/2018/06/23/cssx/程设期末推荐练习/" title="程设期末推荐练习">程设期末推荐练习</a></code></p><!-- upd：其实是 <a href="/2018/06/23/cssx/程设期末推荐练习/" title="程设期末推荐练习">程设期末推荐练习</a> 里面的 --><p>书上的提示是：从左到右扫描，对巡游路线的两个部分分别维护可能的最优解</p><p>说的就是把回路给拆开吧</p><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>$dp[i][j] 表示\ 1..i\ 和\ 1..j\ 两条路径$</p><p>我们可以人为要求 $1..i$ 是更快的那一条路径</p><p>这样考虑第<code>i</code>个点分给谁</p><p>如果是分给快的那条：</p><p>$dp[i][j] = min(dp[i - 1][j] + dis[i - 1][i]),\ j = 1..i$</p><p>如果是慢的，原来是慢的那条就变成了快的，所以另一条是到<code>i - 1</code>那个点：</p><p>$dp[i][j] = min(dp[i - 1][j] + dis[j][i]),\ j = 1..i$</p><p>答案是$min(dp[n][i] + dis[n][i])$<br>（从一开始编号，终点是<code>n</code>）</p><p>代码：<a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp</a></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>把$dp[i][j]$定义反过来，不是$1..i$和$1..j$</p><p>改成是$i..n$和$j..n$，不要求哪个更快</p><p>这样的转移更好写</p><p>我们记<code>k = max(i, j) + 1</code></p><p><code>k</code>这个点肯定在两条路中的一个上，$dp[i][j]$取两种情况的最小值即可</p><p>$dp[i][j] = min(dp[i][k] + dis[k][j], dp[k][j] + dis[i][k])$</p><p>边界是：$dp[i][n] = dp[n][i] = dis[n][i]$</p><p>答案是$dp[1][1]$</p><h2 id="整齐打印"><a href="#整齐打印" class="headerlink" title="整齐打印"></a>整齐打印</h2><p>希望最小化所有行的额外空格数的立方之和</p><p>注意到实际问题要求单词不能打乱顺序，所以就好做了起来</p><p><code># 论不要把题目看复杂</code></p><p>$dp[i] = min(dp[j] + cost[j][i])$</p><hr><p>不知道这样可不可做= =</p><p>有n个单词，可以不按顺序打印，问怎么安排，使得把他们打印成m行之后，每行的空格之和最小</p><hr><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>变换操作有6种，复制、替换、删除、插入、旋转、终止（结束转换过程）</p><h3 id="最优对齐问题"><a href="#最优对齐问题" class="headerlink" title="　最优对齐问题"></a>　最优对齐问题</h3><p>把空格符插入到字符串里，使得相似度最大</p><p>定义了按字符比较的相似度</p><p>然后发现最优对齐问题可以转换为编辑距离问题</p><p>相当于仅有三个操作的带权编辑距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy    :  1</span><br><span class="line">replace : -1</span><br><span class="line">insert  : -2</span><br></pre></td></tr></table></figure><h2 id="公司聚会计划"><a href="#公司聚会计划" class="headerlink" title="公司聚会计划"></a>公司聚会计划</h2><p>没有上司的舞会</p><p><code>dp[x][0]</code>是没去</p><p><code>dp[x][1]</code>是去了</p><p>$dp[u][0] = max(dp[v][0], dp[v][1]), v \in son(u)$</p><p>$dp[u][1] = w[u] + dp[v][0], v \in son(u)$</p><h2 id="译码算法"><a href="#译码算法" class="headerlink" title="译码算法"></a>译码算法</h2><p><a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi algorithm</a><br>之前写词性标注的时候有用到，好像用在输入法里面也是类似的。</p><p>本题中用来实现语音识别，其实就是找一条对应的概率最大的路径</p><p>ref：<a href="https://segmentfault.com/a/1190000008720143" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008720143</a></p><h2 id="基于接缝裁剪的图像压缩"><a href="#基于接缝裁剪的图像压缩" class="headerlink" title="基于接缝裁剪的图像压缩"></a>基于接缝裁剪的图像压缩</h2><p>玩过 opencv 的应该有印象，seam carving 就是在做 dp</p><p>题中要求每一行删除一个像，每个像素都有代价，要求总代价最小</p><p>限制：要求相邻两行中删除的像素必须位于同一列或相邻列</p><p>$dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]， dp[i - 1][j + 1]) + cost[i][j]$</p><p>边界：$dp[1][i] = cost[1][i]$</p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><p>相当于问怎么按顺序拼起来使得总代价最小</p><p>等价于之前那个最优二叉搜索树</p><p>$dp[i][j] = min(dp[i][k] + dp[k][j]) + l[j] - l[i] + 1,\ k = i + 1\ ..\ j - 1$</p><p>注意<code>l[i]</code>表示的是第i个切分点的位置</p><p>边界：$dp[i][i] = 0$</p><p>就按照区间 dp 的姿势来写就好了</p><h2 id="投资策略规划"><a href="#投资策略规划" class="headerlink" title="投资策略规划"></a>投资策略规划</h2><blockquote><p>可以证明存在最优投资策略，每年都将所有钱投入到单一投资中</p></blockquote><p>这是个很有趣的结论，dp 问题中很常见</p><p><a href="https://fogsail.github.io/2017/05/08/20170508/" target="_blank" rel="noopener">https://fogsail.github.io/2017/05/08/20170508/</a></p><p>剩下的就是个二维 dp，想成从$(1, i)$走到$(n, m)$的路径的问题，然后收益和代价就是边权，网格图只能往右下方走。</p><h2 id="库存规划"><a href="#库存规划" class="headerlink" title="库存规划"></a>库存规划</h2><p>生产多了少了都有额外的成本，问怎么安排生产策略使得额外的成本尽可能地少</p><p>$cost[i][j]$ 表示剩下i个月，开始的时候有j台库存的最小成本</p><p><a href="https://walkccc.github.io/CLRS/Chap15/Problems/15-11/" target="_blank" rel="noopener">https://walkccc.github.io/CLRS/Chap15/Problems/15-11/</a></p><h2 id="签约棒球自由球员"><a href="#签约棒球自由球员" class="headerlink" title="签约棒球自由球员"></a>签约棒球自由球员</h2><p>$v[i][j]$ 是考虑i之后的位置，总费用为x，的最大收益</p><p><a href="https://walkccc.github.io/CLRS/Chap15/Problems/15-12/" target="_blank" rel="noopener">https://walkccc.github.io/CLRS/Chap15/Problems/15-12/</a></p><p>类似于背包问题</p><hr><p>当选取的状态难以进行递推时（分解出的子问题和原问题形式不一样），考虑将问题状态分类细化，增加维度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划应用于子问题重叠的情况&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="矩阵乘法" scheme="https://ir1d.cf/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
      <category term="算法导论" scheme="https://ir1d.cf/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 492 (Div. 2) [Thanks, uDebug!]</title>
    <link href="https://ir1d.cf/2018/06/25/cf/cf996/"/>
    <id>https://ir1d.cf/2018/06/25/cf/cf996/</id>
    <published>2018-06-25T12:45:31.000Z</published>
    <updated>2018-06-25T14:14:53.425Z</updated>
    
    <content type="html"><![CDATA[<p>花式过 pp ，专业 fst 选手大显身手</p><a id="more"></a><blockquote><p>A. Hit the Lottery</p></blockquote><p>dp肯定是对的，至于为什么可以贪心呢？</p><blockquote><p>B. World Cup</p></blockquote><p>模拟</p><blockquote><p>C. Tesla</p></blockquote><p>半个小时过去没人过的那种…… 写了半天还是WA</p><p>题意是一个两排车道，要求把车停到路边（道牙子上），求方案</p><p>题解：先把能放的放进去。把双排道看成一个环，如果有空位能转动就一定有解</p><p>这种题坐标一定要按照题目要求来，不能题里是<code>1</code>开头你自己用<code>0</code>开头读入</p><blockquote><p>D. Suit and Tie</p></blockquote><p>数据是成对的，但是被打乱了，问最少要操作多少次可以恢复</p><p>注意到最开头的那个数没必要动，于是它对应的那个数必须换过来。以此类推，搞定</p><blockquote><p>E. Leaving the Bar</p></blockquote><p>输入一堆向量，问如何给他们定向(<code>1 / -1</code>)，使得他们的和的模长符合条件。</p><p>现场写的贪心的，竟然过了pp</p><p>然后发现有dalao加了个如果不符合条件就random shuffle之后重新贪心</p><p>哎……　咋就没想到呢　<a href="http://codeforces.com/contest/995/submission/39644972" target="_blank" rel="noopener">http://codeforces.com/contest/995/submission/39644972</a></p><p>woq…… stm 发现了一个从后往前贪心过了的= =</p><p>题解里证明说每三个模长合格的里面总是能找到两个组成一个模长合格的，这样最后直到只剩两个，顶多是$\sqrt{2} r$ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花式过 pp ，专业 fst 选手大显身手&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="codeforces" scheme="https://ir1d.cf/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>程设期末上机汇总</title>
    <link href="https://ir1d.cf/2018/06/24/cssx/%E7%A8%8B%E8%AE%BE%E6%9C%9F%E6%9C%AB%E4%B8%8A%E6%9C%BA%E6%B1%87%E6%80%BB/"/>
    <id>https://ir1d.cf/2018/06/24/cssx/程设期末上机汇总/</id>
    <published>2018-06-24T11:41:06.000Z</published>
    <updated>2018-06-29T03:04:54.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A02:马走日</p></blockquote><p>dfs的时候别忘了起点也要标记为vis</p><blockquote><p>A04:鸣人的影分身</p></blockquote><p>整数划分，允许分出来0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, <span class="number">20</span>) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">g(i, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">  g(j, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i -j][j];</span><br><span class="line">    <span class="keyword">else</span> dp[i][j] = dp[i][i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>A09:Stupid cat &amp; Doge</p></blockquote><p>永远的痛</p><p><a href="https://blog.csdn.net/sssSSSay/article/details/52097617" target="_blank" rel="noopener">https://blog.csdn.net/sssSSSay/article/details/52097617</a></p><blockquote><p>B04:猴子摘桃</p></blockquote><p>可以尺取</p><p>注意枚举区间的姿势：如果枚举的是闭区间的端点，应该是<code>g(j, l, r)</code> 别漏了 <code>[r..r]</code> 这个</p><blockquote><p>B09:变换的迷宫</p></blockquote><p>注意到不能原地不动，所以还是会有无解的情况= = 忘了输出感叹号了</p><p><code>vis[x][y][ti % k]</code> 来标记是否可以再走</p><blockquote><p>B02:夺宝探险</p></blockquote><p>没什么特别的，dfs就可以了</p><p>但是又WA又T</p><p>发现自己看题里说第一行第一列就写了个<code>dfs(1, 1, 1)</code>，然而是从<code>0</code>开始读入的</p><blockquote><p>B10:游览规划</p></blockquote><p>枚举天数，二维代价dp</p><p>ref: <a href="https://blog.csdn.net/niwatori1217/article/details/51869474" target="_blank" rel="noopener">https://blog.csdn.net/niwatori1217/article/details/51869474</a></p><blockquote><p>C01:浮点数求高精度幂</p></blockquote><p>输出的时候好难受，其实分开写就好了</p><p>先输出小数点前的，判一下是不是需要小数点</p><p>再看小数点后面的</p><blockquote><p>C05:生理周期</p></blockquote><p>扩展欧几里得是<code>y -= a / b * x</code> 数据水</p><blockquote><p>C08:恼人的青蛙</p></blockquote><p>最核心的剪枝是判断第一个点不合法的那个</p><p>就是先排序了嘛，然后当前的第二个点步长过大，之后的点不会更好，所以就得出是第一个点的问题</p><p>怎么判断步长是不是过大呢？就看跳当前答案次还到没到头</p><p>从小到大枚举可以让答案很快就变得足够大，方便剪枝</p><p>还有一个坑点是，枚举的是第一个点和第二个点，那么前一个位置（回退回去）不能在田里</p><blockquote><p>C09:放苹果</p></blockquote><p>盘子相同，允许空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= j) dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - j][j];</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i][i];</span><br></pre></td></tr></table></figure><p>边界：<code>dp[0][i] = 1</code></p><blockquote><p>E05:抓住那头牛</p></blockquote><p>开始以为是贪心啥的，后来发现bfs就可以啦</p><p><code># 论搜索的时候要判断起点是不是就是重点了</code></p><blockquote><p>E06:宠物小精灵之收服</p></blockquote><p>二维代价的01背包</p><p><code>dp[i][j][k]</code> 是前i个精灵，最多用j个精灵球，伤害最多为k，能捉到的最大个数</p><p>第一维可以省去</p><p>然后求最小伤害就是找<code>dp[n][i] == dp[n][V]</code>的最小的i</p><blockquote><p>E09:棋盘问题</p></blockquote><p>莫名其妙写了好久</p><p>其实可以按顺序一格一格搜，放或者不放</p><p>也可以一行一行来</p><p>莫名其妙WA</p><blockquote><p>D02:要变多少次</p></blockquote><p>可以求个LIS</p><p>也可以先求一下前缀有多少个1，枚举在哪分割</p><p>char不能当int用= =</p><blockquote><p>D05:表达式的期望值</p></blockquote><p>想了一天</p><p>其实就是<code>dp[i][j]</code>表示前i个操作，结果是j的概率</p><p>然后这个题我直接拆开每位单独考虑了，也不知道合在一块能不能过</p><p>code：<a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/ftall/d5.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/ftall/d5.cpp</a></p><p>ref: <a href="https://blog.sengxian.com/algorithms/probability-and-expected-value-dynamic-programming" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/probability-and-expected-value-dynamic-programming</a></p><blockquote><p>D07:忍者道具</p></blockquote><p>状压dp，掌握了数组元素直接用PII的姿势</p><p>而且这东西可以直接用min来更新，省掉了显式用if判一下的步骤</p><p><code>dp[S]</code>是一个<code>pair&lt;int, int&gt;</code>，first是放了多少包了，second是最后一包放了多大空间了</p><p>然后枚举S和最后一个放的i，要么放最后一个，要么新开了一个包</p><blockquote><p>D10:ACM/ICPC 2018</p></blockquote><p>HDU 5445</p><p>做两遍多重背包</p><p>第一遍对点心，求出总能量不小于<code>p</code>的最小体积<code>minv</code>，第二遍对卡车，求出总容积不小于<code>minv</code>的最小花费<code>minc</code></p><p>找不到容积足够大的则输出<code>FAIL</code></p><p>“甜点可以切分，但是运过去的必须是整个甜点”，这里其实就在暗示，选甜点和装车是独立的两个过程</p><blockquote><p>D11:机智的弗兰克</p></blockquote><p>把障碍物移到远端（右上角）</p><p>在左下角枚举矩形，求个最大</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A02:马走日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dfs的时候别忘了起点也要标记为vis&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A04:鸣人的影分身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整数划分，允许分出来0&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="https://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 491 (Div.2)</title>
    <link href="https://ir1d.cf/2018/06/24/cf/cf991/"/>
    <id>https://ir1d.cf/2018/06/24/cf/cf991/</id>
    <published>2018-06-23T17:46:29.000Z</published>
    <updated>2018-06-25T14:16:17.826Z</updated>
    
    <content type="html"><![CDATA[<p>好久没打了，根本不在状态，深夜掉分场</p><a id="more"></a><blockquote><p>A. If at first you don’t succeed…</p></blockquote><p>坑点在判断数据是否合法，忘了加上$a &lt; c$，$a &lt; n$之类的，WA了一发</p><blockquote><p>B. Getting an A</p></blockquote><p>问最少修改多少个数满足条件</p><p>统计个数然后判一判，WA</p><p>于是排个序暴力做</p><p>double 转 int 竟然是 直接截断 // 埋下伏笔</p><blockquote><p>C. Candies</p></blockquote><p>交了九发= =</p><p>题意是一个人每天吃k个，另一个人每天吃$10%$，问最少的k，使得第一个人吃的至少为总共的一半</p><p>这题不能用 <code>* 0.1</code> 应该用 <code>/ 10</code></p><ul><li>qls: 整数题怎么有人写 double 的</li></ul><p>题面写的是“第一个人吃的至少为总共的一半”，如果总数是奇数，是上取整，换言之，要求第一个人吃的比第二个人多</p><p>又WA又T一时爽</p><blockquote><p>D. Bishwock</p></blockquote><p>给一个 $2 * n$ 的棋盘，问最多能放多少个L型的块</p><p>贪心放就好了，WA了一发少考虑了几种情况</p><p>upd: fst…. 少判了几种情况</p><blockquote><p>E. Bus Number</p></blockquote><p>给一个$1e18$范围的数，问选择里面的一部分数字（要求每种都得出现），重排之后能排出来多少种不同的数</p><p>当时就写了个爆搜上去 TLE</p><p>最后五分钟想起来加个记忆化</p><p>最后半分钟发现 hash 函数返回值竟然没写 导致一直过不去样例</p><p>加上<code>return s</code>就交，最后一秒钟返回pp</p><p>upd: fst…. sb了</p><p>hmmm 发现又枚举各个数字的个数过了的</p><p>题解：<a href="http://codeforces.com/blog/entry/60181" target="_blank" rel="noopener">http://codeforces.com/blog/entry/60181</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没打了，根本不在状态，深夜掉分场&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="codeforces" scheme="https://ir1d.cf/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>程设期末推荐练习</title>
    <link href="https://ir1d.cf/2018/06/23/cssx/%E7%A8%8B%E8%AE%BE%E6%9C%9F%E6%9C%AB%E6%8E%A8%E8%8D%90%E7%BB%83%E4%B9%A0/"/>
    <id>https://ir1d.cf/2018/06/23/cssx/程设期末推荐练习/</id>
    <published>2018-06-23T03:13:56.000Z</published>
    <updated>2018-06-26T07:16:06.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/04/" target="_blank" rel="noopener">04:What a Ridiculous Election</a></p></blockquote><p>注意搜的时候到同一个点有不同的状态，判断的时候不是判断是否vis，<br>而是要看当前的step和上一次的比较<br><code>dp[s][i][j]</code>表示到达s状态用了<code>i</code>次操作一和<code>j</code>次操作二的结果<br>然后注意输出答案的时候要在终点枚举所有的<code>i</code>和<code>j</code></p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/05/" target="_blank" rel="noopener">05:42点</a></p></blockquote><p>写的时候想得复杂了，其实注意到可以交换顺序，所以这个东西其实只需要每次找两个数操作一下，然后放回去就好了。这样甚至考虑到了括号嵌套的问题</p><p>减法和除法是有顺序的，所以要<a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/oop/2018rec/05.cpp#L47" target="_blank" rel="noopener">两种都做一下</a></p><p>ref <a href="https://blog.csdn.net/V5ZSQ/article/details/76039608" target="_blank" rel="noopener">这个题</a> 这里面还要处理不能整除的情况，要用double = =</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/06/" target="_blank" rel="noopener">06:A Knight’s Journey</a></p></blockquote><p>深搜注意回退删除标记 = =<br>用时间戳表示<code>vis</code>数组的时候，不是每个 case 开始的时候都清空，需要保证全局唯一</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/07/" target="_blank" rel="noopener">07:Sudoku</a></p></blockquote><p>数独，多case要初始化，深搜回退要恢复状态= =</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/10/" target="_blank" rel="noopener">10:股票买卖</a></p></blockquote><p><code>ll[i]</code> 表示 i 左侧极差<br><code>rr[i]</code> 表示 i 右侧极差<br>这样答案就是 $max{ll[i], rr[i + 1]}$</p><p>先用 <code>ll[i]</code> 得到 i 左侧最小的数和<code>a[i]</code>的差，然后对<code>ll[i]</code>求个前缀 max 就好了</p><blockquote><p>12:开餐馆</p></blockquote><p><code>dp[i]</code> 最后一个在 i 开，最大的价值<br>答案是数组的最大值</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/11/" target="_blank" rel="noopener">11:Tour</a> POJ 2677</p></blockquote><p>想了好几天，把一来一回的路径拆开，考虑$dp[i][j] 表示 1..i 和 1..j 两条路径$，<br>然后考虑下一个点（i）是从谁接过来的</p><p><a href="https://blog.csdn.net/xiaoxiaoluo/article/details/7636592" target="_blank" rel="noopener">https://blog.csdn.net/xiaoxiaoluo/article/details/7636592</a> 这里人为要求 $i \geq j$</p><p><a href="https://blog.csdn.net/ECNU_LZJ/article/details/71211855" target="_blank" rel="noopener">https://blog.csdn.net/ECNU_LZJ/article/details/71211855</a> 这个更直观，把路径反向，<br>方便转移</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/14/" target="_blank" rel="noopener">14:DNA</a></p></blockquote><p>调了半天，甚至还换了种思路写，最后发现问题是在于求重叠部分的长度又写错了</p><p>首先没想到的是，如果一个串被另一个包含了，那么短的直接删掉就好了</p><p>思路一：长度很少，枚举全排列，拼起来</p><p>思路二：状压dp，$dp[st][i]$表示已经拼了<code>st</code>里面这些字符串<code>i</code>是最后一个的答案，记忆化搜之</p><p>求重叠部分的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">std</span>::min(len[a], len[b]);</span><br><span class="line"><span class="keyword">while</span> (res) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(s[b], s[a] + len[a] - res) == s[b]) <span class="keyword">break</span>;</span><br><span class="line">  --res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>论善用<code>strstr</code>的重要性</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/13/" target="_blank" rel="noopener">13:上机</a></p></blockquote><p>按顺序考虑，前<code>i</code>个人的结果受前<code>i-1</code>个人的结果和第<code>i</code>与第<code>i-1</code>的顺序的影响</p><p>设计：$dp[i][l][r]$表示处理到第i个人，左侧 / 右侧有没有人</p><p>转移：<code>dp[i][k][t] = std::max(dp[i][k][t], dp[i - 1][j][k ^ 1] + a[i][k + t]);</code></p><p>注意带如果第<code>i</code>个人左侧的状态是<code>k</code>，那么对于第<code>i-1</code>个人而言，他右侧的状态就是<code>k ^ 1</code></p><p>注：用<code>k + t</code>简化，<code>a[i][0]</code>就是都没人，<code>a[i][1]</code>就是有一个,<code>a[i][2]</code>就是两侧都有人</p><p>这里的<code>j</code>是不造成影响的，转移的过程中要考虑每一个<code>j</code>（<code>0 / 1</code>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://cxsjsx.openjudge.cn/2018rec/04/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;04:What a Ridiculous Election&lt;/a&gt;&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="https://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>openjudge动态规划</title>
    <link href="https://ir1d.cf/2018/05/25/cssx/openjudge%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://ir1d.cf/2018/05/25/cssx/openjudge动态规划/</id>
    <published>2018-05-25T11:42:16.000Z</published>
    <updated>2018-06-24T11:40:54.559Z</updated>
    
    <content type="html"><![CDATA[<p>感觉之前使用md的姿势好像不对 = =</p><a id="more"></a><p>ref: <a href="https://fancypei.github.io/OpenjudgeDP/" target="_blank" rel="noopener">https://fancypei.github.io/OpenjudgeDP/</a></p><blockquote><p>LCIS $O(n^2)$</p></blockquote><p><code>dp[i][j]</code> 表示a串前i个和以<code>b[j]</code>结尾的串的LCIS的长度</p><p>转移是：</p><p><code>dp[i][j]=max(dp[i][j],dp[i-1][k]+1)    a[i]==b[j]&amp;&amp;b[k]&lt;b[j]   1&lt;=k&lt;j</code></p><p><code>dp[i][j]=max(dp[i][j],dp[i-1][j])     a[i]!=b[j]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[i] != y[j]) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &lt; dp[i - <span class="number">1</span>][k] &amp;&amp; y[k] &lt; y[j]) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个式子i从i-1转移过来，所以可以把i放到外层。这样内层循环的时候<code>a[i]</code>是固定的。根据第一个式子，<code>a[i] == b[j] &gt; b[k]</code>，实际上要找的是<code>b[j] &lt; a[i]</code> 的最大的<code>dp[i - 1][j]</code>，在内层循环的同时存一下就好了，不需要再去枚举那个k了。所以平方的复杂度就能做了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  mlen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="comment">//更新mlen</span></span><br><span class="line">    <span class="keyword">if</span> (y[j] &lt; x[i] &amp;&amp; dp[i - <span class="number">1</span>][j] &gt; mlen) &#123;</span><br><span class="line">      mlen = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算dp[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (y[j] == x[i]) &#123;</span><br><span class="line">      dp[i][j] = mlen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Ir1d/Fantasy/blob/master/POJ/2127.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/POJ/2127.cpp</a></p><p>（openjudge没有spj）</p><p>记录路径的姿势都忘光了= =</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = n; p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ans--) &#123;</span><br><span class="line">  st[++p] = b[y];</span><br><span class="line">  <span class="keyword">while</span> (a[x] != b[y]) --x;</span><br><span class="line">  y = pre[x][y];</span><br><span class="line">  --x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref: <a href="http://blog.fly2best.com/algorithm/2013/05/11/longges-common-increasing-subsequence/" target="_blank" rel="noopener">http://blog.fly2best.com/algorithm/2013/05/11/longges-common-increasing-subsequence/</a></p><ul><li>山区建小学 <a href="http://noi.openjudge.cn/ch0206/7624/" target="_blank" rel="noopener">http://noi.openjudge.cn/ch0206/7624/</a></li></ul><p>四边形不等式</p><ul><li>7627 鸡蛋的硬度</li></ul><p><code>f[i][j]=min(1+max(f[i-1][t-1],f[i][j-t])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) f[<span class="number">1</span>][i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">  f[i][j] = <span class="number">1</span> + max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i][j - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">2</span>; t &lt;= j; t++)</span><br><span class="line">    f[i][j] = min(f[i][j], <span class="number">1</span> + max(f[i - <span class="number">1</span>][t - <span class="number">1</span>], f[i][j - t]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>9265:取数游戏</p><p>自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是相邻的两个不可以同时被取走.</p><p>答案是斐波那契数，考虑最后一个取(dp[i - 2])，或者不取（dp[i - 1]）.</p></li><li><p>9267:核电站</p><p>加强，变成不能连续m个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">0</span>, m) dp[i] = <span class="number">1L</span>L &lt;&lt; i;</span><br><span class="line">--dp[m];</span><br><span class="line">g(i, m + <span class="number">1</span>, n) &#123;</span><br><span class="line">  dp[i] = <span class="number">2</span> * dp[i - <span class="number">1</span>] - dp[i - m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>9268:酒鬼</p><p>不能连续取三个，问取出的最大权值和</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f是最远，g是到i结束</span></span><br><span class="line"><span class="comment">// 答案是f[n]</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  g[i] = v[i] + max(f[i - <span class="number">2</span>], v[i - <span class="number">1</span>] + f[i - <span class="number">3</span>]);</span><br><span class="line">  f[i] = max(g[i], f[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>POJ3046</p><p><a href="https://blog.csdn.net/jaihk662/article/details/77951670" target="_blank" rel="noopener">https://blog.csdn.net/jaihk662/article/details/77951670</a></p><p>需要滚动数组</p></li></ul><p><code>dp[i][j]</code>表示前i个集合取j个数的种类数</p><p>然后 $dp[i][j] = \sum_{k=0}^{min(cnt_i, j)} dp[i - 1][j - k]$</p><ul><li><p>9288:Zju2061 Buy the Ticket</p><p>排队买票 卡特兰数</p><p>相当于在一个格点阵列中，从 (0, 0) 点走到 (n, m) 点且不穿过对角线 x = y 的方法数 。</p><p>最后答案要乘上排列数（阶乘）</p></li><li><p>6046:数据包的调度机制</p><p>区间dp，<code>dp[i][j]</code> 是把<code>[i, j]</code>这一段的数据包发出去的最小代价，然后转移的时候枚举这一段里面哪一个是最后发出的。因为是个栈，所以最后一个发出的那个包前面的是第一段，那个包后面的是第二段。</p><p><a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/6046.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/6046.cpp</a></p></li><li><p>4149:课程大作业</p><p><code>dp[i][S]</code>表示前i天完成S的最小代价</p><p>过不了</p><p><code>dp[S]</code>表示完成S的最小代价，每次枚举第一个完成哪个，记忆化搜索</p><p><a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/4149.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/4149.cpp</a></p></li></ul><ul><li>1481 Maximum sum</li></ul><p>ll[i]为以i为终点<br>rr[i]为以i为起点</p><p>ls[i]为前i个<br>rs[i]为后i个</p><p>边界数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)</p><ul><li>162 Post Office</li></ul><p>dp[i][j]表示前i个位置放j个post office的最小代价<br>转移是dp[i][j] = min{dp[k][j - 1] + cost[k + 1][i]};<br>cost数组可以v^2p预处理</p><p>时间复杂度O(v^2p)</p><p>考虑优化：(四边形不等式)</p><p>证明略</p><p>决策变量k具有单调性</p><p>从而优化到O(v^2)</p><ul><li>1759 LIS</li></ul><p>*lower_bound(dp, dp + n, a[i]) = a[i];</p><ul><li>1768 最大子矩阵</li></ul><p>枚举起始与终点行，转化为最大子段和</p><ul><li>1775 采药</li></ul><p>01背包</p><ul><li>1808 公共子序列</li></ul><p>LCS</p><ul><li>1944 吃糖果</li></ul><p>Fibonacci</p><ul><li>1996 登山</li></ul><p>转化成求两遍LIS</p><ul><li>2421 Exchange Rates</li></ul><p>题目比较坑</p><p>dp[i][0], dp[i][1]分别是两种全部转化后最大多少</p><p>一定存在一种最优策略是每次全部转化的</p><ul><li>2718 移动路线</li></ul><p>dp[i][j] += dp[i - 1][j] + dp[i][j - 1];</p><ul><li>2728 摘花生</li></ul><p>数字正方形</p><p>dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]) + a[i][j];</p><ul><li>2984    数字组合</li></ul><p>dp[i][j] 表示前i个数拼成j的方案数</p><p>然后滚动数组优化成一维空间</p><ul><li>2988 计算字符串距离</li></ul><p>dp[i][j] 表示s的前i与t的前j的距离</p><p>然后转移就是分各个情况就好</p><p>注意和LCS不同之处在于预处理</p><p>LCS刷0即可</p><p>然而这个地方要<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, n) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">g(i, <span class="number">1</span>, m) dp[<span class="number">0</span>][i] = i;</span><br></pre></td></tr></table></figure></p><ul><li>2989 糖果</li></ul><p>转移是有条件的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, n) f(j, <span class="number">0</span>, k) &#123;</span><br><span class="line">  <span class="keyword">int</span> tee = (j - a[i] % k + k) % k;</span><br><span class="line">  dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">  <span class="keyword">if</span> (dp[i - <span class="number">1</span>][tee] || !tee)</span><br><span class="line">  dp[i][j] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(j - a[i] % k + k) % k] + a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3531 判断整除</li></ul><p>原来这个条件很常见。。。</p><p>同上题</p><p>………………刷表法的话就不用特判了= =</p><ul><li>3532 最大上升子序列和</li></ul><p>LIS 变个形</p><ul><li>4977 怪盗基德的滑翔翼</li></ul><p>求一下两个方向的LIS求max即可</p><ul><li>4978 宠物小精灵之收服</li></ul><p>二维费用的01背包问题</p><p>背包九讲(<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf" target="_blank" rel="noopener">https://github.com/tianyicui/pack/blob/master/V2.pdf</a>)</p><ul><li>4982 踩方格</li></ul><p>爆搜</p><p>或者打个表发现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>,f[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] * <span class="number">2</span> + f[i - <span class="number">2</span>];</span><br></pre></td></tr></table></figure><ul><li>6045 开餐馆</li></ul><p>dp[i]表示到i为止的最大收益</p><p>O(n^2T)</p><ul><li>8787 数的划分</li></ul><p>dp[i][j]表示将i分成j份的方案数<br>dp[i][j]=dp[i-j][1]+dp[i-j][2]+dp[i-j][3]+…+dp[i-j][j-1]+dp[i-j][j];</p><p>时间复杂度是n*k^2</p><p>O(n*k)的方法：</p><p>dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j];</p><p>dp[i-1][j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+…+dp[(i-1)-(j-1)][j-1]<br>=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1];</p><p>因此，</p><p>dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1]+dp[i-j][j]<br>=dp[i-1][j-1]+dp[i-j][j];</p><ul><li>666 放苹果</li></ul><p>假如将7个苹果放进3个盘子里，可以分2种情况考虑：1，空着一个盘子不放，即将7个苹果放进2个盘子里；2，先每个盘子均放进一个苹果，再按照本规则继续放下去。</p><p>于是有递推公式：F(X,Y)=F(X,Y-1)+F(X-Y,Y)</p><p>F(X,1)，F(1,Y),F(0,Y),F(X,0)都等于1</p><p><code>当X&lt;Y时，即比如说将5个苹果放进8个盘子里，根据题意，和将5个苹果放进5个盘子是一样的结果</code></p><p>①最少的盘子放了一个，这样每个盘子至少一个，n个盘子先放上n个，剩下的m-n个可以随便放<br>②最少的盘子没有放，这样剩下的n-1个盘子还是随便放m个</p><ul><li>6049 买书</li></ul><p>考虑分别记录拼出i这个数最后一个用了啥</p><p>注意到拼数的方案与顺序无关，因此可以递增地来考虑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] += dp[i - <span class="number">10</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">dp[i][<span class="number">1</span>] += dp[i - <span class="number">20</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">1</span>] += dp[i - <span class="number">20</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">dp[i][<span class="number">2</span>] += dp[i - <span class="number">50</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">2</span>] += dp[i - <span class="number">50</span>][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">2</span>] += dp[i - <span class="number">50</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6252 通配符字符串匹配</li></ul><p>dp[i][j]表示s[1..i]与t[1..j]是否匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">  tee = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (s[i] == <span class="string">'*'</span>) dp[i][<span class="number">0</span>] = tee;</span><br><span class="line">  g(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">    tee |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">'?'</span> || s[i] == t[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">'*'</span>) dp[i][j] = tee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7113 Charm Bracelet</li></ul><p>01背包</p><ul><li>747 Divisibility</li></ul><p>同3531 判断整除</p><p>而且数据更强？</p><p>奥妙重重</p><p>强烈怀疑3531放了个什么奇怪的数据</p><p>刷表法姿势不对竟然也能过= =</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">g(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">  x = <span class="built_in">abs</span>(x);</span><br><span class="line">  x %= k;</span><br><span class="line">  f(j, <span class="number">0</span>, k) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">    dp[i][(j + x) % k] = <span class="number">1</span>;</span><br><span class="line">    dp[i][((j - x) % k + k) % k] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[n][<span class="number">0</span>]) <span class="built_in">puts</span>(<span class="string">"Divisible"</span>);</span><br></pre></td></tr></table></figure><ul><li>7614 最低通行费</li></ul><p>dp[i][j][k]表示到(i,j)走了k步的最小代价</p><ul><li>7624 山区建小学</li></ul><p>同162 Post Office</p><ul><li>7625 三角形最佳路径问题</li></ul><p>数字三角形</p><ul><li>7627 鸡蛋的硬度</li></ul><p><a href="http://blog.csdn.net/jerry99s/article/details/48802527" target="_blank" rel="noopener">http://blog.csdn.net/jerry99s/article/details/48802527</a></p><ul><li>8462 大盗阿福</li></ul><p>saffah出过，2014暑假集训中</p><ul><li>8464 股票买卖</li></ul><p>DP……预处理后缀最大值、最大获利、前缀最大值之类的求一下对应组合的max</p><ul><li>8467 鸣人的影分身</li></ul><p>同666</p><ul><li>8471 切割回文</li></ul><p>dp[i]表示s[1..i]最小需要的切割次数</p><ul><li>8780 拦截导弹</li></ul><p>LIS</p><ul><li>8782 乘积最大</li></ul><p>dp[i][j]表示前i个分成j份</p><ul><li>8785 装箱问题</li></ul><p>01背包</p><ul><li>90 滑雪</li></ul><p>DAG最长路</p><ul><li>8786 方格取数</li></ul><p>费用流/DP</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉之前使用md的姿势好像不对 = =&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="openjudge" scheme="https://ir1d.cf/tags/openjudge/"/>
    
      <category term="dp" scheme="https://ir1d.cf/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>openjudge补习</title>
    <link href="https://ir1d.cf/2018/05/25/cssx/openjudge%E8%A1%A5%E4%B9%A0/"/>
    <id>https://ir1d.cf/2018/05/25/cssx/openjudge补习/</id>
    <published>2018-05-25T05:07:23.000Z</published>
    <updated>2018-06-29T03:53:33.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>8758 2的幂次方表示</p></blockquote><p>  印象中什么时候好像调了好久的样子，其实就是直接递归的做就好了</p><blockquote><p>整数划分</p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">g(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">  g(j, <span class="number">1</span>, i) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - j][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[i][j] 是i分成j份的方案数</span></span><br></pre></td></tr></table></figure><blockquote><p>zipper</p></blockquote><p>  问A和B两个串 能否交叉组合成C，要求AB内部相对顺序不变</p><p>  <code>dp[i][j]</code> 表示<code>A[1..i]</code>和<code>B[1..j]</code> 能否拼成<code>C[1..i+j]</code> 转移就判一下最后一个字符是否匹配</p><blockquote><p><strong>复杂的整数划分问题</strong></p></blockquote><p>第一行: N划分成K个正整数之和的划分数目<br>第二行: N划分成若干个不同正整数之和的划分数目<br>第三行: N划分成若干个奇正整数之和的划分数目</p><p>ref: <a href="https://blog.csdn.net/tp7309/article/details/54880495" target="_blank" rel="noopener">https://blog.csdn.net/tp7309/article/details/54880495</a></p><blockquote><p>n划分成可相同的正整数</p></blockquote><p><code>dp[i][j]</code> 表示把i分成不超过j的数的和<br><code>dp[i][j] = dp[i][j - 1] + dp[i - j][j]</code><br>要么每个数都小于j，要么至少有一个等于j，把那个j去掉。</p><p><code>i &lt; j</code>时 <code>dp[i][j] = 0</code></p><p>边界：<code>dp[0][0] = 1;</code></p><blockquote><p>不相同</p></blockquote><p><code>dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1]</code><br>要么每个数都小于j，要么有一个数等于j，把唯一的那个j去掉，剩下的数都小于j了。</p><blockquote><p>k个数</p></blockquote><p><code>dp[i][j]</code> 表示把i分成j份<br><code>dp[i][j] = dp[i - j][j] + dp[i - 1][j - 1]</code><br>要么给之前的j组每个数加一，要么取出来一个1单独装一组</p><p><code>i &lt; j</code>时 <code>dp[i][j] = dp[i][i]</code></p><p>边界：<code>dp[0][i] = 1;</code></p><blockquote><p>分成奇数</p></blockquote><p><code>f[i][j]</code> 表示i分成j个正奇数<br><code>g[i][j]</code> 分成正偶数</p><p><code>g[i][j] = f[i - j][j]</code><br>偶数来自每一组奇数加一<br><code>f[i][j] = f[i - 1][j - 1] + g[i - j][j]</code><br>奇数来自偶数加一，或者最后一个1单独一组<br>边界：<code>f[0][0] = g[0][0] = 1</code></p><ul><li><p>6047:切蛋糕</p><p><code>dp[i][j[k]</code>表示<code>i*j</code>大小的切k块的答案（最大块面积的最小值）</p><p>转移的时候就枚举横竖的切法就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">  g(j, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">    dp[i][j][<span class="number">1</span>] = i * j;</span><br><span class="line">    g(k, <span class="number">2</span>, <span class="number">20</span>) &#123;</span><br><span class="line">      dp[i][j][k] = oo;</span><br><span class="line">      f(r, <span class="number">1</span>, i) &#123;</span><br><span class="line">        f(p, <span class="number">1</span>, k) &#123;</span><br><span class="line">          dp[i][j][k] = <span class="built_in">std</span>::min(dp[i][j][k], <span class="built_in">std</span>::max(dp[r][j][p], dp[i - r][j][k - p]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      f(c, <span class="number">1</span>, j) &#123;</span><br><span class="line">        f(p, <span class="number">1</span>, k) &#123;</span><br><span class="line">          dp[i][j][k] = <span class="built_in">std</span>::min(dp[i][j][k], <span class="built_in">std</span>::max(dp[i][c][p], dp[i][j - c][k - p]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p>感觉比之前菜多了…… 重开几页补补题吧QAQ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;8758 2的幂次方表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  印象中什么时候好像调了好久的样子，其实就是直接递归的做就好了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;整数划分&lt;/p&gt;
&lt;/blockquote&gt;
  &lt;figure clas
      
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="openjudge" scheme="https://ir1d.cf/tags/openjudge/"/>
    
  </entry>
  
  <entry>
    <title>程设算法上机练习小结</title>
    <link href="https://ir1d.cf/2018/05/19/cssx/%E7%A8%8B%E8%AE%BE%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E7%BB%83%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>https://ir1d.cf/2018/05/19/cssx/程设算法上机练习小结/</id>
    <published>2018-05-19T13:16:05.000Z</published>
    <updated>2018-06-29T03:52:48.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h1><ul><li><p>A:浮点数求高精度幂</p><p>正常的高精度快速幂，处理小数点的位置注意一下</p></li><li><p>B:Integer Inquiry<br>  高精度加法</p></li><li><p><strong>C:Communication System</strong><br>  每一类选一个使得最后的 <code>最小带宽/总价格</code> 最大<br>  可以枚举最小的带宽是啥 然后贪心找价格最小的</p><p>  dp的话<code>dp[i][j]</code>表示到第<code>i</code>类，带宽是<code>j</code>的答案<br>  当时一直在想<code>j</code>的范围没给不是很好办，后来看代码发现开到<code>1k</code>就可以了</p><p>  代码： <a href="https://github.com/Ir1d/Fantasy/blob/master/POJ/1018.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/POJ/1018.cpp</a><br>  注意 <code>POJ 1018</code> 得用 <code>C++</code> 交，不知道为啥</p></li><li><p>D:判断闰年<br>  <code>if</code>就好了</p></li><li><p>E:生理周期<br>  枚举或者<code>CRT</code></p></li><li><p>F:完美立方<br>  枚举</p></li><li><p>G:画家问题<br>  枚举第一行的结果，然后之后的操作就确定了，找答案最小的就可以了</p></li><li><p><strong>H:恼人的青蛙</strong><br>  枚举？</p><p>  upd： 枚举</p><p>  <a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/ftall/c8.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/ftall/c8.cpp</a></p></li><li><p><strong>I:放苹果</strong><br>  应该直接组合数吧？ dfs过了</p></li><li><p>J:古代密码<br>  就是给每个字母的出现次序排个序看能不能对应上</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;练习一&quot;&gt;&lt;a href=&quot;#练习一&quot; class=&quot;headerlink&quot; title=&quot;练习一&quot;&gt;&lt;/a&gt;练习一&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A:浮点数求高精度幂&lt;/p&gt;
&lt;p&gt;正常的高精度快速幂，处理小数点的位置注意一下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="https://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小结</title>
    <link href="https://ir1d.cf/2018/05/19/%E7%88%AC%E8%99%AB%E5%B0%8F%E7%BB%93/"/>
    <id>https://ir1d.cf/2018/05/19/爬虫小结/</id>
    <published>2018-05-19T02:32:00.000Z</published>
    <updated>2018-05-19T02:35:14.446Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫小结</p><p>爬了个小站，其实对方主要是在防注入（？），并没有怎么反爬所以其实不太困难，美中不足的是写挂了好多地方，然后有懒得增量更新爬到的结果，所以反反复复算是爬了三次，给服务器带来了不少压力。</p><p>其实是第一次用py写模拟登录（惭愧）</p><p>首先是患者列表，在翻页的时候抓包发现没有请求，翻开发者工具发现是藏在IndexedDB里面，然后补习了一下导出的姿势</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> DB_NAME = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> STORE_NAME = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(DB_NAME, DB_VERSION);</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create a new object store if this is the first time we're using</span></span><br><span class="line">  <span class="comment">// this DB_NAME/DB_VERSION combo.</span></span><br><span class="line">  request.result.createObjectStore(STORE_NAME, &#123;<span class="attr">autoIncrement</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  db = request.result;</span><br><span class="line">  <span class="comment">// Enable our buttons once the IndexedDB instance is available.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> res;</span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(STORE_NAME, <span class="string">'readonly'</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore = transaction.objectStore(STORE_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'getAll'</span> <span class="keyword">in</span> objectStore) &#123;</span><br><span class="line">  <span class="comment">// IDBObjectStore.getAll() will return the full set of items in our store.</span></span><br><span class="line">  objectStore.getAll().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    res = event.target.result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是常规操作，模拟登录什么的，然后有一个坑点是request库遇到302会跟着重定向过去，但是cookie没有存= =</p><p>解决方案是开个Session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REQ = requests.Session()</span><br><span class="line">r = REQ.post(loginUrl, headers=header, data=payload)</span><br></pre></td></tr></table></figure><p>对于Cookie的处理选择用dict，然后面向StackOverflow编程学习到了崭新的更新dict的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = REQ.cookies.get_dict()</span><br><span class="line">cookie = &#123;**cookie, **dic&#125;</span><br></pre></td></tr></table></figure><p>然后也学习到了从Chrome的工具里header变成python dict的方法和把dict变成Cookie串的方法= =<br>回想当年自己真的是太naive了呀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Convert Chrome headers to Python's Requests dictionary </span></span><br><span class="line">dict([[h.partition(<span class="string">':'</span>)[<span class="number">0</span>], h.partition(<span class="string">':'</span>)[<span class="number">2</span>]] <span class="keyword">for</span> h <span class="keyword">in</span> rawheaders.split(<span class="string">'\n'</span>)])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(s)</span>:</span> <span class="comment"># Converts dict to cookie string</span></span><br><span class="line">  res = <span class="string">""</span></span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">    res += k + <span class="string">'='</span> + s[k] + <span class="string">';'</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>以及regex中加个括号得到group可以只选中匹配出来的字符串的一部分，真的赞！</p><p>捕捉异常的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  logging.exception(<span class="string">"message"</span>)</span><br></pre></td></tr></table></figure></p><p>创建文件夹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'&#123;&#125;_res/&#123;&#125;'</span>.format(CRAWL_ID, idx)):</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    os.makedirs(<span class="string">'&#123;&#125;_res/&#123;&#125;'</span>.format(CRAWL_ID, idx))</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> exc: <span class="comment"># Guard against race condition</span></span><br><span class="line">    <span class="keyword">if</span> exc.errno != errno.EEXIST:</span><br><span class="line">      <span class="keyword">raise</span> <span class="comment"># 套在 try except里面</span></span><br></pre></td></tr></table></figure><p>下载图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">photoRes = requests.get(curUrl, headers=newHeader)</span><br><span class="line"><span class="comment"># if photoRes.status_code == 200:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'&#123;&#125;_res/&#123;&#125;/&#123;&#125;.&#123;&#125;'</span>.format(CRAWL_ID, idx, idNum, curName.split(<span class="string">'.'</span>)[<span class="number">-1</span>]), <span class="string">'ab'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(photoRes.content)</span><br></pre></td></tr></table></figure><p>最后一个坑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">photoNames = [x[<span class="string">'picId'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> jsonRes[<span class="string">'result'</span>] <span class="keyword">if</span> <span class="string">"X光"</span> <span class="keyword">in</span> str(x[<span class="string">'tags'</span>])]</span><br></pre></td></tr></table></figure><p>注意到<code>x[&#39;tags&#39;]</code>可以是<code>None</code> 所以加上 <code>str</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬虫小结&lt;/p&gt;
&lt;p&gt;爬了个小站，其实对方主要是在防注入（？），并没有怎么反爬所以其实不太困难，美中不足的是写挂了好多地方，然后有懒得增量更新爬到的结果，所以反反复复算是爬了三次，给服务器带来了不少压力。&lt;/p&gt;
&lt;p&gt;其实是第一次用py写模拟登录（惭愧）&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="爬虫" scheme="https://ir1d.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="python" scheme="https://ir1d.cf/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>程设语言部分笔记</title>
    <link href="https://ir1d.cf/2018/05/19/cssx/%E7%A8%8B%E8%AE%BE%E8%AF%AD%E8%A8%80%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2018/05/19/cssx/程设语言部分笔记/</id>
    <published>2018-05-19T02:27:43.000Z</published>
    <updated>2018-06-23T04:52:19.889Z</updated>
    
    <content type="html"><![CDATA[<p>断更了好久……</p><p>其实也说不清在忙什么……</p><p>莫名其妙的……</p><p>雾：下文内含大量typo（拼音输入法）</p><hr><p><a href="http://cxsjsx.openjudge.cn/hw201808/B/" target="_blank" rel="noopener">OpenJudge - B:按距离排序</a> 给struct重载() 来当比较器传给std::sort</p><p><a href="http://cxsjsx.openjudge.cn/hw201807/G/" target="_blank" rel="noopener">OpenJudge - G:你真的搞清楚为啥 while(cin &gt;&gt; n) 能成立了吗？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重载强制类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改指针一定要小心，尤其是模板里面 <code>*a = *b</code> 注意指针指向的地址是否变了 是否只改变了值</p><p><a href="http://cxsjsx.openjudge.cn/hw201807/C/" target="_blank" rel="noopener">OpenJudge - C:山寨版istream_iterator</a><br><code>operator *()</code> 重载解引用运算符   <code>operator ++(int)</code> 是后缀自增运算符</p><p><a href="http://cxsjsx.openjudge.cn/hw201808/E/" target="_blank" rel="noopener">OpenJudge - E:很难蒙混过关的CArray3d三维数组模板类</a></p><p>写得很痛苦，的确没有蒙混过关，还是应该老实的……</p><blockquote><ul><li>建议做法：</li></ul><ol><li>a[i][j][k] 这个表达式的第一个[]返回一个<strong>内部类</strong>的对象，该内部类也重载了[],且返回值为指针。</li><li>必要时需重载对象到指针的强制类型转换运算符</li></ol></blockquote><p><a href="http://cxsjsx.openjudge.cn/hw201808/F/" target="_blank" rel="noopener">OpenJudge - F:我自己的 ostream_iterator</a></p><p>刚开始一直在想怎么让他赋值进去就直接能输出，后来发现实际上是后面有一个++的过程，++的时候输出就好了。<br>然后再就是<code>*x=*a</code>重载的是<code>*</code>运算符不是等号= =</p><p><a href="http://cxsjsx.openjudge.cn/hw201809/A/" target="_blank" rel="noopener">OpenJudge - A:List</a> </p><p>简直惨痛。。。 merge自己到自己的操作要忽略掉就好了= = 果然还是应该写对拍</p><p><a href="http://cxsjsx.openjudge.cn/hw201809/F/" target="_blank" rel="noopener">OpenJudge - F:冷血格斗场</a></p><p>听说是当年pkusc的题，就是找lowerbound 然后再找前面的一个 比较比较就好了</p><p>没考虑到的地方是可能lowerbound的前面找到的那个并不是id最小的，要再lowerbound一下= =</p><p><a href="http://cxsjsx.openjudge.cn/2016mid2018/08/" target="_blank" rel="noopener">OpenJudge - 08:编程填空：维护平面点</a></p><p><a href="http://cxsjsx.openjudge.cn/hw201809/H/" target="_blank" rel="noopener">OpenJudge - H:编程填空：数据库内的学生信息</a></p><p>比较器的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Greater</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>upd：重写了 后三个typedef 不是必须的<br><a href="http://cxsjsx.openjudge.cn/2015mid2018/11/" target="_blank" rel="noopener">OpenJudge - 11:编程填空：数据库内的学生信息</a></p><p><strong>太难了= =</strong></p><p><strong>static的初始化方式</strong></p><p>printf — <code>%x</code> 十六进制</p><hr><p>期中复习</p><p>常引用：不是引用的内容不能修改，是不能通过常引用修改<br><code>const T</code> 或者 <code>const T &amp;</code>类型不能用来初始化 <code>T&amp;</code>类型，除非经过了强制类型转换<br>调用内联函数的语句前必须已经出现内联函数的定义（整个函数体），不能只有声明<br>同名函数只有参数表不同才算是重载，两个同名函数的参数表相同而返回值不同不是重载，是重复定义<br>new分配的空间一定要delete释放，否则程序运行结束后也不会被系统收回<br>一个string对象的大小（sizeof）是固定的（在不同编译器中并不相同，与字符串长度无关）<br>string对象中只存放地址和其他信息<br>大写字母ASCII码小于小写字母<br>struct默认公有，class默认私有<br>局部变量存储空间是动态分配在栈中的<br><strong><code>CTest* pArray[3] = {new CTest(4), new CTest(1, 2)};</code> 只生成了两个对象，第三个没有生成</strong><br>复制构造函数的参数一般用const引用，这样既能以常量对象，也能以非常量对象作为参数<br><strong>函数的参数对象以及作为函数返回值的对象，在消亡时也会引发析构函数调用</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDemo::CDemo(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">CDemo dl;</span><br><span class="line"><span class="function">CDemo <span class="title">Test</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回值是临时对象</span></span><br><span class="line">  foo();</span><br><span class="line">  <span class="keyword">return</span> dl;</span><br><span class="line">&#125;</span><br><span class="line">CDemo d4;</span><br><span class="line">d4 = <span class="number">6</span>; <span class="comment">// 这里6先被转换成临时对象，然后再赋值。语句执行完毕后临时对象消亡，调用析构函数</span></span><br></pre></td></tr></table></figure></p><p>并非所有对象生成的时候都通过上面的构造函数初始化，作为参数和返回值的时候是调用复制构造函数，需要另外再写<br>不能通过对常量对象调用普通成员函数，但是可以调用const的<br>两个成员函数的名字和参数表相同，但是一个const，另一个不是，算重载<br>封闭类生成的时候先执行所有成员对象的构造函数，再执行封闭类自己的构造函数<br>消亡的时候是先执行封闭类的析构函数，后执行成员对象的。<br>常量型成员变量和引用型必须要在构造函数的初始化列表中初始化<br>友元函数内部可以访问该类对象的private<br>不能吧其他类的私有成员函数声明为友元<br>交叉调用的时候允许写一个提前声明<code>class s;</code>但是在定义出现之前，不允许任何会导致该类对象被生成的语句。使用该类的指针或者引用是没有问题的<br>可以声明另一个类是自己的友元<br>友元关系不能传递<br>类的非内联成员函数的函数体只能出现在某一个<code>.cpp</code>文件中，不能放在头文件中被多个<code>.cpp</code>文件包含，否则链接时会发生重复定义的错误<br>如果编写了构造函数，则编译器不自动生成默认构造函数，一个类不一定会有默认（无参）构造函数，但是一定会有复制构造函数<br><code>=</code>只能重载为成员函数<br>在delete之前判断是否是NULL<br>注意赋值给自己的时候的指针的处理<br>参数os只能是ostream的引用，而不能使ostream对象，是因为ostream的复制构造函数是私有的，不能生成参数对象<br>类型强制转换运算符是单目运算符，只能被重载为成员函数 <code>operator double()  {}</code><br><code>++a</code>或者<code>--a</code>前置：<code>CDemo&amp; operator ++();</code><br><code>a++</code>或者<code>a--</code>后置：<code>CDemo operator ++(int);</code><br>运算符重载不改变优先级<br>不能被重载的运算符：<code>.</code> <code>.*</code>（成员指针访问运算符） <code>::</code> <code>?:</code> <code>sizeof</code><br>重载<code>() [] -&gt;</code>或者 赋值<code>=</code>时，只能重载为成员函数<br>派生类的成员函数只能访问所作用的那个对象（this指向的）的基类保护成员，不能访问其他基类对象的基类保护成员<br>如果一个派生类对象使用默认复制构造函数初始化的，那么他内部包含的基类对象也要用基类的复制构造函数初始化<br>封闭类类似<br>派生类对象生成的时候，先从上至下执行所有基类的构造函数，再按照成员对象的定义顺序执行各个成员对象的构造函数，最后执行自身的<br>消亡时，先执行自身的，后面与够早的次序相反<br>如果是public派生，派生类对象也是基类对象，如果是private或者protected，就不成立<br>多态的函数调用语句被称为是<code>动态联编</code>的<br>虚函数表的地址在对象存储空间的最前端<br>成员函数（静态成员函数、构造函数、析构函数除外）中调用其他虚成员函数是多态的<br>析构函数和构造函数中调用的虚函数不是多态<br>只要基类中的某个函数被声明成虚函数，则派生类中的同名、同参数表的成员函数及时前面没写virtual也是虚函数<br>虚析构函数：只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual声明，都是虚析构函数<br><strong>一个类如果定义了虚函数，则最好将析构函数也定义成虚函数</strong><br>独立的抽象类的对象不存在，但是被包含在派生类对象中的抽象类的对象是可以存在的<br>抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能<br>cerr clog 不能被重定向<br>cerr 不使用缓冲区 clog 使用<br><code>while (cin &gt;&gt; n)</code> 是因为把ostream到bool的转换重载了</p><p>顺序容器：vector, deque, list<br>关联容器：set, multiset, map, multimap<br>容器适配器：stack, queue, priority_queue<br>rend():只想容器中的第一个元素前面的位置的反向迭代器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.rbegin(); it != v.rend(); ++it);</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机</td></tr><tr><td>deque</td><td>随机</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set/ multiset</td><td>双向</td></tr><tr><td>map/ multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; output(<span class="built_in">cout</span>,<span class="string">" "</span>);</span><br><span class="line">copy (v.begin(), v.end(), output);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), <span class="built_in">std</span>::back_inserter(dest1));</span><br></pre></td></tr></table></figure><hr><p>考完试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">sz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">int</span>  A &lt;<span class="keyword">int</span>, <span class="number">40</span>&gt;::c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">int</span>  A &lt;<span class="keyword">int</span>, <span class="number">50</span>&gt;::c = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>const算不算重载<br>什么时候需要在初始化列表里初始化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;断更了好久……&lt;/p&gt;
&lt;p&gt;其实也说不清在忙什么……&lt;/p&gt;
&lt;p&gt;莫名其妙的……&lt;/p&gt;
&lt;p&gt;雾：下文内含大量typo（拼音输入法）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://cxsjsx.openjudge.cn/hw201808/B/&quot; target
      
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="程设" scheme="https://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
      <category term="C++" scheme="https://ir1d.cf/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>efb转发微信消息到tg</title>
    <link href="https://ir1d.cf/2018/03/10/efb%E8%BD%AC%E5%8F%91%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E5%88%B0tg/"/>
    <id>https://ir1d.cf/2018/03/10/efb转发微信消息到tg/</id>
    <published>2018-03-10T15:57:50.000Z</published>
    <updated>2018-06-23T04:50:32.629Z</updated>
    
    <content type="html"><![CDATA[<p>折腾很多坑</p><p>在NanoApe指点下得知应该装v1.6.6</p><p>然后就很好办啦</p><p>ref: <a href="https://konano.github.io/2018/02/17/EFB-use/" target="_blank" rel="noopener">https://konano.github.io/2018/02/17/EFB-use/</a></p><p>upd(2018.5.19): 经常掉线 其实很不好用= =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;折腾很多坑&lt;/p&gt;
&lt;p&gt;在NanoApe指点下得知应该装v1.6.6&lt;/p&gt;
&lt;p&gt;然后就很好办啦&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&quot;https://konano.github.io/2018/02/17/EFB-use/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="操作" scheme="https://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="ehForwarderBot" scheme="https://ir1d.cf/tags/ehForwarderBot/"/>
    
      <category term="telegram" scheme="https://ir1d.cf/tags/telegram/"/>
    
  </entry>
  
  <entry>
    <title>安装wxPython</title>
    <link href="https://ir1d.cf/2018/03/01/%E5%AE%89%E8%A3%85wxPython/"/>
    <id>https://ir1d.cf/2018/03/01/安装wxPython/</id>
    <published>2018-02-28T23:55:54.000Z</published>
    <updated>2018-06-23T04:47:38.430Z</updated>
    
    <content type="html"><![CDATA[<p>你可能需要这个【</p><p><a href="https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560" target="_blank" rel="noopener">https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560</a></p><p>甚至可能需要手动编译整个wxwidgets</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你可能需要这个【&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://g
      
    
    </summary>
    
      <category term="操作" scheme="https://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="wxPython" scheme="https://ir1d.cf/tags/wxPython/"/>
    
  </entry>
  
</feed>
