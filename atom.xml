<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neverland</title>
  
  <subtitle>你是我不愿醒来的梦啊&lt;br&gt;真是柔情一场</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ir1d.cf/"/>
  <updated>2018-06-26T10:15:29.524Z</updated>
  <id>http://ir1d.cf/</id>
  
  <author>
    <name>Ir1d</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算导 动态规划部分 笔记</title>
    <link href="http://ir1d.cf/2018/06/25/%E7%AE%97%E5%AF%BCdp%E7%AC%94%E8%AE%B0/"/>
    <id>http://ir1d.cf/2018/06/25/算导dp笔记/</id>
    <published>2018-06-25T14:59:18.000Z</published>
    <updated>2018-06-26T10:15:29.524Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划应用于子问题重叠的情况</p><a id="more"></a><ol><li>要去刻画最优解的结构特征</li><li>尝试递归地定义最优解的值（就是我们常说的考虑从<code>i - 1</code>转移到<code>i</code>）</li><li>计算最优解</li><li>利用计算出的信息构造一个最优解</li></ol><h1 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h1><p>给定一段钢条，和不同长度的价格，问如何切割使得总价格最大</p><p>为了求解规模为<code>n</code>的原问题，我们先求解形式完全一样，但规模更小的子问题。<br>即当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。<br>我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。</p><blockquote><p>最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解</p></blockquote><p>动态规划的两种实现方法</p><ul><li>带备忘的自顶向下法 （记忆化搜索）</li><li>自底向上法 （将子问题按规模排序，类似于递推）</li></ul><p>算导用子问题图上按照逆拓扑序求解问题，引出记忆化搜索。</p><p>重构解（输出方案）：转移的时候记录最优子结构的位置</p><h1 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h1><p>给出n个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算</p><p>（认为$p <em> q$的矩阵与$q</em>r$的矩阵相乘代价是$p<em>q</em>r$）</p><p>完全括号化方案是指要给出谁先和谁乘</p><h1 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h1><p>两个要素：</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>具有最优子结构也可能是适合用贪心的方法求解</p><p>注意要确保我们考察了最优解中用到的所有子问题</p><ol><li>证明问题最优解的第一个组成部分是做出一个选择</li><li>对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。</li><li>给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间</li><li>证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li></ol><p>要保持子问题空间尽量简单，只在必要时扩展</p><p>最优子结构的不同体现在两个方面：</p><ol><li>原问题的最优解中涉及多少个子问题</li><li>确定最优解使用哪些子问题时，需要考察多少种选择</li></ol><p>子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边</p><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>无权最短路径</p></blockquote><p>具有最优子结构性质</p><blockquote><p>无权最长（简单）路径</p></blockquote><p>此问题不具有，是NP完全的</p><p>区别在于，要保证子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解。</p><p>相关 —— 求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用</p><h2 id="子问题重叠"><a href="#子问题重叠" class="headerlink" title="子问题重叠"></a>子问题重叠</h2><p>子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。</p><h2 id="重构最优解"><a href="#重构最优解" class="headerlink" title="重构最优解"></a>重构最优解</h2><p>存表记录最优分割的位置，就不用重新按照代价来重构</p><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>子序列允许不连续</p><p>每个<code>c[i][j]</code>只依赖于<code>c[i - 1][j]</code>、<code>c[i][j - 1]</code>和<code>c[i - 1][j - 1]</code></p><p>记录最优方案的时候可以不需要额外建表（优化空间），因为重新选择一遍（转移过程）也是$O(1)$的</p><h1 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h1><p>给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小</p><p>考虑当一棵子树成为了一个节点的子树时，答案（期望搜索代价）有何变化？</p><p>由于每个节点的深度都增加了1，这棵子树的期望搜索代价的增加值应为所有概率之和</p><blockquote><p>tD / eD 动态规划：<br>状态空间是$O(n^t)$的，每一项依赖其他$O(n^e)$项</p></blockquote><h1 id="经典问题（来自习题）"><a href="#经典问题（来自习题）" class="headerlink" title="经典问题（来自习题）"></a>经典问题（来自习题）</h1><h2 id="DAG-中的最长简单路径"><a href="#DAG-中的最长简单路径" class="headerlink" title="DAG 中的最长简单路径"></a>DAG 中的最长简单路径</h2><p>$dp[i] = max(dp[j] + 1), ((j, i) \in E)$</p><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><script type="math/tex; mode=display">dp[i][i + len] =\begin{cases}dp[i + 1][i + len - 1] + 2,  & \text{if $s[i] == s[i + len]$} \\[2ex]max(dp[i + 1][i + len], dp[i][i + len - 1]), & \text{else}\end{cases}</script><p>边界：$dp[i][i] = 1$</p><p>注意：$dp[i][j]$ 表示的是闭区间</p><p>也可以转化为LCS问题，只需要把a串反转当做b，对a和b求lcs即可</p><p>证明在： <a href="https://www.zhihu.com/question/34580085/answer/59539708" target="_blank" rel="noopener">https://www.zhihu.com/question/34580085/answer/59539708</a></p><p>注意区分子串（要求连续）的问题</p><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>$O(n^2)$：$dp[i] = max(dp[j] + 1), s(j + 1 .. i) 是回文$</p><p>$(O(n))$： Manacher</p><blockquote><p>Manacher</p></blockquote><p>$p[i]$ 表示从<code>i</code>向两侧延伸（当然要保证两侧对应位置相等）的最大长度</p><p>为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的）<code>#</code>，开头加一个<code>$</code></p><p>这样得到的回文串长度就保证是奇数了</p><p>考虑如果按顺序得到了$p[1 .. i - 1]$，如何计算$p[i]$的值</p><p>如果之前有一个位置比如说是<code>id</code>，有<code>p[id] + id &gt; i</code> 那么<code>i</code>这个位置是被覆盖了的，根据<code>id</code>处的对称性，我们找<code>p[id * 2 - i]</code>延伸的部分被<code>p[id]</code>延伸的部分所覆盖的那段，显然这段对称回去之后是可以从<code>i</code>处延伸出去的长度。</p><p>如果找不到呢？就先让<code>p[i] = 1</code>吧。</p><p>之后再暴力延伸一下。</p><p>可以证明是$O(n)$的</p><p>至于如何找是否有这么一个<code>id</code>呢？递推的时候存一个<code>max</code>就好了</p><p>代码在：<a href="https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp</a></p><h2 id="双调欧几里得旅行商问题"><a href="#双调欧几里得旅行商问题" class="headerlink" title="双调欧几里得旅行商问题"></a>双调欧几里得旅行商问题</h2><p>好像出成了某一年程设期末</p><p>upd：其实是<a href="/2018/06/23/cssx/程设期末推荐练习/">推荐练习</a>里面的</p><p>off-topic：惊了，原来 hexo 内链是可以这么写的：<code><a href="/2018/06/23/cssx/程设期末推荐练习/" title="程设期末推荐练习">程设期末推荐练习</a></code></p><!-- upd：其实是 <a href="/2018/06/23/cssx/程设期末推荐练习/" title="程设期末推荐练习">程设期末推荐练习</a> 里面的 --><p>书上的提示是：从左到右扫描，对巡游路线的两个部分分别维护可能的最优解</p><p>说的就是把回路给拆开吧</p><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>$dp[i][j] 表示\ 1..i\ 和\ 1..j\ 两条路径$</p><p>我们可以人为要求 $1..i$ 是更快的那一条路径</p><p>这样考虑第<code>i</code>个点分给谁</p><p>如果是分给快的那条：</p><p>$dp[i][j] = min(dp[i - 1][j] + dis[i - 1][i]),\ j = 1..i$</p><p>如果是慢的，原来是慢的那条就变成了快的，所以另一条是到<code>i - 1</code>那个点：</p><p>$dp[i][j] = min(dp[i - 1][j] + dis[j][i]),\ j = 1..i$</p><p>答案是$min(dp[n][i] + dis[n][i])$<br>（从一开始编号，终点是<code>n</code>）</p><p>代码：<a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp</a></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>把$dp[i][j]$定义反过来，不是$1..i$和$1..j$</p><p>改成是$i..n$和$j..n$，不要求哪个更快</p><p>这样的转移更好写</p><p>我们记<code>k = max(i, j) + 1</code></p><p><code>k</code>这个点肯定在两条路中的一个上，$dp[i][j]$取两种情况的最小值即可</p><p>$dp[i][j] = min(dp[i][k] + dis[k][j], dp[k][j] + dis[i][k])$</p><p>边界是：$dp[i][n] = dp[n][i] = dis[n][i]$</p><p>答案是$dp[1][1]$</p><h2 id="整齐打印"><a href="#整齐打印" class="headerlink" title="整齐打印"></a>整齐打印</h2><p>希望最小化所有行的额外空格数的立方之和</p><p>注意到实际问题要求单词不能打乱顺序，所以就好做了起来</p><p><code># 论不要把题目看复杂</code></p><p>$dp[i] = min(dp[j] + cost[j][i])$</p><hr><p>不知道这样可不可做= =</p><p>有n个单词，可以不按顺序打印，问怎么安排，使得把他们打印成m行之后，每行的空格之和最小</p><hr><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>变换操作有6种，复制、替换、删除、插入、旋转、终止（结束转换过程）</p><h3 id="最优对齐问题"><a href="#最优对齐问题" class="headerlink" title="　最优对齐问题"></a>　最优对齐问题</h3><p>把空格符插入到字符串里，使得相似度最大</p><p>定义了按字符比较的相似度</p><p>然后发现最优对齐问题可以转换为编辑距离问题</p><p>相当于仅有三个操作的带权编辑距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy    :  1</span><br><span class="line">replace : -1</span><br><span class="line">insert  : -2</span><br></pre></td></tr></table></figure><h2 id="公司聚会计划"><a href="#公司聚会计划" class="headerlink" title="公司聚会计划"></a>公司聚会计划</h2><p>没有上司的舞会</p><p><code>dp[x][0]</code>是没去</p><p><code>dp[x][1]</code>是去了</p><p>$dp[u][0] = max(dp[v][0], dp[v][1]), v \in son(u)$</p><p>$dp[u][1] = w[u] + dp[v][0], v \in son(u)$</p><h2 id="译码算法"><a href="#译码算法" class="headerlink" title="译码算法"></a>译码算法</h2><p><a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi algorithm</a><br>之前写词性标注的时候有用到，好像用在输入法里面也是类似的。</p><p>本题中用来实现语音识别，其实就是找一条对应的概率最大的路径</p><p>ref：<a href="https://segmentfault.com/a/1190000008720143" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008720143</a></p><h2 id="基于接缝裁剪的图像压缩"><a href="#基于接缝裁剪的图像压缩" class="headerlink" title="基于接缝裁剪的图像压缩"></a>基于接缝裁剪的图像压缩</h2><p>玩过 opencv 的应该有印象，seam carving 就是在做 dp</p><p>题中要求每一行删除一个像，每个像素都有代价，要求总代价最小</p><p>限制：要求相邻两行中删除的像素必须位于同一列或相邻列</p><p>$dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]， dp[i - 1][j + 1]) + cost[i][j]$</p><p>边界：$dp[1][i] = cost[1][i]$</p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><p>相当于问怎么按顺序拼起来使得总代价最小</p><p>等价于之前那个最优二叉搜索树</p><p>$dp[i][j] = min(dp[i][k] + dp[k][j]) + l[j] - l[i] + 1,\ k = i + 1\ ..\ j - 1$</p><p>注意<code>l[i]</code>表示的是第i个切分点的位置</p><p>边界：$dp[i][i] = 0$</p><p>就按照区间 dp 的姿势来写就好了</p><h2 id="投资策略规划"><a href="#投资策略规划" class="headerlink" title="投资策略规划"></a>投资策略规划</h2><blockquote><p>可以证明存在最优投资策略，每年都将所有钱投入到单一投资中</p></blockquote><p>这是个很有趣的结论，dp 问题中很常见</p><p><a href="https://fogsail.github.io/2017/05/08/20170508/" target="_blank" rel="noopener">https://fogsail.github.io/2017/05/08/20170508/</a></p><p>剩下的就是个二维 dp，想成从$(1, i)$走到$(n, m)$的路径的问题，然后收益和代价就是边权，网格图只能往右下方走。</p><h2 id="库存规划"><a href="#库存规划" class="headerlink" title="库存规划"></a>库存规划</h2><p>生产多了少了都有额外的成本，问怎么安排生产策略使得额外的成本尽可能地少</p><p>$cost[i][j]$ 表示剩下i个月，开始的时候有j台库存的最小成本</p><p><a href="https://walkccc.github.io/CLRS/Chap15/Problems/15-11/" target="_blank" rel="noopener">https://walkccc.github.io/CLRS/Chap15/Problems/15-11/</a></p><h2 id="签约棒球自由球员"><a href="#签约棒球自由球员" class="headerlink" title="签约棒球自由球员"></a>签约棒球自由球员</h2><p>$v[i][j]$ 是考虑i之后的位置，总费用为x，的最大收益</p><p><a href="https://walkccc.github.io/CLRS/Chap15/Problems/15-12/" target="_blank" rel="noopener">https://walkccc.github.io/CLRS/Chap15/Problems/15-12/</a></p><p>类似于背包问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划应用于子问题重叠的情况&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="矩阵乘法" scheme="http://ir1d.cf/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
      <category term="算法导论" scheme="http://ir1d.cf/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 492 (Div. 2) [Thanks, uDebug!]</title>
    <link href="http://ir1d.cf/2018/06/25/cf/cf996/"/>
    <id>http://ir1d.cf/2018/06/25/cf/cf996/</id>
    <published>2018-06-25T12:45:31.000Z</published>
    <updated>2018-06-25T14:14:53.425Z</updated>
    
    <content type="html"><![CDATA[<p>花式过 pp ，专业 fst 选手大显身手</p><a id="more"></a><blockquote><p>A. Hit the Lottery</p></blockquote><p>dp肯定是对的，至于为什么可以贪心呢？</p><blockquote><p>B. World Cup</p></blockquote><p>模拟</p><blockquote><p>C. Tesla</p></blockquote><p>半个小时过去没人过的那种…… 写了半天还是WA</p><p>题意是一个两排车道，要求把车停到路边（道牙子上），求方案</p><p>题解：先把能放的放进去。把双排道看成一个环，如果有空位能转动就一定有解</p><p>这种题坐标一定要按照题目要求来，不能题里是<code>1</code>开头你自己用<code>0</code>开头读入</p><blockquote><p>D. Suit and Tie</p></blockquote><p>数据是成对的，但是被打乱了，问最少要操作多少次可以恢复</p><p>注意到最开头的那个数没必要动，于是它对应的那个数必须换过来。以此类推，搞定</p><blockquote><p>E. Leaving the Bar</p></blockquote><p>输入一堆向量，问如何给他们定向(<code>1 / -1</code>)，使得他们的和的模长符合条件。</p><p>现场写的贪心的，竟然过了pp</p><p>然后发现有dalao加了个如果不符合条件就random shuffle之后重新贪心</p><p>哎……　咋就没想到呢　<a href="http://codeforces.com/contest/995/submission/39644972" target="_blank" rel="noopener">http://codeforces.com/contest/995/submission/39644972</a></p><p>woq…… stm 发现了一个从后往前贪心过了的= =</p><p>题解里证明说每三个模长合格的里面总是能找到两个组成一个模长合格的，这样最后直到只剩两个，顶多是$\sqrt{2} r$ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花式过 pp ，专业 fst 选手大显身手&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="codeforces" scheme="http://ir1d.cf/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>程设期末上机汇总</title>
    <link href="http://ir1d.cf/2018/06/24/cssx/%E7%A8%8B%E8%AE%BE%E6%9C%9F%E6%9C%AB%E4%B8%8A%E6%9C%BA%E6%B1%87%E6%80%BB/"/>
    <id>http://ir1d.cf/2018/06/24/cssx/程设期末上机汇总/</id>
    <published>2018-06-24T11:41:06.000Z</published>
    <updated>2018-06-26T16:46:41.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A02:马走日</p></blockquote><p>dfs的时候别忘了起点也要标记为vis</p><blockquote><p>A04:鸣人的影分身</p></blockquote><p>整数划分，允许分出来0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, <span class="number">20</span>) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">g(i, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">  g(j, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i -j][j];</span><br><span class="line">    <span class="keyword">else</span> dp[i][j] = dp[i][i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>B04:猴子摘桃</p></blockquote><p>可以尺取</p><p>注意枚举区间的姿势：如果枚举的是闭区间的端点，应该是<code>g(j, l, r)</code> 别漏了 <code>[r..r]</code> 这个</p><blockquote><p>B09:变换的迷宫</p></blockquote><p>注意到不能原地不动，所以还是会有无解的情况= = 忘了输出感叹号了</p><p><code>vis[x][y][ti % k]</code> 来标记是否可以再走</p><blockquote><p>B02:夺宝探险</p></blockquote><p>没什么特别的，dfs就可以了</p><p>但是又WA又T</p><p>发现自己看题里说第一行第一列就写了个<code>dfs(1, 1, 1)</code>，然而是从<code>0</code>开始读入的</p><blockquote><p>B10:游览规划</p></blockquote><p>枚举天数，二维代价dp</p><p>ref: <a href="https://blog.csdn.net/niwatori1217/article/details/51869474" target="_blank" rel="noopener">https://blog.csdn.net/niwatori1217/article/details/51869474</a></p><blockquote><p>E09:棋盘问题</p></blockquote><p>莫名其妙写了好久</p><p>其实可以按顺序一格一格搜，放或者不放</p><p>也可以一行一行来</p><p>莫名其妙WA</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A02:马走日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dfs的时候别忘了起点也要标记为vis&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A04:鸣人的影分身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整数划分，允许分出来0&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="http://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 491 (Div.2)</title>
    <link href="http://ir1d.cf/2018/06/24/cf/cf991/"/>
    <id>http://ir1d.cf/2018/06/24/cf/cf991/</id>
    <published>2018-06-23T17:46:29.000Z</published>
    <updated>2018-06-25T14:16:17.826Z</updated>
    
    <content type="html"><![CDATA[<p>好久没打了，根本不在状态，深夜掉分场</p><a id="more"></a><blockquote><p>A. If at first you don’t succeed…</p></blockquote><p>坑点在判断数据是否合法，忘了加上$a &lt; c$，$a &lt; n$之类的，WA了一发</p><blockquote><p>B. Getting an A</p></blockquote><p>问最少修改多少个数满足条件</p><p>统计个数然后判一判，WA</p><p>于是排个序暴力做</p><p>double 转 int 竟然是 直接截断 // 埋下伏笔</p><blockquote><p>C. Candies</p></blockquote><p>交了九发= =</p><p>题意是一个人每天吃k个，另一个人每天吃$10%$，问最少的k，使得第一个人吃的至少为总共的一半</p><p>这题不能用 <code>* 0.1</code> 应该用 <code>/ 10</code></p><ul><li>qls: 整数题怎么有人写 double 的</li></ul><p>题面写的是“第一个人吃的至少为总共的一半”，如果总数是奇数，是上取整，换言之，要求第一个人吃的比第二个人多</p><p>又WA又T一时爽</p><blockquote><p>D. Bishwock</p></blockquote><p>给一个 $2 * n$ 的棋盘，问最多能放多少个L型的块</p><p>贪心放就好了，WA了一发少考虑了几种情况</p><p>upd: fst…. 少判了几种情况</p><blockquote><p>E. Bus Number</p></blockquote><p>给一个$1e18$范围的数，问选择里面的一部分数字（要求每种都得出现），重排之后能排出来多少种不同的数</p><p>当时就写了个爆搜上去 TLE</p><p>最后五分钟想起来加个记忆化</p><p>最后半分钟发现 hash 函数返回值竟然没写 导致一直过不去样例</p><p>加上<code>return s</code>就交，最后一秒钟返回pp</p><p>upd: fst…. sb了</p><p>hmmm 发现又枚举各个数字的个数过了的</p><p>题解：<a href="http://codeforces.com/blog/entry/60181" target="_blank" rel="noopener">http://codeforces.com/blog/entry/60181</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没打了，根本不在状态，深夜掉分场&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="codeforces" scheme="http://ir1d.cf/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>程设期末推荐练习</title>
    <link href="http://ir1d.cf/2018/06/23/cssx/%E7%A8%8B%E8%AE%BE%E6%9C%9F%E6%9C%AB%E6%8E%A8%E8%8D%90%E7%BB%83%E4%B9%A0/"/>
    <id>http://ir1d.cf/2018/06/23/cssx/程设期末推荐练习/</id>
    <published>2018-06-23T03:13:56.000Z</published>
    <updated>2018-06-26T07:16:06.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/04/" target="_blank" rel="noopener">04:What a Ridiculous Election</a></p></blockquote><p>注意搜的时候到同一个点有不同的状态，判断的时候不是判断是否vis，<br>而是要看当前的step和上一次的比较<br><code>dp[s][i][j]</code>表示到达s状态用了<code>i</code>次操作一和<code>j</code>次操作二的结果<br>然后注意输出答案的时候要在终点枚举所有的<code>i</code>和<code>j</code></p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/05/" target="_blank" rel="noopener">05:42点</a></p></blockquote><p>写的时候想得复杂了，其实注意到可以交换顺序，所以这个东西其实只需要每次找两个数操作一下，然后放回去就好了。这样甚至考虑到了括号嵌套的问题</p><p>减法和除法是有顺序的，所以要<a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/oop/2018rec/05.cpp#L47" target="_blank" rel="noopener">两种都做一下</a></p><p>ref <a href="https://blog.csdn.net/V5ZSQ/article/details/76039608" target="_blank" rel="noopener">这个题</a> 这里面还要处理不能整除的情况，要用double = =</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/06/" target="_blank" rel="noopener">06:A Knight’s Journey</a></p></blockquote><p>深搜注意回退删除标记 = =<br>用时间戳表示<code>vis</code>数组的时候，不是每个 case 开始的时候都清空，需要保证全局唯一</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/07/" target="_blank" rel="noopener">07:Sudoku</a></p></blockquote><p>数独，多case要初始化，深搜回退要恢复状态= =</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/10/" target="_blank" rel="noopener">10:股票买卖</a></p></blockquote><p><code>ll[i]</code> 表示 i 左侧极差<br><code>rr[i]</code> 表示 i 右侧极差<br>这样答案就是 $max{ll[i], rr[i + 1]}$</p><p>先用 <code>ll[i]</code> 得到 i 左侧最小的数和<code>a[i]</code>的差，然后对<code>ll[i]</code>求个前缀 max 就好了</p><blockquote><p>12:开餐馆</p></blockquote><p><code>dp[i]</code> 最后一个在 i 开，最大的价值<br>答案是数组的最大值</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/11/" target="_blank" rel="noopener">11:Tour</a> POJ 2677</p></blockquote><p>想了好几天，把一来一回的路径拆开，考虑$dp[i][j] 表示 1..i 和 1..j 两条路径$，<br>然后考虑下一个点（i）是从谁接过来的</p><p><a href="https://blog.csdn.net/xiaoxiaoluo/article/details/7636592" target="_blank" rel="noopener">https://blog.csdn.net/xiaoxiaoluo/article/details/7636592</a> 这里人为要求 $i \geq j$</p><p><a href="https://blog.csdn.net/ECNU_LZJ/article/details/71211855" target="_blank" rel="noopener">https://blog.csdn.net/ECNU_LZJ/article/details/71211855</a> 这个更直观，把路径反向，<br>方便转移</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/14/" target="_blank" rel="noopener">14:DNA</a></p></blockquote><p>调了半天，甚至还换了种思路写，最后发现问题是在于求重叠部分的长度又写错了</p><p>首先没想到的是，如果一个串被另一个包含了，那么短的直接删掉就好了</p><p>思路一：长度很少，枚举全排列，拼起来</p><p>思路二：状压dp，$dp[st][i]$表示已经拼了<code>st</code>里面这些字符串<code>i</code>是最后一个的答案，记忆化搜之</p><p>求重叠部分的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">std</span>::min(len[a], len[b]);</span><br><span class="line"><span class="keyword">while</span> (res) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(s[b], s[a] + len[a] - res) == s[b]) <span class="keyword">break</span>;</span><br><span class="line">  --res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>论善用<code>strstr</code>的重要性</p><blockquote><p><a href="http://cxsjsx.openjudge.cn/2018rec/13/" target="_blank" rel="noopener">13:上机</a></p></blockquote><p>按顺序考虑，前<code>i</code>个人的结果受前<code>i-1</code>个人的结果和第<code>i</code>与第<code>i-1</code>的顺序的影响</p><p>设计：$dp[i][l][r]$表示处理到第i个人，左侧 / 右侧有没有人</p><p>转移：<code>dp[i][k][t] = std::max(dp[i][k][t], dp[i - 1][j][k ^ 1] + a[i][k + t]);</code></p><p>注意带如果第<code>i</code>个人左侧的状态是<code>k</code>，那么对于第<code>i-1</code>个人而言，他右侧的状态就是<code>k ^ 1</code></p><p>注：用<code>k + t</code>简化，<code>a[i][0]</code>就是都没人，<code>a[i][1]</code>就是有一个,<code>a[i][2]</code>就是两侧都有人</p><p>这里的<code>j</code>是不造成影响的，转移的过程中要考虑每一个<code>j</code>（<code>0 / 1</code>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://cxsjsx.openjudge.cn/2018rec/04/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;04:What a Ridiculous Election&lt;/a&gt;&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="http://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>openjudge动态规划</title>
    <link href="http://ir1d.cf/2018/05/25/cssx/openjudge%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://ir1d.cf/2018/05/25/cssx/openjudge动态规划/</id>
    <published>2018-05-25T11:42:16.000Z</published>
    <updated>2018-06-24T11:40:54.559Z</updated>
    
    <content type="html"><![CDATA[<p>感觉之前使用md的姿势好像不对 = =</p><a id="more"></a><p>ref: <a href="https://fancypei.github.io/OpenjudgeDP/" target="_blank" rel="noopener">https://fancypei.github.io/OpenjudgeDP/</a></p><blockquote><p>LCIS $O(n^2)$</p></blockquote><p><code>dp[i][j]</code> 表示a串前i个和以<code>b[j]</code>结尾的串的LCIS的长度</p><p>转移是：</p><p><code>dp[i][j]=max(dp[i][j],dp[i-1][k]+1)    a[i]==b[j]&amp;&amp;b[k]&lt;b[j]   1&lt;=k&lt;j</code></p><p><code>dp[i][j]=max(dp[i][j],dp[i-1][j])     a[i]!=b[j]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[i] != y[j]) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &lt; dp[i - <span class="number">1</span>][k] &amp;&amp; y[k] &lt; y[j]) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个式子i从i-1转移过来，所以可以把i放到外层。这样内层循环的时候<code>a[i]</code>是固定的。根据第一个式子，<code>a[i] == b[j] &gt; b[k]</code>，实际上要找的是<code>b[j] &lt; a[i]</code> 的最大的<code>dp[i - 1][j]</code>，在内层循环的同时存一下就好了，不需要再去枚举那个k了。所以平方的复杂度就能做了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  mlen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="comment">//更新mlen</span></span><br><span class="line">    <span class="keyword">if</span> (y[j] &lt; x[i] &amp;&amp; dp[i - <span class="number">1</span>][j] &gt; mlen) &#123;</span><br><span class="line">      mlen = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算dp[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (y[j] == x[i]) &#123;</span><br><span class="line">      dp[i][j] = mlen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Ir1d/Fantasy/blob/master/POJ/2127.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/POJ/2127.cpp</a></p><p>（openjudge没有spj）</p><p>记录路径的姿势都忘光了= =</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = n; p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ans--) &#123;</span><br><span class="line">  st[++p] = b[y];</span><br><span class="line">  <span class="keyword">while</span> (a[x] != b[y]) --x;</span><br><span class="line">  y = pre[x][y];</span><br><span class="line">  --x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref: <a href="http://blog.fly2best.com/algorithm/2013/05/11/longges-common-increasing-subsequence/" target="_blank" rel="noopener">http://blog.fly2best.com/algorithm/2013/05/11/longges-common-increasing-subsequence/</a></p><ul><li>山区建小学 <a href="http://noi.openjudge.cn/ch0206/7624/" target="_blank" rel="noopener">http://noi.openjudge.cn/ch0206/7624/</a></li></ul><p>四边形不等式</p><ul><li>7627 鸡蛋的硬度</li></ul><p><code>f[i][j]=min(1+max(f[i-1][t-1],f[i][j-t])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) f[<span class="number">1</span>][i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">  f[i][j] = <span class="number">1</span> + max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i][j - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">2</span>; t &lt;= j; t++)</span><br><span class="line">    f[i][j] = min(f[i][j], <span class="number">1</span> + max(f[i - <span class="number">1</span>][t - <span class="number">1</span>], f[i][j - t]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>9265:取数游戏</p><p>自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是相邻的两个不可以同时被取走.</p><p>答案是斐波那契数，考虑最后一个取(dp[i - 2])，或者不取（dp[i - 1]）.</p></li><li><p>9267:核电站</p><p>加强，变成不能连续m个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">0</span>, m) dp[i] = <span class="number">1L</span>L &lt;&lt; i;</span><br><span class="line">--dp[m];</span><br><span class="line">g(i, m + <span class="number">1</span>, n) &#123;</span><br><span class="line">  dp[i] = <span class="number">2</span> * dp[i - <span class="number">1</span>] - dp[i - m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>9268:酒鬼</p><p>不能连续取三个，问取出的最大权值和</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f是最远，g是到i结束</span></span><br><span class="line"><span class="comment">// 答案是f[n]</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  g[i] = v[i] + max(f[i - <span class="number">2</span>], v[i - <span class="number">1</span>] + f[i - <span class="number">3</span>]);</span><br><span class="line">  f[i] = max(g[i], f[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>POJ3046</p><p><a href="https://blog.csdn.net/jaihk662/article/details/77951670" target="_blank" rel="noopener">https://blog.csdn.net/jaihk662/article/details/77951670</a></p><p>需要滚动数组</p></li></ul><p><code>dp[i][j]</code>表示前i个集合取j个数的种类数</p><p>然后 $dp[i][j] = \sum_{k=0}^{min(cnt_i, j)} dp[i - 1][j - k]$</p><ul><li><p>9288:Zju2061 Buy the Ticket</p><p>排队买票 卡特兰数</p><p>相当于在一个格点阵列中，从 (0, 0) 点走到 (n, m) 点且不穿过对角线 x = y 的方法数 。</p><p>最后答案要乘上排列数（阶乘）</p></li><li><p>6046:数据包的调度机制</p><p>区间dp，<code>dp[i][j]</code> 是把<code>[i, j]</code>这一段的数据包发出去的最小代价，然后转移的时候枚举这一段里面哪一个是最后发出的。因为是个栈，所以最后一个发出的那个包前面的是第一段，那个包后面的是第二段。</p><p><a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/6046.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/6046.cpp</a></p></li><li><p>4149:课程大作业</p><p><code>dp[i][S]</code>表示前i天完成S的最小代价</p><p>过不了</p><p><code>dp[S]</code>表示完成S的最小代价，每次枚举第一个完成哪个，记忆化搜索</p><p><a href="https://github.com/Ir1d/Fantasy/blob/master/openjudge/4149.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/openjudge/4149.cpp</a></p></li></ul><ul><li>1481 Maximum sum</li></ul><p>ll[i]为以i为终点<br>rr[i]为以i为起点</p><p>ls[i]为前i个<br>rs[i]为后i个</p><p>边界数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)</p><ul><li>162 Post Office</li></ul><p>dp[i][j]表示前i个位置放j个post office的最小代价<br>转移是dp[i][j] = min{dp[k][j - 1] + cost[k + 1][i]};<br>cost数组可以v^2p预处理</p><p>时间复杂度O(v^2p)</p><p>考虑优化：(四边形不等式)</p><p>证明略</p><p>决策变量k具有单调性</p><p>从而优化到O(v^2)</p><ul><li>1759 LIS</li></ul><p>*lower_bound(dp, dp + n, a[i]) = a[i];</p><ul><li>1768 最大子矩阵</li></ul><p>枚举起始与终点行，转化为最大子段和</p><ul><li>1775 采药</li></ul><p>01背包</p><ul><li>1808 公共子序列</li></ul><p>LCS</p><ul><li>1944 吃糖果</li></ul><p>Fibonacci</p><ul><li>1996 登山</li></ul><p>转化成求两遍LIS</p><ul><li>2421 Exchange Rates</li></ul><p>题目比较坑</p><p>dp[i][0], dp[i][1]分别是两种全部转化后最大多少</p><p>一定存在一种最优策略是每次全部转化的</p><ul><li>2718 移动路线</li></ul><p>dp[i][j] += dp[i - 1][j] + dp[i][j - 1];</p><ul><li>2728 摘花生</li></ul><p>数字正方形</p><p>dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]) + a[i][j];</p><ul><li>2984    数字组合</li></ul><p>dp[i][j] 表示前i个数拼成j的方案数</p><p>然后滚动数组优化成一维空间</p><ul><li>2988 计算字符串距离</li></ul><p>dp[i][j] 表示s的前i与t的前j的距离</p><p>然后转移就是分各个情况就好</p><p>注意和LCS不同之处在于预处理</p><p>LCS刷0即可</p><p>然而这个地方要<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, n) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">g(i, <span class="number">1</span>, m) dp[<span class="number">0</span>][i] = i;</span><br></pre></td></tr></table></figure></p><ul><li>2989 糖果</li></ul><p>转移是有条件的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, n) f(j, <span class="number">0</span>, k) &#123;</span><br><span class="line">  <span class="keyword">int</span> tee = (j - a[i] % k + k) % k;</span><br><span class="line">  dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">  <span class="keyword">if</span> (dp[i - <span class="number">1</span>][tee] || !tee)</span><br><span class="line">  dp[i][j] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(j - a[i] % k + k) % k] + a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3531 判断整除</li></ul><p>原来这个条件很常见。。。</p><p>同上题</p><p>………………刷表法的话就不用特判了= =</p><ul><li>3532 最大上升子序列和</li></ul><p>LIS 变个形</p><ul><li>4977 怪盗基德的滑翔翼</li></ul><p>求一下两个方向的LIS求max即可</p><ul><li>4978 宠物小精灵之收服</li></ul><p>二维费用的01背包问题</p><p>背包九讲(<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf" target="_blank" rel="noopener">https://github.com/tianyicui/pack/blob/master/V2.pdf</a>)</p><ul><li>4982 踩方格</li></ul><p>爆搜</p><p>或者打个表发现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>,f[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] * <span class="number">2</span> + f[i - <span class="number">2</span>];</span><br></pre></td></tr></table></figure><ul><li>6045 开餐馆</li></ul><p>dp[i]表示到i为止的最大收益</p><p>O(n^2T)</p><ul><li>8787 数的划分</li></ul><p>dp[i][j]表示将i分成j份的方案数<br>dp[i][j]=dp[i-j][1]+dp[i-j][2]+dp[i-j][3]+…+dp[i-j][j-1]+dp[i-j][j];</p><p>时间复杂度是n*k^2</p><p>O(n*k)的方法：</p><p>dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j];</p><p>dp[i-1][j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+…+dp[(i-1)-(j-1)][j-1]<br>=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1];</p><p>因此，</p><p>dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1]+dp[i-j][j]<br>=dp[i-1][j-1]+dp[i-j][j];</p><ul><li>666 放苹果</li></ul><p>假如将7个苹果放进3个盘子里，可以分2种情况考虑：1，空着一个盘子不放，即将7个苹果放进2个盘子里；2，先每个盘子均放进一个苹果，再按照本规则继续放下去。</p><p>于是有递推公式：F(X,Y)=F(X,Y-1)+F(X-Y,Y)</p><p>F(X,1)，F(1,Y),F(0,Y),F(X,0)都等于1</p><p><code>当X&lt;Y时，即比如说将5个苹果放进8个盘子里，根据题意，和将5个苹果放进5个盘子是一样的结果</code></p><p>①最少的盘子放了一个，这样每个盘子至少一个，n个盘子先放上n个，剩下的m-n个可以随便放<br>②最少的盘子没有放，这样剩下的n-1个盘子还是随便放m个</p><ul><li>6049 买书</li></ul><p>考虑分别记录拼出i这个数最后一个用了啥</p><p>注意到拼数的方案与顺序无关，因此可以递增地来考虑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] += dp[i - <span class="number">10</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">dp[i][<span class="number">1</span>] += dp[i - <span class="number">20</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">1</span>] += dp[i - <span class="number">20</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">dp[i][<span class="number">2</span>] += dp[i - <span class="number">50</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">2</span>] += dp[i - <span class="number">50</span>][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">2</span>] += dp[i - <span class="number">50</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] += dp[i - <span class="number">100</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6252 通配符字符串匹配</li></ul><p>dp[i][j]表示s[1..i]与t[1..j]是否匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">  tee = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (s[i] == <span class="string">'*'</span>) dp[i][<span class="number">0</span>] = tee;</span><br><span class="line">  g(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">    tee |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">'?'</span> || s[i] == t[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">'*'</span>) dp[i][j] = tee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7113 Charm Bracelet</li></ul><p>01背包</p><ul><li>747 Divisibility</li></ul><p>同3531 判断整除</p><p>而且数据更强？</p><p>奥妙重重</p><p>强烈怀疑3531放了个什么奇怪的数据</p><p>刷表法姿势不对竟然也能过= =</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">g(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">  x = <span class="built_in">abs</span>(x);</span><br><span class="line">  x %= k;</span><br><span class="line">  f(j, <span class="number">0</span>, k) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">    dp[i][(j + x) % k] = <span class="number">1</span>;</span><br><span class="line">    dp[i][((j - x) % k + k) % k] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[n][<span class="number">0</span>]) <span class="built_in">puts</span>(<span class="string">"Divisible"</span>);</span><br></pre></td></tr></table></figure><ul><li>7614 最低通行费</li></ul><p>dp[i][j][k]表示到(i,j)走了k步的最小代价</p><ul><li>7624 山区建小学</li></ul><p>同162 Post Office</p><ul><li>7625 三角形最佳路径问题</li></ul><p>数字三角形</p><ul><li>7627 鸡蛋的硬度</li></ul><p><a href="http://blog.csdn.net/jerry99s/article/details/48802527" target="_blank" rel="noopener">http://blog.csdn.net/jerry99s/article/details/48802527</a></p><ul><li>8462 大盗阿福</li></ul><p>saffah出过，2014暑假集训中</p><ul><li>8464 股票买卖</li></ul><p>DP……预处理后缀最大值、最大获利、前缀最大值之类的求一下对应组合的max</p><ul><li>8467 鸣人的影分身</li></ul><p>同666</p><ul><li>8471 切割回文</li></ul><p>dp[i]表示s[1..i]最小需要的切割次数</p><ul><li>8780 拦截导弹</li></ul><p>LIS</p><ul><li>8782 乘积最大</li></ul><p>dp[i][j]表示前i个分成j份</p><ul><li>8785 装箱问题</li></ul><p>01背包</p><ul><li>90 滑雪</li></ul><p>DAG最长路</p><ul><li>8786 方格取数</li></ul><p>费用流/DP</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉之前使用md的姿势好像不对 = =&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="openjudge" scheme="http://ir1d.cf/tags/openjudge/"/>
    
      <category term="dp" scheme="http://ir1d.cf/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>openjudge补习</title>
    <link href="http://ir1d.cf/2018/05/25/cssx/openjudge%E8%A1%A5%E4%B9%A0/"/>
    <id>http://ir1d.cf/2018/05/25/cssx/openjudge补习/</id>
    <published>2018-05-25T05:07:23.000Z</published>
    <updated>2018-06-23T04:51:31.883Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>8758 2的幂次方表示</p><p>印象中什么时候好像调了好久的样子，其实就是直接递归的做就好了</p></li><li><p>整数划分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">g(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">  g(j, <span class="number">1</span>, i) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - j][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[i][j] 是i分成j份的方案数</span></span><br></pre></td></tr></table></figure></li><li><p>zipper</p><p>问A和B两个串 能否交叉组合成C，要求AB内部相对顺序不变</p><p><code>dp[i][j]</code> 表示<code>A[1..i]</code>和<code>B[1..j]</code> 能否拼成<code>C[1..i+j]</code> 转移就判一下最后一个字符是否匹配</p></li></ul><ul><li><strong>复杂的整数划分问题</strong></li></ul><p>第一行: N划分成K个正整数之和的划分数目<br>第二行: N划分成若干个不同正整数之和的划分数目<br>第三行: N划分成若干个奇正整数之和的划分数目</p><p>ref: <a href="https://blog.csdn.net/tp7309/article/details/54880495" target="_blank" rel="noopener">https://blog.csdn.net/tp7309/article/details/54880495</a></p><blockquote><p>n划分成可相同的正整数</p></blockquote><p><code>dp[i][j]</code> 表示把i分成不超过j的数的和<br><code>dp[i][j] = dp[i][j - 1] + dp[i - j][j]</code><br>要么每个数都小于j，要么至少有一个等于j，把那个j去掉。</p><p><code>i &lt; j</code>时 <code>dp[i][j] = 0</code></p><p>边界：<code>dp[0][0] = 1;</code></p><blockquote><p>不相同</p></blockquote><p><code>dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1]</code><br>要么每个数都小于j，要么有一个数等于j，把唯一的那个j去掉，剩下的数都小于j了。</p><blockquote><p>k个数</p></blockquote><p><code>dp[i][j]</code> 表示把i分成j份<br><code>dp[i][j] = dp[i - j][j] + dp[i - 1][j - 1]</code><br>要么给之前的j组每个数加一，要么取出来一个1单独装一组</p><p><code>i &lt; j</code>时 <code>dp[i][j] = dp[i][i]</code></p><p>边界：<code>dp[0][i] = 1;</code></p><blockquote><p>分成奇数</p></blockquote><p><code>f[i][j]</code> 表示i分成j个正奇数<br><code>g[i][j]</code> 分成正偶数</p><p><code>g[i][j] = f[i - j][j]</code><br>偶数来自每一组奇数加一<br><code>f[i][j] = f[i - 1][j - 1] + g[i - j][j]</code><br>奇数来自偶数加一，或者最后一个1单独一组<br>边界：<code>f[0][0] = g[0][0] = 1</code></p><ul><li><p>6047:切蛋糕</p><p><code>dp[i][j[k]</code>表示<code>i*j</code>大小的切k块的答案（最大块面积的最小值）</p><p>转移的时候就枚举横竖的切法就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">g(i, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">  g(j, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">    dp[i][j][<span class="number">1</span>] = i * j;</span><br><span class="line">    g(k, <span class="number">2</span>, <span class="number">20</span>) &#123;</span><br><span class="line">      dp[i][j][k] = oo;</span><br><span class="line">      f(r, <span class="number">1</span>, i) &#123;</span><br><span class="line">        f(p, <span class="number">1</span>, k) &#123;</span><br><span class="line">          dp[i][j][k] = <span class="built_in">std</span>::min(dp[i][j][k], <span class="built_in">std</span>::max(dp[r][j][p], dp[i - r][j][k - p]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      f(c, <span class="number">1</span>, j) &#123;</span><br><span class="line">        f(p, <span class="number">1</span>, k) &#123;</span><br><span class="line">          dp[i][j][k] = <span class="built_in">std</span>::min(dp[i][j][k], <span class="built_in">std</span>::max(dp[i][c][p], dp[i][j - c][k - p]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p>感觉比之前菜多了…… 重开几页补补题吧QAQ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;8758 2的幂次方表示&lt;/p&gt;
&lt;p&gt;印象中什么时候好像调了好久的样子，其实就是直接递归的做就好了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整数划分&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="openjudge" scheme="http://ir1d.cf/tags/openjudge/"/>
    
  </entry>
  
  <entry>
    <title>程设算法上机练习小结</title>
    <link href="http://ir1d.cf/2018/05/19/cssx/%E7%A8%8B%E8%AE%BE%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E7%BB%83%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>http://ir1d.cf/2018/05/19/cssx/程设算法上机练习小结/</id>
    <published>2018-05-19T13:16:05.000Z</published>
    <updated>2018-06-23T04:52:09.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h1><ul><li><p>A:浮点数求高精度幂</p><p>正常的高精度快速幂，处理小数点的位置注意一下</p></li><li><p>B:Integer Inquiry<br>  高精度加法</p></li><li><p><strong>C:Communication System</strong><br>  每一类选一个使得最后的 <code>最小带宽/总价格</code> 最大<br>  可以枚举最小的带宽是啥 然后贪心找价格最小的</p><p>  dp的话<code>dp[i][j]</code>表示到第<code>i</code>类，带宽是<code>j</code>的答案<br>  当时一直在想<code>j</code>的范围没给不是很好办，后来看代码发现开到<code>1k</code>就可以了</p><p>  代码： <a href="https://github.com/Ir1d/Fantasy/blob/master/POJ/1018.cpp" target="_blank" rel="noopener">https://github.com/Ir1d/Fantasy/blob/master/POJ/1018.cpp</a><br>  注意 <code>POJ 1018</code> 得用 <code>C++</code> 交，不知道为啥</p></li><li><p>D:判断闰年<br>  <code>if</code>就好了</p></li><li><p>E:生理周期<br>  枚举或者<code>CRT</code></p></li><li><p>F:完美立方<br>  枚举</p></li><li><p>G:画家问题<br>  枚举第一行的结果，然后之后的操作就确定了，找答案最小的就可以了</p></li><li><p><strong>H:恼人的青蛙</strong><br>  枚举？</p></li><li><p><strong>I:放苹果</strong><br>  应该直接组合数吧？ dfs过了</p></li><li><p>J:古代密码<br>  就是给每个字母的出现次序排个序看能不能对应上</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;练习一&quot;&gt;&lt;a href=&quot;#练习一&quot; class=&quot;headerlink&quot; title=&quot;练习一&quot;&gt;&lt;/a&gt;练习一&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A:浮点数求高精度幂&lt;/p&gt;
&lt;p&gt;正常的高精度快速幂，处理小数点的位置注意一下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程设" scheme="http://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小结</title>
    <link href="http://ir1d.cf/2018/05/19/%E7%88%AC%E8%99%AB%E5%B0%8F%E7%BB%93/"/>
    <id>http://ir1d.cf/2018/05/19/爬虫小结/</id>
    <published>2018-05-19T02:32:00.000Z</published>
    <updated>2018-05-19T02:35:14.446Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫小结</p><p>爬了个小站，其实对方主要是在防注入（？），并没有怎么反爬所以其实不太困难，美中不足的是写挂了好多地方，然后有懒得增量更新爬到的结果，所以反反复复算是爬了三次，给服务器带来了不少压力。</p><p>其实是第一次用py写模拟登录（惭愧）</p><p>首先是患者列表，在翻页的时候抓包发现没有请求，翻开发者工具发现是藏在IndexedDB里面，然后补习了一下导出的姿势</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"><span class="keyword">var</span> DB_NAME = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> STORE_NAME = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(DB_NAME, DB_VERSION);</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create a new object store if this is the first time we're using</span></span><br><span class="line">  <span class="comment">// this DB_NAME/DB_VERSION combo.</span></span><br><span class="line">  request.result.createObjectStore(STORE_NAME, &#123;<span class="attr">autoIncrement</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  db = request.result;</span><br><span class="line">  <span class="comment">// Enable our buttons once the IndexedDB instance is available.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> res;</span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(STORE_NAME, <span class="string">'readonly'</span>);</span><br><span class="line"><span class="keyword">var</span> objectStore = transaction.objectStore(STORE_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'getAll'</span> <span class="keyword">in</span> objectStore) &#123;</span><br><span class="line">  <span class="comment">// IDBObjectStore.getAll() will return the full set of items in our store.</span></span><br><span class="line">  objectStore.getAll().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    res = event.target.result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是常规操作，模拟登录什么的，然后有一个坑点是request库遇到302会跟着重定向过去，但是cookie没有存= =</p><p>解决方案是开个Session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REQ = requests.Session()</span><br><span class="line">r = REQ.post(loginUrl, headers=header, data=payload)</span><br></pre></td></tr></table></figure><p>对于Cookie的处理选择用dict，然后面向StackOverflow编程学习到了崭新的更新dict的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = REQ.cookies.get_dict()</span><br><span class="line">cookie = &#123;**cookie, **dic&#125;</span><br></pre></td></tr></table></figure><p>然后也学习到了从Chrome的工具里header变成python dict的方法和把dict变成Cookie串的方法= =<br>回想当年自己真的是太naive了呀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Convert Chrome headers to Python's Requests dictionary </span></span><br><span class="line">dict([[h.partition(<span class="string">':'</span>)[<span class="number">0</span>], h.partition(<span class="string">':'</span>)[<span class="number">2</span>]] <span class="keyword">for</span> h <span class="keyword">in</span> rawheaders.split(<span class="string">'\n'</span>)])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(s)</span>:</span> <span class="comment"># Converts dict to cookie string</span></span><br><span class="line">  res = <span class="string">""</span></span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">    res += k + <span class="string">'='</span> + s[k] + <span class="string">';'</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>以及regex中加个括号得到group可以只选中匹配出来的字符串的一部分，真的赞！</p><p>捕捉异常的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  logging.exception(<span class="string">"message"</span>)</span><br></pre></td></tr></table></figure></p><p>创建文件夹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'&#123;&#125;_res/&#123;&#125;'</span>.format(CRAWL_ID, idx)):</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    os.makedirs(<span class="string">'&#123;&#125;_res/&#123;&#125;'</span>.format(CRAWL_ID, idx))</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> exc: <span class="comment"># Guard against race condition</span></span><br><span class="line">    <span class="keyword">if</span> exc.errno != errno.EEXIST:</span><br><span class="line">      <span class="keyword">raise</span> <span class="comment"># 套在 try except里面</span></span><br></pre></td></tr></table></figure><p>下载图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">photoRes = requests.get(curUrl, headers=newHeader)</span><br><span class="line"><span class="comment"># if photoRes.status_code == 200:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'&#123;&#125;_res/&#123;&#125;/&#123;&#125;.&#123;&#125;'</span>.format(CRAWL_ID, idx, idNum, curName.split(<span class="string">'.'</span>)[<span class="number">-1</span>]), <span class="string">'ab'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(photoRes.content)</span><br></pre></td></tr></table></figure><p>最后一个坑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">photoNames = [x[<span class="string">'picId'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> jsonRes[<span class="string">'result'</span>] <span class="keyword">if</span> <span class="string">"X光"</span> <span class="keyword">in</span> str(x[<span class="string">'tags'</span>])]</span><br></pre></td></tr></table></figure><p>注意到<code>x[&#39;tags&#39;]</code>可以是<code>None</code> 所以加上 <code>str</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬虫小结&lt;/p&gt;
&lt;p&gt;爬了个小站，其实对方主要是在防注入（？），并没有怎么反爬所以其实不太困难，美中不足的是写挂了好多地方，然后有懒得增量更新爬到的结果，所以反反复复算是爬了三次，给服务器带来了不少压力。&lt;/p&gt;
&lt;p&gt;其实是第一次用py写模拟登录（惭愧）&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="爬虫" scheme="http://ir1d.cf/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="python" scheme="http://ir1d.cf/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>程设语言部分笔记</title>
    <link href="http://ir1d.cf/2018/05/19/cssx/%E7%A8%8B%E8%AE%BE%E8%AF%AD%E8%A8%80%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://ir1d.cf/2018/05/19/cssx/程设语言部分笔记/</id>
    <published>2018-05-19T02:27:43.000Z</published>
    <updated>2018-06-23T04:52:19.889Z</updated>
    
    <content type="html"><![CDATA[<p>断更了好久……</p><p>其实也说不清在忙什么……</p><p>莫名其妙的……</p><p>雾：下文内含大量typo（拼音输入法）</p><hr><p><a href="http://cxsjsx.openjudge.cn/hw201808/B/" target="_blank" rel="noopener">OpenJudge - B:按距离排序</a> 给struct重载() 来当比较器传给std::sort</p><p><a href="http://cxsjsx.openjudge.cn/hw201807/G/" target="_blank" rel="noopener">OpenJudge - G:你真的搞清楚为啥 while(cin &gt;&gt; n) 能成立了吗？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重载强制类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改指针一定要小心，尤其是模板里面 <code>*a = *b</code> 注意指针指向的地址是否变了 是否只改变了值</p><p><a href="http://cxsjsx.openjudge.cn/hw201807/C/" target="_blank" rel="noopener">OpenJudge - C:山寨版istream_iterator</a><br><code>operator *()</code> 重载解引用运算符   <code>operator ++(int)</code> 是后缀自增运算符</p><p><a href="http://cxsjsx.openjudge.cn/hw201808/E/" target="_blank" rel="noopener">OpenJudge - E:很难蒙混过关的CArray3d三维数组模板类</a></p><p>写得很痛苦，的确没有蒙混过关，还是应该老实的……</p><blockquote><ul><li>建议做法：</li></ul><ol><li>a[i][j][k] 这个表达式的第一个[]返回一个<strong>内部类</strong>的对象，该内部类也重载了[],且返回值为指针。</li><li>必要时需重载对象到指针的强制类型转换运算符</li></ol></blockquote><p><a href="http://cxsjsx.openjudge.cn/hw201808/F/" target="_blank" rel="noopener">OpenJudge - F:我自己的 ostream_iterator</a></p><p>刚开始一直在想怎么让他赋值进去就直接能输出，后来发现实际上是后面有一个++的过程，++的时候输出就好了。<br>然后再就是<code>*x=*a</code>重载的是<code>*</code>运算符不是等号= =</p><p><a href="http://cxsjsx.openjudge.cn/hw201809/A/" target="_blank" rel="noopener">OpenJudge - A:List</a> </p><p>简直惨痛。。。 merge自己到自己的操作要忽略掉就好了= = 果然还是应该写对拍</p><p><a href="http://cxsjsx.openjudge.cn/hw201809/F/" target="_blank" rel="noopener">OpenJudge - F:冷血格斗场</a></p><p>听说是当年pkusc的题，就是找lowerbound 然后再找前面的一个 比较比较就好了</p><p>没考虑到的地方是可能lowerbound的前面找到的那个并不是id最小的，要再lowerbound一下= =</p><p><a href="http://cxsjsx.openjudge.cn/2016mid2018/08/" target="_blank" rel="noopener">OpenJudge - 08:编程填空：维护平面点</a></p><p><a href="http://cxsjsx.openjudge.cn/hw201809/H/" target="_blank" rel="noopener">OpenJudge - H:编程填空：数据库内的学生信息</a></p><p>比较器的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Greater</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>upd：重写了 后三个typedef 不是必须的<br><a href="http://cxsjsx.openjudge.cn/2015mid2018/11/" target="_blank" rel="noopener">OpenJudge - 11:编程填空：数据库内的学生信息</a></p><p><strong>太难了= =</strong></p><p><strong>static的初始化方式</strong></p><p>printf – <code>%x</code> 十六进制</p><hr><p>期中复习</p><p>常引用：不是引用的内容不能修改，是不能通过常引用修改<br><code>const T</code> 或者 <code>const T &amp;</code>类型不能用来初始化 <code>T&amp;</code>类型，除非经过了强制类型转换<br>调用内联函数的语句前必须已经出现内联函数的定义（整个函数体），不能只有声明<br>同名函数只有参数表不同才算是重载，两个同名函数的参数表相同而返回值不同不是重载，是重复定义<br>new分配的空间一定要delete释放，否则程序运行结束后也不会被系统收回<br>一个string对象的大小（sizeof）是固定的（在不同编译器中并不相同，与字符串长度无关）<br>string对象中只存放地址和其他信息<br>大写字母ASCII码小于小写字母<br>struct默认公有，class默认私有<br>局部变量存储空间是动态分配在栈中的<br><strong><code>CTest* pArray[3] = {new CTest(4), new CTest(1, 2)};</code> 只生成了两个对象，第三个没有生成</strong><br>复制构造函数的参数一般用const引用，这样既能以常量对象，也能以非常量对象作为参数<br><strong>函数的参数对象以及作为函数返回值的对象，在消亡时也会引发析构函数调用</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDemo::CDemo(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">CDemo dl;</span><br><span class="line"><span class="function">CDemo <span class="title">Test</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回值是临时对象</span></span><br><span class="line">  foo();</span><br><span class="line">  <span class="keyword">return</span> dl;</span><br><span class="line">&#125;</span><br><span class="line">CDemo d4;</span><br><span class="line">d4 = <span class="number">6</span>; <span class="comment">// 这里6先被转换成临时对象，然后再赋值。语句执行完毕后临时对象消亡，调用析构函数</span></span><br></pre></td></tr></table></figure></p><p>并非所有对象生成的时候都通过上面的构造函数初始化，作为参数和返回值的时候是调用复制构造函数，需要另外再写<br>不能通过对常量对象调用普通成员函数，但是可以调用const的<br>两个成员函数的名字和参数表相同，但是一个const，另一个不是，算重载<br>封闭类生成的时候先执行所有成员对象的构造函数，再执行封闭类自己的构造函数<br>消亡的时候是先执行封闭类的析构函数，后执行成员对象的。<br>常量型成员变量和引用型必须要在构造函数的初始化列表中初始化<br>友元函数内部可以访问该类对象的private<br>不能吧其他类的私有成员函数声明为友元<br>交叉调用的时候允许写一个提前声明<code>class s;</code>但是在定义出现之前，不允许任何会导致该类对象被生成的语句。使用该类的指针或者引用是没有问题的<br>可以声明另一个类是自己的友元<br>友元关系不能传递<br>类的非内联成员函数的函数体只能出现在某一个<code>.cpp</code>文件中，不能放在头文件中被多个<code>.cpp</code>文件包含，否则链接时会发生重复定义的错误<br>如果编写了构造函数，则编译器不自动生成默认构造函数，一个类不一定会有默认（无参）构造函数，但是一定会有复制构造函数<br><code>=</code>只能重载为成员函数<br>在delete之前判断是否是NULL<br>注意赋值给自己的时候的指针的处理<br>参数os只能是ostream的引用，而不能使ostream对象，是因为ostream的复制构造函数是私有的，不能生成参数对象<br>类型强制转换运算符是单目运算符，只能被重载为成员函数 <code>operator double()  {}</code><br><code>++a</code>或者<code>--a</code>前置：<code>CDemo&amp; operator ++();</code><br><code>a++</code>或者<code>a--</code>后置：<code>CDemo operator ++(int);</code><br>运算符重载不改变优先级<br>不能被重载的运算符：<code>.</code> <code>.*</code>（成员指针访问运算符） <code>::</code> <code>?:</code> <code>sizeof</code><br>重载<code>() [] -&gt;</code>或者 赋值<code>=</code>时，只能重载为成员函数<br>派生类的成员函数只能访问所作用的那个对象（this指向的）的基类保护成员，不能访问其他基类对象的基类保护成员<br>如果一个派生类对象使用默认复制构造函数初始化的，那么他内部包含的基类对象也要用基类的复制构造函数初始化<br>封闭类类似<br>派生类对象生成的时候，先从上至下执行所有基类的构造函数，再按照成员对象的定义顺序执行各个成员对象的构造函数，最后执行自身的<br>消亡时，先执行自身的，后面与够早的次序相反<br>如果是public派生，派生类对象也是基类对象，如果是private或者protected，就不成立<br>多态的函数调用语句被称为是<code>动态联编</code>的<br>虚函数表的地址在对象存储空间的最前端<br>成员函数（静态成员函数、构造函数、析构函数除外）中调用其他虚成员函数是多态的<br>析构函数和构造函数中调用的虚函数不是多态<br>只要基类中的某个函数被声明成虚函数，则派生类中的同名、同参数表的成员函数及时前面没写virtual也是虚函数<br>虚析构函数：只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual声明，都是虚析构函数<br><strong>一个类如果定义了虚函数，则最好将析构函数也定义成虚函数</strong><br>独立的抽象类的对象不存在，但是被包含在派生类对象中的抽象类的对象是可以存在的<br>抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能<br>cerr clog 不能被重定向<br>cerr 不使用缓冲区 clog 使用<br><code>while (cin &gt;&gt; n)</code> 是因为把ostream到bool的转换重载了</p><p>顺序容器：vector, deque, list<br>关联容器：set, multiset, map, multimap<br>容器适配器：stack, queue, priority_queue<br>rend():只想容器中的第一个元素前面的位置的反向迭代器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.rbegin(); it != v.rend(); ++it);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机</td></tr><tr><td>deque</td><td>随机</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set/ multiset</td><td>双向</td></tr><tr><td>map/ multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; output(<span class="built_in">cout</span>,<span class="string">" "</span>);</span><br><span class="line">copy (v.begin(), v.end(), output);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), <span class="built_in">std</span>::back_inserter(dest1));</span><br></pre></td></tr></table></figure><hr><p>考完试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">sz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">int</span>  A &lt;<span class="keyword">int</span>, <span class="number">40</span>&gt;::c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt; &gt; <span class="keyword">int</span>  A &lt;<span class="keyword">int</span>, <span class="number">50</span>&gt;::c = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>const算不算重载<br>什么时候需要在初始化列表里初始化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;断更了好久……&lt;/p&gt;
&lt;p&gt;其实也说不清在忙什么……&lt;/p&gt;
&lt;p&gt;莫名其妙的……&lt;/p&gt;
&lt;p&gt;雾：下文内含大量typo（拼音输入法）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://cxsjsx.openjudge.cn/hw201808/B/&quot; target
      
    
    </summary>
    
      <category term="笔记" scheme="http://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="程设" scheme="http://ir1d.cf/tags/%E7%A8%8B%E8%AE%BE/"/>
    
      <category term="C++" scheme="http://ir1d.cf/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>efb转发微信消息到tg</title>
    <link href="http://ir1d.cf/2018/03/10/efb%E8%BD%AC%E5%8F%91%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E5%88%B0tg/"/>
    <id>http://ir1d.cf/2018/03/10/efb转发微信消息到tg/</id>
    <published>2018-03-10T15:57:50.000Z</published>
    <updated>2018-06-23T04:50:32.629Z</updated>
    
    <content type="html"><![CDATA[<p>折腾很多坑</p><p>在NanoApe指点下得知应该装v1.6.6</p><p>然后就很好办啦</p><p>ref: <a href="https://konano.github.io/2018/02/17/EFB-use/" target="_blank" rel="noopener">https://konano.github.io/2018/02/17/EFB-use/</a></p><p>upd(2018.5.19): 经常掉线 其实很不好用= =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;折腾很多坑&lt;/p&gt;
&lt;p&gt;在NanoApe指点下得知应该装v1.6.6&lt;/p&gt;
&lt;p&gt;然后就很好办啦&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&quot;https://konano.github.io/2018/02/17/EFB-use/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="操作" scheme="http://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="ehForwarderBot" scheme="http://ir1d.cf/tags/ehForwarderBot/"/>
    
      <category term="telegram" scheme="http://ir1d.cf/tags/telegram/"/>
    
  </entry>
  
  <entry>
    <title>安装wxPython</title>
    <link href="http://ir1d.cf/2018/03/01/%E5%AE%89%E8%A3%85wxPython/"/>
    <id>http://ir1d.cf/2018/03/01/安装wxPython/</id>
    <published>2018-02-28T23:55:54.000Z</published>
    <updated>2018-06-23T04:47:38.430Z</updated>
    
    <content type="html"><![CDATA[<p>你可能需要这个【</p><p><a href="https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560" target="_blank" rel="noopener">https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560</a></p><p>甚至可能需要手动编译整个wxwidgets</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你可能需要这个【&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://g
      
    
    </summary>
    
      <category term="操作" scheme="http://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="wxPython" scheme="http://ir1d.cf/tags/wxPython/"/>
    
  </entry>
  
  <entry>
    <title>telegram-bots</title>
    <link href="http://ir1d.cf/2018/02/24/telegram-bots/"/>
    <id>http://ir1d.cf/2018/02/24/telegram-bots/</id>
    <published>2018-02-24T03:49:44.000Z</published>
    <updated>2018-06-23T04:46:57.857Z</updated>
    
    <content type="html"><![CDATA[<p>写 Telegram bot 的时候遇到了问题，一直在纠结为什么我的 bot 需要 <code>/asdf@bot</code> 而不是 <code>/asdf</code> 就行= =</p><p>最后发现问题在这里：<a href="https://core.telegram.org/bots#privacy-mode" target="_blank" rel="noopener">https://core.telegram.org/bots#privacy-mode</a></p><p>官方API：<a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">https://core.telegram.org/bots/api</a></p><p>一些现成的整理：<a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets" target="_blank" rel="noopener">https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets</a></p><p>以及 TG bot 传文件大小是50M= = 图片是10M</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写 Telegram bot 的时候遇到了问题，一直在纠结为什么我的 bot 需要 &lt;code&gt;/asdf@bot&lt;/code&gt; 而不是 &lt;code&gt;/asdf&lt;/code&gt; 就行= =&lt;/p&gt;
&lt;p&gt;最后发现问题在这里：&lt;a href=&quot;https://core.tele
      
    
    </summary>
    
      <category term="操作" scheme="http://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="telegram" scheme="http://ir1d.cf/tags/telegram/"/>
    
  </entry>
  
  <entry>
    <title>机器学习记录</title>
    <link href="http://ir1d.cf/2018/02/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://ir1d.cf/2018/02/09/机器学习记录/</id>
    <published>2018-02-09T08:03:20.000Z</published>
    <updated>2018-06-23T04:47:43.635Z</updated>
    
    <content type="html"><![CDATA[<ol><li>[done] Andrew NG coursera 机器学习</li><li>cs229 <a href="https://see.stanford.edu/course/cs229" target="_blank" rel="noopener">https://see.stanford.edu/course/cs229</a></li><li><a href="http://deeplearning.stanford.edu/wiki/index.php/UFLDL_Tutorial" target="_blank" rel="noopener">UFLDL</a><br><a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL2</a><br>西瓜书《机器学习》 机器学习实战</li><li>机器学习基石（林轩田）<br>机器学习技法<blockquote><p>李宏毅</p></blockquote></li></ol><p>配合着台湾林轩田的《机器学习基石+技法》把李航的《统计学习方法》这本书走一遍</p><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/courses.html</a><br><a href="https://www.youtube.com/channel/UC2ggjtuuWvxrHHHiaDH1dlQ/playlists" target="_blank" rel="noopener">https://www.youtube.com/channel/UC2ggjtuuWvxrHHHiaDH1dlQ/playlists</a></p><p>花书</p><ol start="5"><li>Neural Network for Machine Learning-coursera-多伦多大学</li><li>cs224n</li><li>cs231n</li><li>Neural Networks for NLP</li><li><a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap1.html</a></li><li>deeplearning <a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/courses.html</a><br><a href="http://blog.csdn.net/zouxy09/article/details/8775360" target="_blank" rel="noopener">http://blog.csdn.net/zouxy09/article/details/8775360</a><br><a href="https://www.cs.ox.ac.uk/people/nando.defreitas/machinelearning/" target="_blank" rel="noopener">https://www.cs.ox.ac.uk/people/nando.defreitas/machinelearning/</a></li><li>drl CS 294</li><li>MIT 6.S191 (bilibili未搬运) <a href="https://www.youtube.com/watch?v=JN6H4rQvwgY&amp;index=1&amp;list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=JN6H4rQvwgY&amp;index=1&amp;list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI</a></li><li>David Silver</li><li><a href="https://www.coursera.org/specializations/machine-learning" target="_blank" rel="noopener">https://www.coursera.org/specializations/machine-learning</a></li><li>deeplearning.ai coursera</li><li><a href="http://gameaibook.org" target="_blank" rel="noopener">http://gameaibook.org</a></li><li>《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》<br>Machine Learning A Probabilistic Perspective Learning</li><li><a href="http://deeplearning.net/reading-list/" target="_blank" rel="noopener">http://deeplearning.net/reading-list/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;[done] Andrew NG coursera 机器学习&lt;/li&gt;
&lt;li&gt;cs229 &lt;a href=&quot;https://see.stanford.edu/course/cs229&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="笔记" scheme="http://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://ir1d.cf/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="http://ir1d.cf/2018/02/08/notes/2017%E5%B0%8F%E7%BB%93/"/>
    <id>http://ir1d.cf/2018/02/08/notes/2017小结/</id>
    <published>2018-02-08T04:11:09.000Z</published>
    <updated>2018-06-23T04:49:37.255Z</updated>
    
    <content type="html"><![CDATA[<p>今天小年<br>偶然看到学妹发的WC2018的节目，发现时间原来过得好快<br>这三年WC上24OI都有节目，也算是很妙的一件事吧 好在一届更比一届强，并非不务正业XD<br>本来以为都忘记了的事，突然发现原来记得清清楚楚<br>翻了翻知乎上几个OI相关的问题，pyc问的时候我还是个上台拿衣服的孩子吧= =<br>转眼间，大半的答主都不认识了<br>高三一年下来，不那么跳了，写了很久的很长的东西，却还是完全没有剖析清楚内心<br>出了些意外，不过还好无大碍<br>高考还算可以，靠着pkusc的运气还是混进了园子<br>还是很喜欢你<br>可能每次写回忆录写得都是一篇流水 也并没有什么特别值得叙说的事<br>就当是结局圆满吧<br>2018 愿安 希望可以变得自信点<br>愿大家诸事顺遂，永远行走在光明向上的路上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天小年&lt;br&gt;偶然看到学妹发的WC2018的节目，发现时间原来过得好快&lt;br&gt;这三年WC上24OI都有节目，也算是很妙的一件事吧 好在一届更比一届强，并非不务正业XD&lt;br&gt;本来以为都忘记了的事，突然发现原来记得清清楚楚&lt;br&gt;翻了翻知乎上几个OI相关的问题，pyc问的时
      
    
    </summary>
    
      <category term="回忆录" scheme="http://ir1d.cf/categories/%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>20180206comments</title>
    <link href="http://ir1d.cf/2018/02/06/notes/20180206comments/"/>
    <id>http://ir1d.cf/2018/02/06/notes/20180206comments/</id>
    <published>2018-02-06T14:24:42.000Z</published>
    <updated>2018-06-23T04:49:42.947Z</updated>
    
    <content type="html"><![CDATA[<p>高中同学聚会，见到大家其实很开心</p><p>有人喝酒 听到了不少劲爆的消息</p><p>有个老哥还喝醉了</p><p>喝醉的老哥感觉很爱面子 一直反复在说高考</p><p>是梦魔吧……sigh</p><p>愿安</p><p>很容易就想起你了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高中同学聚会，见到大家其实很开心&lt;/p&gt;
&lt;p&gt;有人喝酒 听到了不少劲爆的消息&lt;/p&gt;
&lt;p&gt;有个老哥还喝醉了&lt;/p&gt;
&lt;p&gt;喝醉的老哥感觉很爱面子 一直反复在说高考&lt;/p&gt;
&lt;p&gt;是梦魔吧……sigh&lt;/p&gt;
&lt;p&gt;愿安&lt;/p&gt;
&lt;p&gt;很容易就想起你了&lt;/p&gt;

      
    
    </summary>
    
      <category term="回忆录" scheme="http://ir1d.cf/categories/%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>cprimerplus</title>
    <link href="http://ir1d.cf/2018/02/05/cprimerplus/"/>
    <id>http://ir1d.cf/2018/02/05/cprimerplus/</id>
    <published>2018-02-05T14:10:39.000Z</published>
    <updated>2018-06-23T04:50:36.553Z</updated>
    
    <content type="html"><![CDATA[<p>八进制 023 <code>%o</code> <code>%lo</code></p><p>十六进制0xdbf <code>%x</code> <code>%lx</code></p><p><code>&#39;\007&#39;, &#39;\07&#39;, &#39;\7&#39;</code>都是八进制表示</p><p><code>3.4l</code>表示使数字成为long double类型，默认是double</p><p>c只保证float有6位精度</p><p>当缓冲区满、遇到换行符、需要输入的时候刷新缓冲区</p><p>或者使用<code>fflush()</code>函数</p><p><code>%p</code>输出指针 <code>%%</code> 百分号</p><p><code>%5.2f</code>是字符宽度为5，小数点后2位的浮点数</p><p><code>%10d</code>是右对齐 <code>%-10d</code>是左对齐</p><p>printf返回值是输出成功的个数<br>printf的float和double都是<code>%f</code>而scanf的float是<code>%f</code>double是<code>%lf</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八进制 023 &lt;code&gt;%o&lt;/code&gt; &lt;code&gt;%lo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;十六进制0xdbf &lt;code&gt;%x&lt;/code&gt; &lt;code&gt;%lx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;#39;\007&amp;#39;, &amp;#39;\07&amp;#39;, &amp;#
      
    
    </summary>
    
      <category term="笔记" scheme="http://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C" scheme="http://ir1d.cf/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>bsgs</title>
    <link href="http://ir1d.cf/2018/01/28/bsgs/"/>
    <id>http://ir1d.cf/2018/01/28/bsgs/</id>
    <published>2018-01-28T04:06:16.000Z</published>
    <updated>2018-06-23T04:49:58.592Z</updated>
    
    <content type="html"><![CDATA[<p>BSGS 可以用来求离散对数</p><p><a href="http://kzoacn.is-programmer.com/posts/97193.html" target="_blank" rel="noopener">http://kzoacn.is-programmer.com/posts/97193.html</a></p><p><a href="http://blog.csdn.net/FromATP/article/details/56013530" target="_blank" rel="noopener">http://blog.csdn.net/FromATP/article/details/56013530</a></p><p>注意朴素的 BSGS 要求 a 和 c 互质</p><p>POJ 2471 用 map 很容易 TLE ，手动开 <code>-O2</code> 过的</p><p><code>#pragma GCC optimize(&quot;O2&quot;)</code>交<code>G++</code></p><p>扩展BSGS是不断提取a和c的公因子直到互质</p><p><a href="http://blog.csdn.net/clove_unique/article/details/51227328" target="_blank" rel="noopener">http://blog.csdn.net/clove_unique/article/details/51227328</a></p><p>简易hash= =<br>把冲突的往后一个位置堆直到不冲突= =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BSGS 可以用来求离散对数&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kzoacn.is-programmer.com/posts/97193.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://kzoacn.is-programm
      
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="BSGS" scheme="http://ir1d.cf/tags/BSGS/"/>
    
  </entry>
  
  <entry>
    <title>矩阵乘法小优化</title>
    <link href="http://ir1d.cf/2018/01/28/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%B0%8F%E4%BC%98%E5%8C%96/"/>
    <id>http://ir1d.cf/2018/01/28/矩阵乘法小优化/</id>
    <published>2018-01-27T23:56:59.000Z</published>
    <updated>2018-06-25T15:00:01.811Z</updated>
    
    <content type="html"><![CDATA[<p>看叉姐的repo翻到矩阵相关的板子</p><a id="more"></a><p>然后发现里面有这样一句话</p><p>乘法的时候将$B$数组转置一下然后$C[i][j] = \sum{A[i][k]\times B[j][k]}$会有奇效。</p><p>然后操作了一番发现的确是这么回事 Qrz%%%</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line">f(i, <span class="number">0</span>, <span class="number">233</span>) f(j, <span class="number">0</span>, <span class="number">233</span>) a[i][j] = rand(), b[i][j] = rand();</span><br><span class="line"><span class="keyword">double</span> st = clock();</span><br><span class="line">f(i, <span class="number">0</span>, <span class="number">233</span>) f(j, <span class="number">0</span>, <span class="number">233</span>) f(k, <span class="number">0</span>, <span class="number">233</span>)</span><br><span class="line">  c[i][j] += a[i][k] * b[k][j];</span><br><span class="line"><span class="keyword">double</span> ed = clock();</span><br><span class="line">f(i, <span class="number">0</span>, <span class="number">233</span>) f(j, <span class="number">0</span>, <span class="number">233</span>) &#123;</span><br><span class="line">  d[i][j] = b[j][i]; c[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(i, <span class="number">0</span>, <span class="number">233</span>) f(j, <span class="number">0</span>, <span class="number">233</span>) f(k, <span class="number">0</span>, <span class="number">233</span>)</span><br><span class="line">  c[i][j] += a[i][k] * d[j][k];</span><br><span class="line"><span class="keyword">double</span> e2 = clock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, ((e2 - ed) - (ed - st)) / CLOCKS_PER_SEC);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure><p>本机大概能差<code>0.02s</code></p><p>以及惊讶地发现<code>CLOCKS_PER_SEC</code>在新电脑上是<code>1e6</code>了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看叉姐的repo翻到矩阵相关的板子&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="矩阵乘法" scheme="http://ir1d.cf/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大连六重</title>
    <link href="http://ir1d.cf/2018/01/28/%E5%A4%A7%E8%BF%9E%E5%85%AD%E9%87%8D/"/>
    <id>http://ir1d.cf/2018/01/28/大连六重/</id>
    <published>2018-01-27T23:28:40.000Z</published>
    <updated>2018-06-24T13:00:59.045Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/d4881b876b8a" target="_blank" rel="noopener">https://www.jianshu.com/p/d4881b876b8a</a></p><a id="more"></a><p>忙了20多天组织完这个六重</p><p>也不知道是否值得</p><p>就当是神奇的经历吧</p><p>感谢大家的帮助 当天赶完了战报 想了好多 写起来感觉大学国文真的是白学了QAQ</p><p>准备的过程和出锅的时候甚至是满满的无力感</p><p>有种那年NOI的时候的flashback</p><p>可我怎么就没想到呢= =</p><p>不过好在是在大连做的</p><p>我们甚至可以拆了补一补做成正儿八经的六重</p><p>表白大连蓝军</p><p><img src="https://upload-images.jianshu.io/upload_images/145746-552077acfb413edb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>2018.1.27.12:51 - 2018.1.28 14:42</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d4881b876b8a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/d4881b876b8a&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ingress" scheme="http://ir1d.cf/categories/Ingress/"/>
    
    
      <category term="竹笋" scheme="http://ir1d.cf/tags/%E7%AB%B9%E7%AC%8B/"/>
    
      <category term="大连" scheme="http://ir1d.cf/tags/%E5%A4%A7%E8%BF%9E/"/>
    
  </entry>
  
</feed>
