<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neverland</title>
  
  <subtitle>你是我不愿醒来的梦啊&lt;br&gt;真是柔情一场</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ir1d.cf/"/>
  <updated>2019-02-11T14:19:03.837Z</updated>
  <id>https://ir1d.cf/</id>
  
  <author>
    <name>Ir1d</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Face Detection Demo 评测</title>
    <link href="https://ir1d.cf/2019/02/11/Face-Detection-Demo-%E8%AF%84%E6%B5%8B/"/>
    <id>https://ir1d.cf/2019/02/11/Face-Detection-Demo-评测/</id>
    <published>2019-02-11T13:00:24.000Z</published>
    <updated>2019-02-11T14:19:03.837Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Face Detection 代码测试</li></ul><a id="more"></a><p>总体来说其实 doc 都蛮清楚，搞了这么久其实还是自己基本功不够扎实</p><p>Google 真好用.webp</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><a href="https://github.com/mahyarnajibi/SSH" target="_blank" rel="noopener">https://github.com/mahyarnajibi/SSH</a></p><p>编译 <code>caffe-ssh</code> 之后要把 <code>caffe-ssh/python</code> 塞进 <code>PYTHONPATH</code>，方法是 <code>echo $PYTHONPATH=xxx</code></p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p><a href="https://github.com/sciencefans/RSA-for-object-detection" target="_blank" rel="noopener">https://github.com/sciencefans/RSA-for-object-detection</a></p><p>需要 matlab。</p><p>跑的时候可能需要自己 <code>addpath</code>，一个是加那个 <code>caffemex</code> 下面的 <code>matlab</code> 文件夹（类似上面的 pycaffe），另一个是要加 <code>predict/utils/bin</code> 这个目录，因为底下有 <code>nms_mex</code> 这个东西……</p><p><code>caffemex</code> 编译的时候如果 <code>make test</code> 如果报错是正常的，好像是因为魔改版的 caffe 加了新层没有加上配套的测试用例</p><h2 id="face-py-faster-rcnn"><a href="#face-py-faster-rcnn" class="headerlink" title="face-py-faster-rcnn"></a>face-py-faster-rcnn</h2><p>这个比 Detectron 要扎心得多……</p><p><a href="https://github.com/playerkk/face-py-faster-rcnn" target="_blank" rel="noopener">https://github.com/playerkk/face-py-faster-rcnn</a></p><p>他那个远古的 caffe-faster-rcnn 有问题，搜索一波得知使用 <code>merge -X theirs</code> 这种方式把新的 caffe 合进来就行（caffe 那个仓库就行，不是非得要 pytorch 里的那个）</p><p>它 README 拉到最下面才是那个 face 上面训的 model，不然前面那堆 model 其实都是直接在 wider 上面训的（印象中）</p><p>然后那个 <code>tools/demo.py</code> 里面找 model 的时候可能有些不尽人意，用的时候就写死成本机绝对路径就好了</p><h2 id="HR-ER"><a href="#HR-ER" class="headerlink" title="HR_ER"></a>HR_ER</h2><p>需要 matlab 环境</p><p><a href="https://github.com/peiyunh/tiny" target="_blank" rel="noopener">https://github.com/peiyunh/tiny</a></p><p>编译 matconvnet 的时候请务必指定 cudaRoot 和 cudnnRoot，否则可能看起来很正常然而 <code>CUDNN_STATUS_BAD_PARAM</code> 或者 <img src="https://i.loli.net/2019/02/11/5c618449c3b2e.png" alt="20190211221848.png"></p><p>其实应该这样的啦</p><p>后面都海星，注意那个 <code>cd utils</code> 是指的是 tiny 下面的那个 utils = =</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Face Detection 代码测试&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>OI Wiki 相关的技能点</title>
    <link href="https://ir1d.cf/2019/02/09/OI-Wiki-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E8%83%BD%E7%82%B9/"/>
    <id>https://ir1d.cf/2019/02/09/OI-Wiki-相关的技能点/</id>
    <published>2019-02-09T06:43:08.000Z</published>
    <updated>2019-02-11T14:09:41.252Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录下吧，免得吹逼的时候忘记了（×</li></ul><ol><li>python-markdown + mkdocs 的方案（当时还不知道有 vuepress）</li><li>找到 remarkjs 来做 lint，而且搞了几个自用的插件，似乎和 pymdownx 还算是兼容</li><li>魔改 gitment，后换用 gitalk</li><li>大量修改 mkdocs-material 的主题（React）</li><li>搭建 elasticsearch 替换原有搜索（比 Algolia Docsearch 不知道高到哪里去了）</li><li>nginx 配置 brotil，gzip，用 acme.sh 签证书，配置 patch、一系列优化</li><li>用 mathjax-node 配置服务器端渲染 mathjax （mathjax-ssr 雾）</li><li>配置 gulp 来压缩构建产物等一系列操作（感谢 @Margatroid 大佬 carry）</li><li>配置 instantClick（感谢 @frank 大佬 carry）</li></ol><p><del>10. 这玩意肯定能凑出来十条的</del></p><ol><li>搞了个 lintbot，自动对 pr 做 lint</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;记录下吧，免得吹逼的时候忘记了（×&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;python-markdown + mkdocs 的方案（当时还不知道有 vuepress）&lt;/li&gt;
&lt;li&gt;找到 remarkjs 来做 lint，而且搞了几个自用的插件，似乎和 p
      
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>mkdocs 配置 Elasticsearch</title>
    <link href="https://ir1d.cf/2019/01/23/mkdocs-%E9%85%8D%E7%BD%AE-Elasticsearch/"/>
    <id>https://ir1d.cf/2019/01/23/mkdocs-配置-Elasticsearch/</id>
    <published>2019-01-23T13:40:16.000Z</published>
    <updated>2019-01-24T06:38:29.997Z</updated>
    
    <content type="html"><![CDATA[<ul><li>mkdocs 配置 Elasticsearch</li></ul><a id="more"></a><p>按照 <a href="https://imququ.com/post/elasticsearch.html" target="_blank" rel="noopener">https://imququ.com/post/elasticsearch.html</a></p><p>除了 elasticsearch.yml 里不需要再配置 analyzer，现在新版本是在建 index 的时候放到 setting 字段里 <a href="https://github.com/elastic/elasticsearch/issues/2630" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/issues/2630</a></p><p>分词插件在 <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p><p>ubuntu 上面按照官网的来直接 apt 装，比 docker 还方便（雾）</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>用 express 封装了一下搜索和查询结果（main.js）</p><p>关于 cors，还是被坑了一下，在 oi-wiki.org 搜的时候，存到了 cache 里，再用别的域名搜的时候，就会被 cors 给拦住。需要加上 <code>add_header &#39;Vary&#39; &quot;Origin&quot;;</code>，来告诉 client side 这个 cors 的域名可能会有多种情况。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>主要改的 <code>assets/javascripts/components/Material/Search/Result.jsx</code>，因为不想每打一个字就发一个请求，就给 delay 了一下，参见 <a href="https://github.com/Ir1d/mkdocs-material/tree/es" target="_blank" rel="noopener">https://github.com/Ir1d/mkdocs-material/tree/es</a></p><h2 id="es-配置"><a href="#es-配置" class="headerlink" title="es 配置"></a>es 配置</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>（init.js）</p><p><code>client.bulk</code> 是个好东西</p><h3 id="搭配-github-webhook"><a href="#搭配-github-webhook" class="headerlink" title="搭配 github webhook"></a>搭配 github webhook</h3><p>用的是 <code>modified</code> 和 <code>remoed</code> 字段，过程和导入类似。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>分别是 <code>h1</code>, <code>h2</code>, <code>content</code>（全文）, <code>url</code>（方便前端直接调，其实写在 express 也行，当时没考虑那么多）</p><p>由于全文之前是 markdown 文档，这里是用 <code>strip-markdown-math</code> 给 markdown 格式删一删（不过还剩了很多空行没删掉= =），由于 <code>strip-markdown</code> 不删掉数学公式（<code>remark-math</code> 是外部插件），所以我就封装（fork）了下。</p><p>相关代码：<a href="https://gist.github.com/Ir1d/eb1cc5d749be93238f3a4118156e5b5b" target="_blank" rel="noopener">https://gist.github.com/Ir1d/eb1cc5d749be93238f3a4118156e5b5b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;mkdocs 配置 Elasticsearch&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mkdocs" scheme="https://ir1d.cf/tags/mkdocs/"/>
    
      <category term="Elasticsearch" scheme="https://ir1d.cf/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Photoshop 脚本</title>
    <link href="https://ir1d.cf/2019/01/10/Photoshop-%E8%84%9A%E6%9C%AC/"/>
    <id>https://ir1d.cf/2019/01/10/Photoshop-脚本/</id>
    <published>2019-01-10T15:07:06.000Z</published>
    <updated>2019-01-10T15:12:21.849Z</updated>
    
    <content type="html"><![CDATA[<ul><li>11 月末写了个 ps 脚本来整理图片…… 一直没来得及记录</li></ul><a id="more"></a><p>需求是给每组图片对齐，拍的时候误差不是很大，对齐就用自动对齐就行。可惜图片数量太多，大概 4k 张，一组 5-7 张，手动来怕是要难受死。</p><p>用 ps 来操作的话，大概就是打开文件到图层，对齐，然后导出各图层至文件。开始的时候还试用现成的那个导入文件到堆栈，可惜和后面的操作接不上= = 不过那个导出图片的还是好用的 XD</p><p>对齐之后遇到了个问题，会对齐出来白边，然而我需要从这组图中找到一个尽量大的有色矩形。。。折腾了好久也没弄明白，最后搜到刚好前几天有人发布了一个解决方案。爽爆：<a href="https://developer71240.github.io/crop-to-opaque/" target="_blank" rel="noopener">https://developer71240.github.io/crop-to-opaque/</a></p><p>（不过人家禁止再分发，所以我的 gist 里面删掉了那部分，把人家的那段粘进 crop 函数就好啦）</p><p>Gist：<a href="https://gist.github.com/Ir1d/14af313f15d3fc91b23e70897daa2ca4" target="_blank" rel="noopener">https://gist.github.com/Ir1d/14af313f15d3fc91b23e70897daa2ca4</a></p><p>总体来说 Ps 的脚本体验及其糟糕…… 文档奇差，不过海星吧，印象中它是扩展了某种 jsx，然后直接去看那种 jsx 的 api 就星。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;11 月末写了个 ps 脚本来整理图片…… 一直没来得及记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Photoshop" scheme="https://ir1d.cf/tags/Photoshop/"/>
    
      <category term="jsx" scheme="https://ir1d.cf/tags/jsx/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 笔记</title>
    <link href="https://ir1d.cf/2018/12/09/LeetCode-%E7%AC%94%E8%AE%B0/"/>
    <id>https://ir1d.cf/2018/12/09/LeetCode-笔记/</id>
    <published>2018-12-09T06:00:55.000Z</published>
    <updated>2018-12-09T10:46:23.130Z</updated>
    
    <content type="html"><![CDATA[<ul><li>LeetCode 笔记</li></ul><p>工具用的是 leetcode-cli，可惜这货在网站上登录之后本地 cli 存的 session 就掉了，又得重新登录</p><a id="more"></a><ul><li>342</li></ul><p>判断一个数是不是 4 的幂次。我们知道 2 的幂次的话是：<code>x &amp;&amp; (x &amp; (x - 1)) == 0</code>，4 的话只需要额外看一下二进制表示里所有的 1 都在最高位就行。</p><ul><li>405</li></ul><p>十进制转十六进制，想到可以 sprintf 一波，最简单</p><ul><li>665</li></ul><p>最长上升子序列：lower_bound<br>最长不下降子序列：upper_bound</p><ul><li>594</li></ul><p>求一个最长的子序列，使得它的最大值和最小值的差恰好为 1。</p><p>注意是子序列，所以就找相邻的两个数的出现次数之和的最大值咯</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;LeetCode 笔记&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工具用的是 leetcode-cli，可惜这货在网站上登录之后本地 cli 存的 session 就掉了，又得重新登录&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="https://ir1d.cf/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>CF950F Treeland Tour</title>
    <link href="https://ir1d.cf/2018/12/07/CF950F-Treeland-Tour/"/>
    <id>https://ir1d.cf/2018/12/07/CF950F-Treeland-Tour/</id>
    <published>2018-12-07T11:53:03.000Z</published>
    <updated>2018-12-07T11:54:33.082Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一个点有权值的无根树，求一个链，使得这个链上的点权的 lis 长度最大</li></ul><a id="more"></a><p>说起来是我打的第一次 cf 吧……</p><p>很科学的做法：</p><p><a href="https://www.cnblogs.com/cxhscst2/p/7219887.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxhscst2/p/7219887.html</a></p><p>通过一次 dfs 把它转换成从子树向上合并答案的过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;一个点有权值的无根树，求一个链，使得这个链上的点权的 lis 长度最大&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2002</title>
    <link href="https://ir1d.cf/2018/12/07/POJ-2002/"/>
    <id>https://ir1d.cf/2018/12/07/POJ-2002/</id>
    <published>2018-12-07T10:15:40.000Z</published>
    <updated>2018-12-07T10:16:55.776Z</updated>
    
    <content type="html"><![CDATA[<ul><li>POJ 2002</li></ul><a id="more"></a><p>平面上一堆点，数能组成多少个正方形</p><p>枚举一条边（而不是枚举对角线</p><p>现在有了坐标怎么判断是否是正方形呢？</p><p>先看 4 边长相等，再看两个对角线相等。</p><p>数算这题写了好久。。好难过</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;POJ 2002&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="POJ" scheme="https://ir1d.cf/tags/POJ/"/>
    
  </entry>
  
  <entry>
    <title>g++ -Og 作用</title>
    <link href="https://ir1d.cf/2018/11/25/g-Og-%E4%BD%9C%E7%94%A8/"/>
    <id>https://ir1d.cf/2018/11/25/g-Og-作用/</id>
    <published>2018-11-25T14:46:45.000Z</published>
    <updated>2018-11-25T14:47:49.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>g++ -Og</code></li></ul><a id="more"></a><p>来自 <code>man g++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Options for Debugging Your Program</span><br><span class="line">       To tell GCC to emit extra information for use by a debugger, in almost</span><br><span class="line">       all cases you need only to add -g to your other options.</span><br><span class="line"></span><br><span class="line">       GCC allows you to use -g with -O.  The shortcuts taken by optimized</span><br><span class="line">       code may occasionally be surprising: some variables you declared may</span><br><span class="line">       not exist at all; flow of control may briefly move where you did not</span><br><span class="line">       expect it; some statements may not be executed because they compute</span><br><span class="line">       constant results or their values are already at hand; some statements</span><br><span class="line">       may execute in different places because they have been moved out of</span><br><span class="line">       loops.  Nevertheless it is possible to debug optimized output.  This</span><br><span class="line">       makes it reasonable to use the optimizer for programs that might have</span><br><span class="line">       bugs.</span><br><span class="line"></span><br><span class="line">       If you are not using some other optimization option, consider using -Og</span><br><span class="line">       with -g.  With no -O option at all, some compiler passes that collect</span><br><span class="line">       information useful for debugging do not run at all, so that -Og may</span><br><span class="line">       result in a better debugging experience.</span><br><span class="line">       -g  Produce debugging information in the operating system&apos;s native</span><br><span class="line">           format (stabs, COFF, XCOFF, or DWARF).  GDB can work with this</span><br><span class="line">           debugging information.</span><br><span class="line">           On most systems that use stabs format, -g enables use of extra</span><br><span class="line">           debugging information that only GDB can use; this extra information</span><br><span class="line">           makes debugging work better in GDB but probably makes other</span><br><span class="line">           debuggers crash or refuse to read the program.  If you want to</span><br><span class="line">           control for certain whether to generate the extra information, use</span><br><span class="line">           -gstabs+, -gstabs, -gxcoff+, -gxcoff, or -gvms (see below).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -Og&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="g++" scheme="https://ir1d.cf/tags/g/"/>
    
  </entry>
  
  <entry>
    <title>集合论…</title>
    <link href="https://ir1d.cf/2018/11/20/%E9%9B%86%E5%90%88%E8%AE%BA%E2%80%A6/"/>
    <id>https://ir1d.cf/2018/11/20/集合论…/</id>
    <published>2018-11-20T07:32:15.000Z</published>
    <updated>2018-11-20T07:35:42.217Z</updated>
    
    <content type="html"><![CDATA[<p>集图期中…… 范围是集合论</p><p>巧妙避开考点</p><p>时间比较紧，也没有整理多少出来，基本上直接在书上画了 = =</p><p>本文基本没有参考价值</p><p>嗯…… peano 系统…… F是单射！！</p><p>说起来还有件值得思考的事情，为什么可以在期中速成一门课的内容，而没有开学的时候就速成一波呢？</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/10709657/48658198-a6c98580-ea78-11e8-914a-659008b4ec9c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658199-af21c080-ea78-11e8-9d38-35ecd851235c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658228-1475b180-ea79-11e8-8246-5b91b5b2bd53.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658329-e2fde580-ea7a-11e8-93e6-f2e5ea2bbbb9.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48658337-0032b400-ea7b-11e8-99b0-d4983e1133f8.png" alt="image"></p><p>第二类 stirling 计算<br>哈斯图要求 y 覆盖 x 的时候才连边，覆盖的意思是x &lt; y但是中间不存在z</p><p>n元集，多少个偏序关系：1, 1, 3, 19, 219(n=0,1,2,3,4)</p><p>传递集那一套理论<br>康托定理</p><p><img src="https://user-images.githubusercontent.com/10709657/48716632-b7cdee80-ec52-11e8-85ea-5eedb18f1c3f.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48716875-4478ac80-ec53-11e8-9fd3-1651eef6e7eb.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48717187-d8e30f00-ec53-11e8-9381-273bf6d0e89d.png" alt="image"></p><p>对称闭包会破坏传递性</p><p><img src="https://user-images.githubusercontent.com/10709657/48718497-7b9c8d00-ec56-11e8-9269-400cc42e0dd0.png" alt="image"></p><p>自然映射: f:A→A/R, f(a)=[a]R, R为A上等价关系</p><p><a href="https://zhidao.baidu.com/question/49517936.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/49517936.html</a></p><p>NxN -&gt; N 的映射<br><img src="https://user-images.githubusercontent.com/10709657/48718938-4ba1b980-ec57-11e8-875c-37bbd0ecda82.png" alt="image"></p><p>Cantor编码</p><p><img src="https://user-images.githubusercontent.com/10709657/48722516-29ac3500-ec5f-11e8-98f8-7ff5694bb70a.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集图期中…… 范围是集合论&lt;/p&gt;
&lt;p&gt;巧妙避开考点&lt;/p&gt;
&lt;p&gt;时间比较紧，也没有整理多少出来，基本上直接在书上画了 = =&lt;/p&gt;
&lt;p&gt;本文基本没有参考价值&lt;/p&gt;
&lt;p&gt;嗯…… peano 系统…… F是单射！！&lt;/p&gt;
&lt;p&gt;说起来还有件值得思考的事情，为什么可以在期中速成一门课的内容，而没有开学的时候就速成一波呢？&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="集合论与图论" scheme="https://ir1d.cf/tags/%E9%9B%86%E5%90%88%E8%AE%BA%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ics期中整理</title>
    <link href="https://ir1d.cf/2018/11/14/ics%E6%9C%9F%E4%B8%AD%E6%95%B4%E7%90%86/"/>
    <id>https://ir1d.cf/2018/11/14/ics期中整理/</id>
    <published>2018-11-14T03:59:59.000Z</published>
    <updated>2018-11-17T06:51:05.229Z</updated>
    
    <content type="html"><![CDATA[<p>可以说是巧妙地避开了考点吧，觉得还是对大家有点帮助的（</p><p>范围是 csapp 的 2-6 章。</p><p>upd: hcl 背错了，身败名裂</p><a id="more"></a><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>0：<br><img src="https://user-images.githubusercontent.com/10709657/48384428-48716f80-e725-11e8-97f5-74e0ad470460.png" alt="image"></p><p>补码：最高有效位是 -2^{w-1}<br>反码：最高有效位是 -(2^{w-1}-1)<br>原码：最高有效位是符号位，决定其余位的正负</p><p>short -&gt; unsigned 先改变大小，再完成有符号数到无符号数 —&gt; (unsigned)sx == (unsigned)(int)sx</p><p>算术右移补最高位，逻辑右移补 0</p><p>检测无符号数加法的溢出 P62</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uok</span> <span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">unsigned</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum &gt;= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有符号数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = x + y;</span><br><span class="line">  <span class="keyword">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos_over = x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> !neg_over &amp;&amp; !pos_over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补码加法构成阿贝尔群，可交换可结合</p><p>减法溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意测试 TMIN</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    (y == INT_MIN) &amp;&amp; (res = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// if (y == INT_MIN) res = 0;</span></span><br><span class="line">    <span class="keyword">int</span> sub = x - y;</span><br><span class="line">    <span class="keyword">int</span> pos_over = x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sub &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; sub &gt; <span class="number">0</span>;</span><br><span class="line">    res = res &amp;&amp; !(pos_over || neg_over);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-x == ~x+1</code> 对任意整数值一样</p><p>无符号和补码乘法，虽然完整的乘积的位级表示可能会不同，但是截断后乘积的位级表示是相同的</p><p><img src="https://user-images.githubusercontent.com/10709657/48301101-01b42780-e523-11e8-9b78-706ef72b86c9.png" alt="image"></p><p>无论无符号还是补码、是否溢出，<code>(x &lt;&lt; 4) - (x &lt;&lt; 1)</code> 都和 <code>(x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1)</code>相等</p><p>补码除法 <code>x &gt;&gt; k</code> 产生 下取整 <code>x/2^k</code><br>正常除法应该对负数上取整</p><p><img src="https://user-images.githubusercontent.com/10709657/48301231-75efca80-e525-11e8-96fc-e0af015bfd48.png" alt="image"></p><p>符号、尾数、阶码<br>1 8 23 （float）<br>1 11 52 （double）<br><img src="https://user-images.githubusercontent.com/10709657/48303065-8fead680-e540-11e8-93bb-389679fccc29.png" alt="image"></p><p>规格化<br>(1+f)<em>2^{exp-127}<br>非规格化<br>f</em>2^(-126)<br>正无穷：s = 0, exp=1111111, f = 0;<br>负无穷：s = 1, exp=1111111, f = 0;</p><p>可表示数越靠近原点约稠密</p><p><strong>P80</strong><br>最小的非规格化数 exp = 0, f = 1;<br>最大的非规格化数 exp = 0, f = 1111;<br>最小的规格化数 exp = 1, f = 0;<br>最大的规格化数 exp = 1110, f = 111;<br>无穷大 0 exp = 1111, f = 0;</p><p><img src="https://user-images.githubusercontent.com/10709657/48303175-fb817380-e541-11e8-9eef-21abb4597fbe.png" alt="image"></p><p>P83 - 2.49<br>P84 - 2.52<br>P87 - 2.54</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>P118 ATT与 intel汇编代码格式<br>float 4 double 8<br>P121 操作数格式<br>传送指令的两个操作数不能都指向内存位置<br>movz 把目的中的剩余字节填充为0，movs则是符号扩展<br>任何为寄存器生成32位值的指令都会把该寄存器的高位部分设为0，比如 movl，而其他时候只会更新目的操作数指定的那些寄存器字节或内存位置。<br>cltq: 把 eax 符号扩展到 rax 编码更紧凑<br>movabsq 传送绝对的四字<br>指示地址寄存器必须是 r开头，不能 <code>movb $1, (%eax)</code><br>movsbl 符号扩展<br>movzbl 0扩展<br>char -&gt; int: movsbl<br>int -&gt; char: movb<br>栈向下增长，栈顶元素地址最低<br>leaq直接操作 x，而movq操作地址 x 处的值<br>移位量可以是一个立即数，或者放在单字节寄存器 <code>%cl</code>中:sarq算术移位（填符号位），shrq逻辑移位（填0）<br>对应的 salq<br>移位操作的目的操作数可以使寄存器/内存地址<br>cqto<br><img src="https://user-images.githubusercontent.com/10709657/48312488-4ce53d80-e5ea-11e8-928d-7a0db84f0cae.png" alt="image"><br>一个参数存在 rax，另一个作为操作数给出，然后乘积：高64位在rdx，低64位在rax。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int128 <span class="keyword">uint128_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upord</span><span class="params">(uint128 *dest, <span class="keyword">uint64_t</span> x, <span class="keyword">uint64_t</span> y)</span> </span>&#123;</span><br><span class="line">  *dest = x * (<span class="keyword">uint128_t</span>) y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cqto,把 rax的符号扩展到rdx的所有位</p><p><img src="https://user-images.githubusercontent.com/10709657/48312544-2e337680-e5eb-11e8-9af8-95b82f391d76.png" alt="image"><br>leaq 不改变条件吗，inc和deq会设置溢出和零标志，但不改变进位。移位操作的仅为标志设置为最后一个被移除的位，溢出标志设为 0</p><p><code>cmp s1, s2 ==&gt; s2 - s1</code><br><code>test s1, s2 ==&gt; s1 &amp; s2</code><br>这两个只设置条件吗，不改变任何其他寄存器</p><p><img src="https://user-images.githubusercontent.com/10709657/48312556-8e2a1d00-e5eb-11e8-98ea-3f819ef8aaf0.png" alt="image"></p><p>条件跳转只能是直接跳转</p><p>直接跳转？？间接？？</p><p>T_ran = T_ok + 0.5T_MP（MP是预测错误）</p><p>cmove 条件传送</p><p>continue 会跳到当前循环迭代的结尾</p><p><code>&amp;&amp;</code> 创建一个指向代码为止的指针</p><p>函数调用时，通过寄存器，过程可以传递最多6个整数值<br>P调用Q时，把返回地址当做是 P的栈帧的一部分，因为它存放的是与P相关的状态<br>char 1字节 8位 short 2字节 16位 int 4字节 32位<br>switch ……<br>long至少要和int一样大，书上似乎认为 long 是8<br>用 leaq 生成到某个位置的指针<br>%rbx, %rbp, %r12-%r15为被调用者保存寄存器，当P调用Q时，Q必须保存这些寄存器的值<br>其他寄存器除了 %rsp，都是调用者保存寄存器，意味着任何函数都能修改他们，P调用Q的时候Q可以随意修改这个寄存器<br>返回数组值：操作类型为int，涉及四字节操作;movl和%eax<br>返回指针：操作类型为<code>int*</code>，涉及八字节：leaq，%rax<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> r3[<span class="number">3</span>];</span><br><span class="line">r3 a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></p><p>二维数组<br>$&amp;d[i][j] = x_d + L(Ci+j)$</p><p>sal 算术右移（填符号位），shl 逻辑右移（填0）<br>数据对齐：要求k字节类型对象的地址必须是k的倍数</p><p>malloc 返回一个通用指针 <code>void*</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> *p)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>*); <span class="comment">// 函数指针。</span></span><br></pre></td></tr></table></figure></p><p>rsp不能放第二个位置<br><code>(xxx, %rsp) 不合法</code></p><p>指针的差结果是两个地址之差除以该数据类型的大小</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>程序员可见的状态：<br><img src="https://user-images.githubusercontent.com/10709657/48349544-76bc6400-e6bf-11e8-80b5-a475021c371d.png" alt="image"><br><code>pushq %rsp</code>放的是原值<br><code>popq %rsp</code>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addq $8, %rsp</span><br><span class="line">mrmovq 8(%rsp), %rsp</span><br><span class="line">//如果后加的话就把 rsp的值又改了</span><br></pre></td></tr></table></figure></p><p><code>pushq %rsp</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq REG, -8(%rsp)</span><br><span class="line">subq $8, %rsp</span><br><span class="line">// 先减的话就不能把正确的值塞到栈里</span><br></pre></td></tr></table></figure></p><p>向寄存器的写入受时钟信号控制<br>寄存器文件有内部存储</p><p>valP在取指阶段得到<br>执行阶段设置条件码。写回阶段最多可以写两个结果到寄存器文件</p><p>程序寄存器的新值取自：vapP,下一条指令的地址，valC，调用指令或跳转指令指定的目标地址，valM，从内存读取的返回地址<br>组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播<br>每个时钟周期，程序计数器都会装载新的指令地址。只有在执行整数运算指令时，才会装载条件码寄存器。只有在执行rmmovq，pushq，call时，才会写数据内存。<br>只有 popq 会用到寄存器文件的两个写端口，为了把值放到 %esp，M端口优先级高于E<br>alu的输出是valE的信号<br>从头到尾执行一条指令所需时间为延迟，吞吐量为倒数<br>流水线的延迟是最大的一部分的延迟加上流水线寄存器的延迟<br>SEQ的延迟是各阶段之和加上流水线寄存器的延迟<br>转发：5个源：e_valE,m_valM,M_valE,W_valM,W_valE；2个转发目的：valA, valB<br>由流水线中最深的指令引起的异常，优先级最高<br>访存/写回阶段的指令异常时，流水线控制逻辑禁止更新条件码寄存器或是数据内存<br>出现异常时，信息只是简单地存放在流水线寄存器的状态字段中，异常事件不会对流水线中的指令流有任何影响。在写回阶段，流水线控制逻辑发现出现了异常，并停止执行。<br>只有 call 和跳转指令需要 valp 而这些指令不需要valA<br><img src="https://user-images.githubusercontent.com/10709657/48357545-d4f34200-e6d3-11e8-8b72-86ff6be7dabc.png" alt="image"><br>处于最早流水线阶段中的转发源具有较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令<br>只有 <code>popq %rsp</code> 关心访存和写回的转发优先级，因为只有他同时写两个寄存器</p><p><img src="https://user-images.githubusercontent.com/10709657/48360102-7204a980-e6d9-11e8-9355-7a296ec49959.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/10709657/48360114-76c95d80-e6d9-11e8-865f-6c4b74fe4be6.png" alt="image"><br>CPI是流水线平均吞吐量的倒数，单位是时钟周期，不是微微秒</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>关键路径是在循环的反复执行过程中形成的数据相关链<br>CPE 镁元素的周期数<br>编译器回家社函数有副作用，程序员需要显示完成代码移动<br>减少过程调用<br>消除不必要的内存引用<br>延迟界限：下一条指令开始前，这条必须结束 — 数据相关<br>吞吐量界限：处理器功能单元的原始计算能力<br>循环寄存器之间的操作链决定了限制性能的数据相关<br>比较和分支操作不直接影响程序中的数据流<br>练习题5.6 n次乘法，n次加法，<code>i--</code>不在关键路径上<br>循环展开<br>使用多个累计变量 —- 多路并行<br>重新结合变换，增加了可以并行执行的操作数量<br>大多数编译器不会尝试的对浮点运算做重新结合，因为这些运算不保证是可结合的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 慢</span><br><span class="line">acc = (acc OP data[i]) OP data[i + 1];</span><br><span class="line">// 快</span><br><span class="line">acc = acc OP (data[i] OP data[i + 1]);</span><br></pre></td></tr></table></figure></p><p>练习题 5.8 最快的是 A3A4<br>寄存器溢出<br>分支预测和预测错误出发<br>不要过分关心可预测的分支<br>书写适合用条件传送实现的代码<br>消除连续的函数调用，将计算移到循环外<br>消除不必要的内存引用，引入临时变量来保存中间结果<br>低级优化，结构化代码以利用硬件功能</p><ul><li>展开循环</li><li>使用多个累计变量、重新结合，提高指令级并行</li><li>用功能性的风格重写条件操作，使得编译采用条件数据传送</li></ul><p><img src="https://user-images.githubusercontent.com/10709657/48364664-f5c39380-e6e3-11e8-9c27-ccbdb713bc6d.png" alt="image"></p><p>B不对是因为可能A和B指向的是同一块内存区域</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>寻道时间和旋转延迟 4ms，传送时间 <code>0.02ms（1/RPM/（每磁道平均扇区数）*60）</code><br>读SSD比写要快，随机读写的性能差别由底层闪存基本属性决定<br>数据以页为单位读写，只有在一页所属的块整个被擦除之后，才能写这一页。一个快在 100000 次重复写之后会磨损坏。<br>SRAM比DRAM快，DRAM比磁盘快，SRAM比DRAM贵，DRAM比磁盘贵，SSD位于DRAM和磁盘之间<br>循环有很好地时间（循环体会被执行多次）和空间局部性<br>数组有空间局部性<br>数据以块为大小在第k层和k+1层之间来回复制的<br>随机替换策略、LRU策略（最近最少被使用）</p><p><img src="https://user-images.githubusercontent.com/10709657/48365499-0d9c1700-e6e6-11e8-94db-70a19bb24200.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48365524-2278aa80-e6e6-11e8-9c78-c10c5ea590bb.png" alt="image"><br>E=1 — 直接映射高速缓存</p><h2 id="补"><a href="#补" class="headerlink" title="补"></a>补</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp *%rax #目标为寄存器中的值</span><br><span class="line">jmp *(%rax) #以寄存器中的值作为读地址，从内存中读出跳转目标</span><br></pre></td></tr></table></figure><p>CISC指令数量较多，有些指令的执行周期很长 ，<br>编码是可变长度的，支持复杂的寻址方式，栈密<br>集的过程链接，代码长度一般较短，取址部件更复杂。<br>RISC指令较少，没有执行周期很长的指令，编码固定长度，<br>只有简单的寻址方式，寄存器密集的过程链接，代码长度<br>较长，没有条件码<br><img src="https://user-images.githubusercontent.com/10709657/48426375-9d52cb80-e7a1-11e8-8fd3-79bd33c97822.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以说是巧妙地避开了考点吧，觉得还是对大家有点帮助的（&lt;/p&gt;
&lt;p&gt;范围是 csapp 的 2-6 章。&lt;/p&gt;
&lt;p&gt;upd: hcl 背错了，身败名裂&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ics" scheme="https://ir1d.cf/tags/ics/"/>
    
      <category term="csapp" scheme="https://ir1d.cf/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>数算期中整理</title>
    <link href="https://ir1d.cf/2018/11/14/%E6%95%B0%E7%AE%97%E6%9C%9F%E4%B8%AD%E6%95%B4%E7%90%86/"/>
    <id>https://ir1d.cf/2018/11/14/数算期中整理/</id>
    <published>2018-11-14T03:56:17.000Z</published>
    <updated>2018-11-14T03:59:44.305Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一些 ppt 上和复习过程中觉得自己不够扎实的</p><p>其实压中了几个题，可惜还是疏忽了…… 算法填空竟然 CE 了。</p><p>没看到那个栈中元素是指针。。</p><a id="more"></a><ol><li>判断序列是否是出栈序列</li><li>中缀表达式转后缀表达式</li><li>栈 队列 互相模拟</li></ol><p>编辑距离<br>kmp<br>N个节点的树有多少种<br>试证明，在具有n(n&gt;=1)个结点的k叉树中，有n(k-1)+1个指针是空的。<br>出栈序列计数 卡特兰数<br>通配符匹配<br>N0 = N2+1<br>堆是一颗完全二叉树节点的层次序列<br>带权并查集 扩展 kmp kmp 的应用 kmp 自动机<br>堆  P120<br>已知二叉树的先序序列和中序序列，可以唯一确定一棵二叉树<br><img src="https://user-images.githubusercontent.com/10709657/47954102-44c14880-dfc1-11e8-9fd4-c2d38505a26b.png" alt="image"></p><p><a href="https://wenku.baidu.com/view/ec8f638dbb68a98271fefafe.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ec8f638dbb68a98271fefafe.html</a><br><a href="https://wenku.baidu.com/view/aa6845d30029bd64793e2c2e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/aa6845d30029bd64793e2c2e.html</a><br><img src="https://user-images.githubusercontent.com/10709657/47990818-73efcb00-e123-11e8-93ff-223859eb5e7b.png" alt="image"><br>要减一</p><p>k叉哈夫曼树 (n-1)%(k-1)==0 否则补虚拟节点<br>书上的 kmp 板子</p><p>非递归 dfs<br><img src="https://user-images.githubusercontent.com/10709657/47996962-41e76480-e135-11e8-91e2-9dd3be4ab7e3.png" alt="image"></p><p>两个队列模拟栈<br>队列、栈、堆与数据结构的存储结构无关<br> 在一个具有n个结点的有序单链表中插入一个新结点并仍保持其有序的时间复杂度为 O(N)<br>表达式求值，和栈顶运算符优先级相同的话也要弹出（比如减号会把加号弹出</p><p>BST 的删除 P118</p><p><img src="https://user-images.githubusercontent.com/10709657/48001194-cab8cd00-e142-11e8-8d8c-924bacd88c77.png" alt="image"></p><p>出栈序列计数：1/(n+1) *C(2n,n)种</p><p><img src="https://user-images.githubusercontent.com/10709657/48070074-02db1100-e212-11e8-9b46-e31857a91385.png" alt="image"><br><img src="https://user-images.githubusercontent.com/10709657/48005022-56cff200-e14d-11e8-84f4-a71fb711feec.png" alt="image"></p><p>堆向下调整的时候是把小的儿子换上来</p><p><img src="https://user-images.githubusercontent.com/10709657/48005677-fd68c280-e14e-11e8-88a8-c8c51f056b1a.png" alt="image"></p><p>队列模拟栈 每一时刻ab只有一个为空<br><img src="https://user-images.githubusercontent.com/10709657/48007203-1626a780-e152-11e8-91ef-f883cd5a0c15.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一些 ppt 上和复习过程中觉得自己不够扎实的&lt;/p&gt;
&lt;p&gt;其实压中了几个题，可惜还是疏忽了…… 算法填空竟然 CE 了。&lt;/p&gt;
&lt;p&gt;没看到那个栈中元素是指针。。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法课程" scheme="https://ir1d.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Comparative Study on Generative Adversarial Networks</title>
    <link href="https://ir1d.cf/2018/10/20/Comparative-Study-on-Generative-Adversarial-Networks/"/>
    <id>https://ir1d.cf/2018/10/20/Comparative-Study-on-Generative-Adversarial-Networks/</id>
    <published>2018-10-20T13:21:14.000Z</published>
    <updated>2018-10-20T15:26:03.673Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Comparative Study on Generative Adversarial Networks</li></ul><a id="more"></a><h2 id="Comparative-Study-on-Generative-Adversarial-Networks"><a href="#Comparative-Study-on-Generative-Adversarial-Networks" class="headerlink" title="Comparative Study on Generative Adversarial Networks"></a>Comparative Study on Generative Adversarial Networks</h2><p>这篇 comparative study 试图比较原版和各种不同修改版的 GAN 的异同之处。</p><p><img src="https://i.loli.net/2018/10/20/5bcb4887b26c3.png" alt=""><br><img src="https://i.loli.net/2018/10/20/5bcb4887963a5.png" alt=""></p><p>$D(x)$ 是 x 来自原始数据而不是 $p_g$ 的概率。D 要最大化 $logD(x)$，而 G 要最小化 $log(1-D(G(z)))$。但是这样做的话 G 的梯度不适合用来训练，就把 objective function 修改一下，变成让D最大化 $logD(G(z))$</p><p><img src="https://i.loli.net/2018/10/20/5bcb4887a4bc9.png" alt=""></p><h3 id="CGAN"><a href="#CGAN" class="headerlink" title="CGAN"></a>CGAN</h3><p><img src="https://i.loli.net/2018/10/20/5bcb4887eabd6.png" alt=""><br>Conditional Generative Adversarial Network，简称 CGAN，这里把噪声 z 和条件 y 同时送进 G。<br><img src="https://i.loli.net/2018/10/20/5bcb488794302.png" alt=""></p><h3 id="LAPGAN"><a href="#LAPGAN" class="headerlink" title="LAPGAN"></a>LAPGAN</h3><p>Laplacian Pyramid of Adversarial Networks，简称 LAPGAN，这里构建了一个拉普拉斯金字塔，金字塔的每一层是一个 CGAN</p><h3 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h3><p>Deep Convolutional Generative Adversarial Networks，主要特点是：去掉了全连接和 pooling 层，全部使用卷积层；在 G 和 D 中都使用了 BN；在 G 中，除了最后一层，每一层之后都跟了 ReLU，而在 D 中，每一层后面跟了 LeakyReLU。</p><p><img src="https://i.loli.net/2018/10/20/5bcb48889218d.png" alt=""></p><h3 id="Adversarial-Autoencoder"><a href="#Adversarial-Autoencoder" class="headerlink" title="Adversarial Autoencoder"></a>Adversarial Autoencoder</h3><p><img src="https://i.loli.net/2018/10/20/5bcb48887eb9e.png" alt=""></p><h3 id="GRAN"><a href="#GRAN" class="headerlink" title="GRAN"></a>GRAN</h3><h3 id="InfoGAN"><a href="#InfoGAN" class="headerlink" title="InfoGAN"></a>InfoGAN</h3><p><img src="https://i.loli.net/2018/10/20/5bcb48885d134.png" alt=""></p><p>Imformation maximizing GANs，InfoGAN 把输入的 noise vector 分成两部分，一个是看做噪声z，一个是当做 latent code（c），然后把 z 和 c 同时输入给 G。在判别器的输出部分也进行了调整，同时输出一个 $c’$。</p><p>Q 网络用于判别结果对应的类别（c），实现上和 D 的结构相同，最后接一个全连接层输出</p><h3 id="BiGAN"><a href="#BiGAN" class="headerlink" title="BiGAN"></a>BiGAN</h3><p><img src="https://i.loli.net/2018/10/20/5bcb488896667.png" alt=""><br>Bidirectional Generative Adversarial Networks。</p><p><img src="https://i.loli.net/2018/10/20/5bcb4888b3219.png" alt=""></p><p>它有个特点是可以保证得到全局最小值。</p><p>BiGAN 引入了一个 E 网络，把输入图转换成 latent vector，然后把图片和 vector 一起送给 D 进行分类。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Comparative Study on Generative Adversarial Networks&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 2.21 为什么 INT_MIN=-INT_MAX-1</title>
    <link href="https://ir1d.cf/2018/10/09/CSAPP-2-21-%E4%B8%BA%E4%BB%80%E4%B9%88-INT-MIN-INT-MAX-1/"/>
    <id>https://ir1d.cf/2018/10/09/CSAPP-2-21-为什么-INT-MIN-INT-MAX-1/</id>
    <published>2018-10-09T13:47:05.000Z</published>
    <updated>2018-10-09T13:58:05.069Z</updated>
    
    <content type="html"><![CDATA[<ul><li>来源于网络</li></ul><a id="more"></a><p><code>-2147483648</code> 会被当做是表达式，存给 int 的话实际表示的是 <code>2147483648</code>。</p><p>考虑整个过程：</p><p>最开始是 <code>2147483648</code>: <code>1 &lt;&lt; 31</code></p><p>然后取反加一，还是 <code>1 &lt;&lt; 31</code></p><p>如果把这个结果赋值给一个 int，就会当做是有符号数： <code>-2147483648</code></p><p>然而如果赋值给一个 auto，再看它的 sizeof，就发现和 int 不一样了 :thinking:</p><p>参考：<a href="https://blog.csdn.net/le119126/article/details/45072969" target="_blank" rel="noopener">https://blog.csdn.net/le119126/article/details/45072969</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;来源于网络&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode [594] Longest Harmonious Subsequence</title>
    <link href="https://ir1d.cf/2018/10/09/LeetCode-594-Longest-Harmonious-Subsequence/"/>
    <id>https://ir1d.cf/2018/10/09/LeetCode-594-Longest-Harmonious-Subsequence/</id>
    <published>2018-10-08T17:06:41.000Z</published>
    <updated>2018-12-09T06:05:42.562Z</updated>
    
    <content type="html"><![CDATA[<ul><li>求一个最长的子序列，使得它的最大值和最小值的差恰好为 1</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [594] Longest Harmonious Subsequence</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/longest-harmonious-subsequence/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Easy (41.66%)</span></span><br><span class="line"><span class="comment"> * Total Accepted:    26.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 64.5K</span></span><br><span class="line"><span class="comment"> * Testcase Example:  '[1,3,2,2,5,2,3,7]'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We define a harmonious array is an array where the difference between its</span></span><br><span class="line"><span class="comment"> * maximum value and its minimum value is exactly 1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Now, given an integer array, you need to find the length of its longest</span></span><br><span class="line"><span class="comment"> * harmonious subsequence among all its possible subsequences.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Input: [1,3,2,2,5,2,3,7]</span></span><br><span class="line"><span class="comment"> * Output: 5</span></span><br><span class="line"><span class="comment"> * Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> * The length of the input array will not exceed 20,000.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>犯了几个错误……</p><p>局部变量没有赋初值……</p><p>然后调用了太多次 map 的操作…… 感觉复杂度有点爆炸</p><p>事实上这件事情并不需要 map，用 unordered_map 就好了…… 然后这样的话就只需要顺序地扫一遍就可以啦= =</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;求一个最长的子序列，使得它的最大值和最小值的差恰好为 1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ir1d.cf/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://ir1d.cf/tags/LeetCode/"/>
    
      <category term="HashMap" scheme="https://ir1d.cf/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Image Blind Denoising With Generative Adversarial Network Based Noise Modeling</title>
    <link href="https://ir1d.cf/2018/10/06/Image-Blind-Denoising-With-Generative-Adversarial-Network-Based-Noise-Modeling/"/>
    <id>https://ir1d.cf/2018/10/06/Image-Blind-Denoising-With-Generative-Adversarial-Network-Based-Noise-Modeling/</id>
    <published>2018-10-06T15:49:49.000Z</published>
    <updated>2018-10-06T17:06:49.621Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Image Blind Denoising With Generative Adversarial Network Based Noise Modeling</li></ul><a id="more"></a><p>好久没学术了…… 这回轮到我 paperReading ，才好好整理一篇文章。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章中了 CVPR 2018 的 poster，处理的问题是 blind denoising，就是不知道噪声水平下的去噪。作者来自中山大学和 CVTE，看 title 真的好厉害，可惜一作二作窝都没有搜到什么信息，仰慕不得……</p><p>文章的方法是把 DCGAN 和 DnCNN 的框架给整合到一起了，整个流程是给一堆 noisy images 和一堆 clean images，不需要是 paired，然后先用 GAN 对噪声进行建模并得到大量噪声块。用生成的噪声块和 clean images 配对喂给 CNN 进行去噪。</p><h2 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h2><p><img src="https://i.loli.net/2018/10/07/5bb8eab515899.png" alt=""></p><p>第一步是进行 Noise Modeling，首先要提取噪声块。</p><p>噪声块提取得比较迷……<br>为了减弱原图背景的影响，提取 noise block 的时候要选取 weak background 的部分。<br>文中定义了一个 smooth patch，用噪声图像减去 smooth patch 的均值得到噪声块。<br>注：基于一个假设 —— 噪声分布的期望是 0<br><img src="https://i.loli.net/2018/10/07/5bb8eab4f2d38.png" alt=""><br>怎么找这种 patch 呢？$p_i$在原图上按照固定步长走，$q_j^i$ 是在 $p_i$ 上按照固定步长走。</p><p>作者表示，在高清大图中，有充分多的 eligible smooth patch，比如 sky、walls 可以用来提取。</p><p>第二步是送给 GAN 了，用 GAN 来解决 Noise Modeling 的任务。</p><p>GAN 的特点是提供 more diversity，而且 model implicitly 也可以效果更好。</p><p>文中使用的是 WGAN-GP。</p><p><img src="https://i.loli.net/2018/10/07/5bb8eab530209.png" alt=""></p><p>其他部分其实就是 DCGAN 的结构。</p><p>第三步是送给 CNN 了。这里使用的是 DnCNN 的结构，也是预测残差。</p><p><img src="https://i.loli.net/2018/10/07/5bb8eab528e89.png" alt=""></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>测试分为四部分：</p><ol><li>Gaussian blind denoising task</li><li>mixture noise</li><li>realistic noise</li><li>compare noise samples</li></ol><p>测试用的数据集是 BSD68，DND 和 NIGHT。CNN 使用的干净图片来自 CLEAN1 和 CLEAN2 集合，文中并没有详细说是哪来的。</p><h3 id="Gaussian"><a href="#Gaussian" class="headerlink" title="Gaussian"></a>Gaussian</h3><p>训练过程中不提供 noise info。</p><p>GCBD 和 DnCNN-B 结果差不多好，作者表示这说明 GAN 生成的结果已经足够优秀了。</p><h3 id="Mixture"><a href="#Mixture" class="headerlink" title="Mixture"></a>Mixture</h3><p>Mixture Noise = 10% uniform noise $[-s, s]$ + 20% Gaussian N(0, 1) + 70% Gaussian N(0, 0.01)</p><p>这时 DnCNN-B 效果没有那么好了，作者表示是因为这时没有了 paired dataset</p><h3 id="Realworld"><a href="#Realworld" class="headerlink" title="Realworld"></a>Realworld</h3><p><img src="https://i.loli.net/2018/10/07/5bb8eab50ab23.png" alt=""></p><h3 id="Noise-samples"><a href="#Noise-samples" class="headerlink" title="Noise samples"></a>Noise samples</h3><p><img src="https://i.loli.net/2018/10/07/5bb8eab5903ac.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后作者表示有一点 limitation，是这里处理的 noise 都假设了是 additive noise with zero mean。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/9b134f0e57f5" target="_blank" rel="noopener">https://www.jianshu.com/p/9b134f0e57f5</a><br><a href="https://mp.weixin.qq.com/s/Vb0sIXC7s0yMRfhZFeC-wg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Vb0sIXC7s0yMRfhZFeC-wg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Image Blind Denoising With Generative Adversarial Network Based Noise Modeling&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="paperReading" scheme="https://ir1d.cf/tags/paperReading/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft 1.13 挂机钓鱼脚本</title>
    <link href="https://ir1d.cf/2018/10/05/Minecraft-1-13-%E6%8C%82%E6%9C%BA%E9%92%93%E9%B1%BC%E8%84%9A%E6%9C%AC/"/>
    <id>https://ir1d.cf/2018/10/05/Minecraft-1-13-挂机钓鱼脚本/</id>
    <published>2018-10-05T08:17:27.000Z</published>
    <updated>2018-10-05T08:28:26.619Z</updated>
    
    <content type="html"><![CDATA[<p>Minecraft 1.13 挂机钓鱼</p><p>（Ubuntu</p><a id="more"></a><p>启动器是 HMCL：<a href="https://github.com/huanghongxun/HMCL/" target="_blank" rel="noopener">https://github.com/huanghongxun/HMCL/</a></p><p>本文记录的操作来自：<a href="https://www.reddit.com/r/Minecraft/comments/6fb6cp/using_an_afk_fish_farm_in_the_background_with/" target="_blank" rel="noopener">https://www.reddit.com/r/Minecraft/comments/6fb6cp/using_an_afk_fish_farm_in_the_background_with/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xwininfo -display :0</span><br><span class="line"><span class="comment"># 查看窗口的十六进制 id，然后改到下一个命令中去</span></span><br><span class="line">xdotool mousedown --window [MINECRAFT_WINDOW_ID] 3</span><br></pre></td></tr></table></figure><p>安装直接 <code>sudo apt install xdotool</code> 就好了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Minecraft 1.13 挂机钓鱼&lt;/p&gt;
&lt;p&gt;（Ubuntu&lt;/p&gt;
    
    </summary>
    
      <category term="操作" scheme="https://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Minecraft" scheme="https://ir1d.cf/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-cli</title>
    <link href="https://ir1d.cf/2018/10/02/leetcode-cli/"/>
    <id>https://ir1d.cf/2018/10/02/leetcode-cli/</id>
    <published>2018-10-02T06:54:39.000Z</published>
    <updated>2018-10-02T06:56:29.190Z</updated>
    
    <content type="html"><![CDATA[<ul><li>LeetCode-cli</li></ul><a id="more"></a><p>一直想写一个 cli 工具来简化提交到 OJ 的过程= =</p><p>鸽了多年的 TerminalOJ 终于可以瞑目了吧……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g leetcode-cli</span><br></pre></td></tr></table></figure><p><a href="https://skygragon.github.io/leetcode-cli/commands" target="_blank" rel="noopener">https://skygragon.github.io/leetcode-cli/commands</a></p><p>功能也蛮强大的说实话，要是能自带 alias 就好了 XD</p><p>我现在加上这两个，更方便一些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> Leetcode=<span class="string">'leetcode'</span></span><br><span class="line"><span class="built_in">alias</span> Another=<span class="string">'leetcode show -q eDL -t algorithms -gxe'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;LeetCode-cli&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="操作" scheme="https://ir1d.cf/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="leetcode" scheme="https://ir1d.cf/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数算MOOC 3.4 思考题</title>
    <link href="https://ir1d.cf/2018/10/01/%E6%95%B0%E7%AE%97MOOC-3-4-%E6%80%9D%E8%80%83%E9%A2%98/"/>
    <id>https://ir1d.cf/2018/10/01/数算MOOC-3-4-思考题/</id>
    <published>2018-10-01T01:52:07.000Z</published>
    <updated>2018-10-01T01:58:36.962Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>只用 front, rear 两个变量，长度为 n 的队列，最多能容纳多少个元素？</li></ul><p>最多容纳 n-1 个元素。一个最多元素个数为 n-1 的队列，它有 n 个状态，需要用 front 和 rear 的距离来表示这种状态，所以需要一个空位置。</p><ul><li>如果不愿意浪费队列的存储单元，还可以怎么办？</li></ul><p>可以把这个存储单元拿出来，单独开一个变量表示队列元素个数或者表示队列是否为空。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;只用 front, rear 两个变量，长度为 n 的队列，最多能容纳多少个元素？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最多容纳 n-1 个元素。一个最多元素个数为 n-1 的队列，它有 n 个状态，需要用 front 和 rear 
      
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数算" scheme="https://ir1d.cf/tags/%E6%95%B0%E7%AE%97/"/>
    
      <category term="MOOC" scheme="https://ir1d.cf/tags/MOOC/"/>
    
  </entry>
  
  <entry>
    <title>为什么 pop() 返回值是 void</title>
    <link href="https://ir1d.cf/2018/09/30/%E4%B8%BA%E4%BB%80%E4%B9%88-pop-%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF-void/"/>
    <id>https://ir1d.cf/2018/09/30/为什么-pop-返回值是-void/</id>
    <published>2018-09-30T15:54:31.000Z</published>
    <updated>2018-09-30T17:08:05.374Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ref: <a href="http://cpptruths.blogspot.com/2005/10/why-does-stdstackpop-returns-void.html" target="_blank" rel="noopener">http://cpptruths.blogspot.com/2005/10/why-does-stdstackpop-returns-void.html</a></li></ul><a id="more"></a><p>数算 MOOC 的思考题：STL 为什么把 pop 和 top 分开？</p><ol><li>pop 如果有返回值的话，显然不能返回一个引用。如果是值的话，就不是很高效了——它会产生至少一次多余的构造函数调用。</li><li>如果 <code>std::stack&lt;T&gt;</code> 是一个模板类， pop 返回的结果需要调用复制构造函数。如果这个构造函数内部足够复杂，甚至出发了异常，那么这里面的 pop 的返回值就是一个 rvalue…… 在过程中就丢失了…… 并没有办法找回</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;ref: &lt;a href=&quot;http://cpptruths.blogspot.com/2005/10/why-does-stdstackpop-returns-void.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cpptruths.blogspot.com/2005/10/why-does-stdstackpop-returns-void.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="https://ir1d.cf/tags/c/"/>
    
      <category term="pop" scheme="https://ir1d.cf/tags/pop/"/>
    
      <category term="void" scheme="https://ir1d.cf/tags/void/"/>
    
  </entry>
  
  <entry>
    <title>ics datalab 小结</title>
    <link href="https://ir1d.cf/2018/09/30/ics-datalab-%E5%B0%8F%E7%BB%93/"/>
    <id>https://ir1d.cf/2018/09/30/ics-datalab-小结/</id>
    <published>2018-09-30T04:37:27.000Z</published>
    <updated>2018-09-30T05:07:09.244Z</updated>
    
    <content type="html"><![CDATA[<ul><li>datalab</li></ul><a id="more"></a><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="http://aggregate.org/MAGIC/" target="_blank" rel="noopener">http://aggregate.org/MAGIC/</a></li><li><a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">https://graphics.stanford.edu/~seander/bithacks.html</a></li><li><a href="https://github.com/lmichalek/CodeSamples/blob/master/bit-manipulation/bits.c" target="_blank" rel="noopener">https://github.com/lmichalek/CodeSamples/blob/master/bit-manipulation/bits.c</a></li><li><a href="https://github.com/mrseaman/15213-datalab/blob/master/bits.c" target="_blank" rel="noopener">https://github.com/mrseaman/15213-datalab/blob/master/bits.c</a></li><li><a href="http://hackersdelight.org" target="_blank" rel="noopener">http://hackersdelight.org</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;datalab&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://ir1d.cf/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ics" scheme="https://ir1d.cf/tags/ics/"/>
    
      <category term="datalab" scheme="https://ir1d.cf/tags/datalab/"/>
    
  </entry>
  
</feed>
