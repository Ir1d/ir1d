{"meta":{"title":"Neverland","subtitle":"你是我不愿醒来的梦啊<br>真是柔情一场","description":null,"author":"Ir1d","url":"https://ir1d.cf"},"pages":[{"title":"About","date":"2017-11-09T13:19:14.000Z","updated":"2018-01-31T10:36:37.323Z","comments":true,"path":"about/index.html","permalink":"https://ir1d.cf/about/index.html","excerpt":"","text":"The only label to find is ‘I don’t like labels’. Best Wishes!"},{"title":"404","date":"2017-11-09T13:17:18.000Z","updated":"2017-11-09T13:17:33.395Z","comments":true,"path":"404/index.html","permalink":"https://ir1d.cf/404/index.html","excerpt":"","text":""},{"title":"Friends","date":"2017-11-09T13:19:14.000Z","updated":"2018-10-29T13:31:20.657Z","comments":true,"path":"friends/index.html","permalink":"https://ir1d.cf/friends/index.html","excerpt":"","text":"OI Wiki: https://oi-wiki.org wwyqianqian: https://wwyqianqian.github.io/ XZYQvQ: https://www.k-xzy.xyz/ Frank: https://www.4leaf.top abc1763613206: https://ihcr.top Yirannn: https://yirannn.com Alpha1022: https://alpha1022.gitee.io"},{"title":"Categories","date":"2017-11-09T13:15:33.000Z","updated":"2018-01-31T10:36:56.452Z","comments":true,"path":"categories/index.html","permalink":"https://ir1d.cf/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-06-22T15:06:32.000Z","updated":"2018-06-22T15:06:32.731Z","comments":true,"path":"categories/index-1.html","permalink":"https://ir1d.cf/categories/index-1.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-09T13:14:50.000Z","updated":"2018-01-31T10:37:33.062Z","comments":true,"path":"tags/index.html","permalink":"https://ir1d.cf/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-22T14:56:00.000Z","updated":"2018-06-22T14:56:00.881Z","comments":true,"path":"tags/index-1.html","permalink":"https://ir1d.cf/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"g++ -Og 作用","slug":"g-Og-作用","date":"2018-11-25T14:46:45.000Z","updated":"2018-11-25T14:47:49.786Z","comments":true,"path":"2018/11/25/g-Og-作用/","link":"","permalink":"https://ir1d.cf/2018/11/25/g-Og-作用/","excerpt":"g++ -Og","text":"g++ -Og 来自 man g++ 123456789101112131415161718192021222324252627Options for Debugging Your Program To tell GCC to emit extra information for use by a debugger, in almost all cases you need only to add -g to your other options. GCC allows you to use -g with -O. The shortcuts taken by optimized code may occasionally be surprising: some variables you declared may not exist at all; flow of control may briefly move where you did not expect it; some statements may not be executed because they compute constant results or their values are already at hand; some statements may execute in different places because they have been moved out of loops. Nevertheless it is possible to debug optimized output. This makes it reasonable to use the optimizer for programs that might have bugs. If you are not using some other optimization option, consider using -Og with -g. With no -O option at all, some compiler passes that collect information useful for debugging do not run at all, so that -Og may result in a better debugging experience. -g Produce debugging information in the operating system&apos;s native format (stabs, COFF, XCOFF, or DWARF). GDB can work with this debugging information. On most systems that use stabs format, -g enables use of extra debugging information that only GDB can use; this extra information makes debugging work better in GDB but probably makes other debuggers crash or refuse to read the program. If you want to control for certain whether to generate the extra information, use -gstabs+, -gstabs, -gxcoff+, -gxcoff, or -gvms (see below).","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"g++","slug":"g","permalink":"https://ir1d.cf/tags/g/"}]},{"title":"集合论…","slug":"集合论…","date":"2018-11-20T07:32:15.000Z","updated":"2018-11-20T07:35:42.217Z","comments":true,"path":"2018/11/20/集合论…/","link":"","permalink":"https://ir1d.cf/2018/11/20/集合论…/","excerpt":"集图期中…… 范围是集合论 巧妙避开考点 时间比较紧，也没有整理多少出来，基本上直接在书上画了 = = 本文基本没有参考价值 嗯…… peano 系统…… F是单射！！ 说起来还有件值得思考的事情，为什么可以在期中速成一门课的内容，而没有开学的时候就速成一波呢？","text":"集图期中…… 范围是集合论 巧妙避开考点 时间比较紧，也没有整理多少出来，基本上直接在书上画了 = = 本文基本没有参考价值 嗯…… peano 系统…… F是单射！！ 说起来还有件值得思考的事情，为什么可以在期中速成一门课的内容，而没有开学的时候就速成一波呢？ 第二类 stirling 计算哈斯图要求 y 覆盖 x 的时候才连边，覆盖的意思是x &lt; y但是中间不存在z n元集，多少个偏序关系：1, 1, 3, 19, 219(n=0,1,2,3,4) 传递集那一套理论康托定理 对称闭包会破坏传递性 自然映射: f:A→A/R, f(a)=[a]R, R为A上等价关系 https://zhidao.baidu.com/question/49517936.html NxN -&gt; N 的映射 Cantor编码","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"集合论与图论","slug":"集合论与图论","permalink":"https://ir1d.cf/tags/集合论与图论/"}]},{"title":"ics期中整理","slug":"ics期中整理","date":"2018-11-14T03:59:59.000Z","updated":"2018-11-17T06:51:05.229Z","comments":true,"path":"2018/11/14/ics期中整理/","link":"","permalink":"https://ir1d.cf/2018/11/14/ics期中整理/","excerpt":"可以说是巧妙地避开了考点吧，觉得还是对大家有点帮助的（ 范围是 csapp 的 2-6 章。 upd: hcl 背错了，身败名裂","text":"可以说是巧妙地避开了考点吧，觉得还是对大家有点帮助的（ 范围是 csapp 的 2-6 章。 upd: hcl 背错了，身败名裂 第二章0： 补码：最高有效位是 -2^{w-1}反码：最高有效位是 -(2^{w-1}-1)原码：最高有效位是符号位，决定其余位的正负 short -&gt; unsigned 先改变大小，再完成有符号数到无符号数 —&gt; (unsigned)sx == (unsigned)(int)sx 算术右移补最高位，逻辑右移补 0 检测无符号数加法的溢出 P62 1234int uok (unsigned x, unsigned y) &#123; unsigned sum = x + y; return sum &gt;= x;&#125; 有符号数 123456int tok(int x, int y) &#123; int sum = x + y; int neg_over = x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; sum &gt;= 0; int pos_over = x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; sum &lt; 0; return !neg_over &amp;&amp; !pos_over;&#125; 补码加法构成阿贝尔群，可交换可结合 减法溢出 1234567891011// 注意测试 TMINint tsub(int x, int y) &#123; int res = 1; (y == INT_MIN) &amp;&amp; (res = 0); // if (y == INT_MIN) res = 0; int sub = x - y; int pos_over = x &gt; 0 &amp;&amp; y &lt; 0 &amp;&amp; sub &lt; 0; int neg_over = x &lt; 0 &amp;&amp; y &gt; 0 &amp;&amp; sub &gt; 0; res = res &amp;&amp; !(pos_over || neg_over); return res;&#125; -x == ~x+1 对任意整数值一样 无符号和补码乘法，虽然完整的乘积的位级表示可能会不同，但是截断后乘积的位级表示是相同的 无论无符号还是补码、是否溢出，(x &lt;&lt; 4) - (x &lt;&lt; 1) 都和 (x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1)相等 补码除法 x &gt;&gt; k 产生 下取整 x/2^k正常除法应该对负数上取整 符号、尾数、阶码1 8 23 （float）1 11 52 （double） 规格化(1+f)2^{exp-127}非规格化f2^(-126)正无穷：s = 0, exp=1111111, f = 0;负无穷：s = 1, exp=1111111, f = 0; 可表示数越靠近原点约稠密 P80最小的非规格化数 exp = 0, f = 1;最大的非规格化数 exp = 0, f = 1111;最小的规格化数 exp = 1, f = 0;最大的规格化数 exp = 1110, f = 111;无穷大 0 exp = 1111, f = 0; P83 - 2.49P84 - 2.52P87 - 2.54 第三章P118 ATT与 intel汇编代码格式float 4 double 8P121 操作数格式传送指令的两个操作数不能都指向内存位置movz 把目的中的剩余字节填充为0，movs则是符号扩展任何为寄存器生成32位值的指令都会把该寄存器的高位部分设为0，比如 movl，而其他时候只会更新目的操作数指定的那些寄存器字节或内存位置。cltq: 把 eax 符号扩展到 rax 编码更紧凑movabsq 传送绝对的四字指示地址寄存器必须是 r开头，不能 movb $1, (%eax)movsbl 符号扩展movzbl 0扩展char -&gt; int: movsblint -&gt; char: movb栈向下增长，栈顶元素地址最低leaq直接操作 x，而movq操作地址 x 处的值移位量可以是一个立即数，或者放在单字节寄存器 %cl中:sarq算术移位（填符号位），shrq逻辑移位（填0）对应的 salq移位操作的目的操作数可以使寄存器/内存地址cqto一个参数存在 rax，另一个作为操作数给出，然后乘积：高64位在rdx，低64位在rax。 12345#include &lt;inttypes.h&gt;typedef unsigned __int128 uint128_t;void upord(uint128 *dest, uint64_t x, uint64_t y) &#123; *dest = x * (uint128_t) y;&#125; cqto,把 rax的符号扩展到rdx的所有位 leaq 不改变条件吗，inc和deq会设置溢出和零标志，但不改变进位。移位操作的仅为标志设置为最后一个被移除的位，溢出标志设为 0 cmp s1, s2 ==&gt; s2 - s1test s1, s2 ==&gt; s1 &amp; s2这两个只设置条件吗，不改变任何其他寄存器 条件跳转只能是直接跳转 直接跳转？？间接？？ T_ran = T_ok + 0.5T_MP（MP是预测错误） cmove 条件传送 continue 会跳到当前循环迭代的结尾 &amp;&amp; 创建一个指向代码为止的指针 函数调用时，通过寄存器，过程可以传递最多6个整数值P调用Q时，把返回地址当做是 P的栈帧的一部分，因为它存放的是与P相关的状态char 1字节 8位 short 2字节 16位 int 4字节 32位switch ……long至少要和int一样大，书上似乎认为 long 是8用 leaq 生成到某个位置的指针%rbx, %rbp, %r12-%r15为被调用者保存寄存器，当P调用Q时，Q必须保存这些寄存器的值其他寄存器除了 %rsp，都是调用者保存寄存器，意味着任何函数都能修改他们，P调用Q的时候Q可以随意修改这个寄存器返回数组值：操作类型为int，涉及四字节操作;movl和%eax返回指针：操作类型为int*，涉及八字节：leaq，%rax12typedef int r3[3];r3 a[5]; 二维数组$&amp;d[i][j] = x_d + L(Ci+j)$ sal 算术右移（填符号位），shl 逻辑右移（填0）数据对齐：要求k字节类型对象的地址必须是k的倍数 malloc 返回一个通用指针 void*12int fun(int x, int *p);int (*fp)(int, int*); // 函数指针。 rsp不能放第二个位置(xxx, %rsp) 不合法 指针的差结果是两个地址之差除以该数据类型的大小 第四章程序员可见的状态：pushq %rsp放的是原值popq %rsp等价于123addq $8, %rspmrmovq 8(%rsp), %rsp//如果后加的话就把 rsp的值又改了 pushq %rsp123movq REG, -8(%rsp)subq $8, %rsp// 先减的话就不能把正确的值塞到栈里 向寄存器的写入受时钟信号控制寄存器文件有内部存储 valP在取指阶段得到执行阶段设置条件码。写回阶段最多可以写两个结果到寄存器文件 程序寄存器的新值取自：vapP,下一条指令的地址，valC，调用指令或跳转指令指定的目标地址，valM，从内存读取的返回地址组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播每个时钟周期，程序计数器都会装载新的指令地址。只有在执行整数运算指令时，才会装载条件码寄存器。只有在执行rmmovq，pushq，call时，才会写数据内存。只有 popq 会用到寄存器文件的两个写端口，为了把值放到 %esp，M端口优先级高于Ealu的输出是valE的信号从头到尾执行一条指令所需时间为延迟，吞吐量为倒数流水线的延迟是最大的一部分的延迟加上流水线寄存器的延迟SEQ的延迟是各阶段之和加上流水线寄存器的延迟转发：5个源：e_valE,m_valM,M_valE,W_valM,W_valE；2个转发目的：valA, valB由流水线中最深的指令引起的异常，优先级最高访存/写回阶段的指令异常时，流水线控制逻辑禁止更新条件码寄存器或是数据内存出现异常时，信息只是简单地存放在流水线寄存器的状态字段中，异常事件不会对流水线中的指令流有任何影响。在写回阶段，流水线控制逻辑发现出现了异常，并停止执行。只有 call 和跳转指令需要 valp 而这些指令不需要valA处于最早流水线阶段中的转发源具有较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令只有 popq %rsp 关心访存和写回的转发优先级，因为只有他同时写两个寄存器 CPI是流水线平均吞吐量的倒数，单位是时钟周期，不是微微秒 第五章关键路径是在循环的反复执行过程中形成的数据相关链CPE 镁元素的周期数编译器回家社函数有副作用，程序员需要显示完成代码移动减少过程调用消除不必要的内存引用延迟界限：下一条指令开始前，这条必须结束 — 数据相关吞吐量界限：处理器功能单元的原始计算能力循环寄存器之间的操作链决定了限制性能的数据相关比较和分支操作不直接影响程序中的数据流练习题5.6 n次乘法，n次加法，i--不在关键路径上循环展开使用多个累计变量 —- 多路并行重新结合变换，增加了可以并行执行的操作数量大多数编译器不会尝试的对浮点运算做重新结合，因为这些运算不保证是可结合的1234// 慢acc = (acc OP data[i]) OP data[i + 1];// 快acc = acc OP (data[i] OP data[i + 1]); 练习题 5.8 最快的是 A3A4寄存器溢出分支预测和预测错误出发不要过分关心可预测的分支书写适合用条件传送实现的代码消除连续的函数调用，将计算移到循环外消除不必要的内存引用，引入临时变量来保存中间结果低级优化，结构化代码以利用硬件功能 展开循环 使用多个累计变量、重新结合，提高指令级并行 用功能性的风格重写条件操作，使得编译采用条件数据传送 B不对是因为可能A和B指向的是同一块内存区域 第六章寻道时间和旋转延迟 4ms，传送时间 0.02ms（1/RPM/（每磁道平均扇区数）*60）读SSD比写要快，随机读写的性能差别由底层闪存基本属性决定数据以页为单位读写，只有在一页所属的块整个被擦除之后，才能写这一页。一个快在 100000 次重复写之后会磨损坏。SRAM比DRAM快，DRAM比磁盘快，SRAM比DRAM贵，DRAM比磁盘贵，SSD位于DRAM和磁盘之间循环有很好地时间（循环体会被执行多次）和空间局部性数组有空间局部性数据以块为大小在第k层和k+1层之间来回复制的随机替换策略、LRU策略（最近最少被使用） E=1 — 直接映射高速缓存 补12jmp *%rax #目标为寄存器中的值jmp *(%rax) #以寄存器中的值作为读地址，从内存中读出跳转目标 CISC指令数量较多，有些指令的执行周期很长 ，编码是可变长度的，支持复杂的寻址方式，栈密集的过程链接，代码长度一般较短，取址部件更复杂。RISC指令较少，没有执行周期很长的指令，编码固定长度，只有简单的寻址方式，寄存器密集的过程链接，代码长度较长，没有条件码","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"ics","slug":"ics","permalink":"https://ir1d.cf/tags/ics/"},{"name":"csapp","slug":"csapp","permalink":"https://ir1d.cf/tags/csapp/"}]},{"title":"数算期中整理","slug":"数算期中整理","date":"2018-11-14T03:56:17.000Z","updated":"2018-11-14T03:59:44.305Z","comments":true,"path":"2018/11/14/数算期中整理/","link":"","permalink":"https://ir1d.cf/2018/11/14/数算期中整理/","excerpt":"整理了一些 ppt 上和复习过程中觉得自己不够扎实的 其实压中了几个题，可惜还是疏忽了…… 算法填空竟然 CE 了。 没看到那个栈中元素是指针。。","text":"整理了一些 ppt 上和复习过程中觉得自己不够扎实的 其实压中了几个题，可惜还是疏忽了…… 算法填空竟然 CE 了。 没看到那个栈中元素是指针。。 判断序列是否是出栈序列 中缀表达式转后缀表达式 栈 队列 互相模拟 编辑距离kmpN个节点的树有多少种试证明，在具有n(n&gt;=1)个结点的k叉树中，有n(k-1)+1个指针是空的。出栈序列计数 卡特兰数通配符匹配N0 = N2+1堆是一颗完全二叉树节点的层次序列带权并查集 扩展 kmp kmp 的应用 kmp 自动机堆 P120已知二叉树的先序序列和中序序列，可以唯一确定一棵二叉树 https://wenku.baidu.com/view/ec8f638dbb68a98271fefafe.htmlhttps://wenku.baidu.com/view/aa6845d30029bd64793e2c2e.html要减一 k叉哈夫曼树 (n-1)%(k-1)==0 否则补虚拟节点书上的 kmp 板子 非递归 dfs 两个队列模拟栈队列、栈、堆与数据结构的存储结构无关 在一个具有n个结点的有序单链表中插入一个新结点并仍保持其有序的时间复杂度为 O(N)表达式求值，和栈顶运算符优先级相同的话也要弹出（比如减号会把加号弹出 BST 的删除 P118 出栈序列计数：1/(n+1) *C(2n,n)种 堆向下调整的时候是把小的儿子换上来 队列模拟栈 每一时刻ab只有一个为空","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"数据结构与算法课程","slug":"数据结构与算法课程","permalink":"https://ir1d.cf/tags/数据结构与算法课程/"}]},{"title":"Comparative Study on Generative Adversarial Networks","slug":"Comparative-Study-on-Generative-Adversarial-Networks","date":"2018-10-20T13:21:14.000Z","updated":"2018-10-20T15:26:03.673Z","comments":true,"path":"2018/10/20/Comparative-Study-on-Generative-Adversarial-Networks/","link":"","permalink":"https://ir1d.cf/2018/10/20/Comparative-Study-on-Generative-Adversarial-Networks/","excerpt":"Comparative Study on Generative Adversarial Networks","text":"Comparative Study on Generative Adversarial Networks Comparative Study on Generative Adversarial Networks这篇 comparative study 试图比较原版和各种不同修改版的 GAN 的异同之处。 $D(x)$ 是 x 来自原始数据而不是 $p_g$ 的概率。D 要最大化 $logD(x)$，而 G 要最小化 $log(1-D(G(z)))$。但是这样做的话 G 的梯度不适合用来训练，就把 objective function 修改一下，变成让D最大化 $logD(G(z))$ CGANConditional Generative Adversarial Network，简称 CGAN，这里把噪声 z 和条件 y 同时送进 G。 LAPGANLaplacian Pyramid of Adversarial Networks，简称 LAPGAN，这里构建了一个拉普拉斯金字塔，金字塔的每一层是一个 CGAN DCGANDeep Convolutional Generative Adversarial Networks，主要特点是：去掉了全连接和 pooling 层，全部使用卷积层；在 G 和 D 中都使用了 BN；在 G 中，除了最后一层，每一层之后都跟了 ReLU，而在 D 中，每一层后面跟了 LeakyReLU。 Adversarial Autoencoder GRANInfoGAN Imformation maximizing GANs，InfoGAN 把输入的 noise vector 分成两部分，一个是看做噪声z，一个是当做 latent code（c），然后把 z 和 c 同时输入给 G。在判别器的输出部分也进行了调整，同时输出一个 $c’$。 Q 网络用于判别结果对应的类别（c），实现上和 D 的结构相同，最后接一个全连接层输出 BiGANBidirectional Generative Adversarial Networks。 它有个特点是可以保证得到全局最小值。 BiGAN 引入了一个 E 网络，把输入图转换成 latent vector，然后把图片和 vector 一起送给 D 进行分类。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"CSAPP 2.21 为什么 INT_MIN=-INT_MAX-1","slug":"CSAPP-2-21-为什么-INT-MIN-INT-MAX-1","date":"2018-10-09T13:47:05.000Z","updated":"2018-10-09T13:58:05.069Z","comments":true,"path":"2018/10/09/CSAPP-2-21-为什么-INT-MIN-INT-MAX-1/","link":"","permalink":"https://ir1d.cf/2018/10/09/CSAPP-2-21-为什么-INT-MIN-INT-MAX-1/","excerpt":"来源于网络","text":"来源于网络 -2147483648 会被当做是表达式，存给 int 的话实际表示的是 2147483648。 考虑整个过程： 最开始是 2147483648: 1 &lt;&lt; 31 然后取反加一，还是 1 &lt;&lt; 31 如果把这个结果赋值给一个 int，就会当做是有符号数： -2147483648 然而如果赋值给一个 auto，再看它的 sizeof，就发现和 int 不一样了 :thinking: 参考：https://blog.csdn.net/le119126/article/details/45072969","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"LeetCode [594] Longest Harmonious Subsequence","slug":"LeetCode-594-Longest-Harmonious-Subsequence","date":"2018-10-08T17:06:41.000Z","updated":"2018-10-09T13:58:21.378Z","comments":true,"path":"2018/10/09/LeetCode-594-Longest-Harmonious-Subsequence/","link":"","permalink":"https://ir1d.cf/2018/10/09/LeetCode-594-Longest-Harmonious-Subsequence/","excerpt":"求一个最长的子序列，使得它的最大值和最小值的差恰好为 1","text":"求一个最长的子序列，使得它的最大值和最小值的差恰好为 1 12345678910111213141516171819202122232425262728293031/* * [594] Longest Harmonious Subsequence * * https://leetcode.com/problems/longest-harmonious-subsequence/description/ * * algorithms * Easy (41.66%) * Total Accepted: 26.9K * Total Submissions: 64.5K * Testcase Example: '[1,3,2,2,5,2,3,7]' * * We define a harmonious array is an array where the difference between its * maximum value and its minimum value is exactly 1. * * Now, given an integer array, you need to find the length of its longest * harmonious subsequence among all its possible subsequences. * * Example 1: * * Input: [1,3,2,2,5,2,3,7] * Output: 5 * Explanation: The longest harmonious subsequence is [3,2,2,2,3]. * * * * Note: * The length of the input array will not exceed 20,000. * * * */ 犯了几个错误…… 局部变量没有赋初值…… 然后调用了太多次 map 的操作…… 感觉复杂度有点爆炸 事实上这件事情并不需要 map，用 unordered_map 就好了…… 然后这样的话就只需要顺序地扫一遍就可以啦= =","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://ir1d.cf/tags/LeetCode/"},{"name":"HashMap","slug":"HashMap","permalink":"https://ir1d.cf/tags/HashMap/"}]},{"title":"Image Blind Denoising With Generative Adversarial Network Based Noise Modeling","slug":"Image-Blind-Denoising-With-Generative-Adversarial-Network-Based-Noise-Modeling","date":"2018-10-06T15:49:49.000Z","updated":"2018-10-06T17:06:49.621Z","comments":true,"path":"2018/10/06/Image-Blind-Denoising-With-Generative-Adversarial-Network-Based-Noise-Modeling/","link":"","permalink":"https://ir1d.cf/2018/10/06/Image-Blind-Denoising-With-Generative-Adversarial-Network-Based-Noise-Modeling/","excerpt":"Image Blind Denoising With Generative Adversarial Network Based Noise Modeling","text":"Image Blind Denoising With Generative Adversarial Network Based Noise Modeling 好久没学术了…… 这回轮到我 paperReading ，才好好整理一篇文章。 简介这篇文章中了 CVPR 2018 的 poster，处理的问题是 blind denoising，就是不知道噪声水平下的去噪。作者来自中山大学和 CVTE，看 title 真的好厉害，可惜一作二作窝都没有搜到什么信息，仰慕不得…… 文章的方法是把 DCGAN 和 DnCNN 的框架给整合到一起了，整个流程是给一堆 noisy images 和一堆 clean images，不需要是 paired，然后先用 GAN 对噪声进行建模并得到大量噪声块。用生成的噪声块和 clean images 配对喂给 CNN 进行去噪。 模型介绍 第一步是进行 Noise Modeling，首先要提取噪声块。 噪声块提取得比较迷……为了减弱原图背景的影响，提取 noise block 的时候要选取 weak background 的部分。文中定义了一个 smooth patch，用噪声图像减去 smooth patch 的均值得到噪声块。注：基于一个假设 —— 噪声分布的期望是 0怎么找这种 patch 呢？$p_i$在原图上按照固定步长走，$q_j^i$ 是在 $p_i$ 上按照固定步长走。 作者表示，在高清大图中，有充分多的 eligible smooth patch，比如 sky、walls 可以用来提取。 第二步是送给 GAN 了，用 GAN 来解决 Noise Modeling 的任务。 GAN 的特点是提供 more diversity，而且 model implicitly 也可以效果更好。 文中使用的是 WGAN-GP。 其他部分其实就是 DCGAN 的结构。 第三步是送给 CNN 了。这里使用的是 DnCNN 的结构，也是预测残差。 实验结果测试分为四部分： Gaussian blind denoising task mixture noise realistic noise compare noise samples 测试用的数据集是 BSD68，DND 和 NIGHT。CNN 使用的干净图片来自 CLEAN1 和 CLEAN2 集合，文中并没有详细说是哪来的。 Gaussian训练过程中不提供 noise info。 GCBD 和 DnCNN-B 结果差不多好，作者表示这说明 GAN 生成的结果已经足够优秀了。 MixtureMixture Noise = 10% uniform noise $[-s, s]$ + 20% Gaussian N(0, 1) + 70% Gaussian N(0, 0.01) 这时 DnCNN-B 效果没有那么好了，作者表示是因为这时没有了 paired dataset Realworld Noise samples 总结最后作者表示有一点 limitation，是这里处理的 noise 都假设了是 additive noise with zero mean。 参考https://www.jianshu.com/p/9b134f0e57f5https://mp.weixin.qq.com/s/Vb0sIXC7s0yMRfhZFeC-wg","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Minecraft 1.13 挂机钓鱼脚本","slug":"Minecraft-1-13-挂机钓鱼脚本","date":"2018-10-05T08:17:27.000Z","updated":"2018-10-05T08:28:26.619Z","comments":true,"path":"2018/10/05/Minecraft-1-13-挂机钓鱼脚本/","link":"","permalink":"https://ir1d.cf/2018/10/05/Minecraft-1-13-挂机钓鱼脚本/","excerpt":"Minecraft 1.13 挂机钓鱼 （Ubuntu","text":"Minecraft 1.13 挂机钓鱼 （Ubuntu 启动器是 HMCL：https://github.com/huanghongxun/HMCL/ 本文记录的操作来自：https://www.reddit.com/r/Minecraft/comments/6fb6cp/using_an_afk_fish_farm_in_the_background_with/ 123xwininfo -display :0# 查看窗口的十六进制 id，然后改到下一个命令中去xdotool mousedown --window [MINECRAFT_WINDOW_ID] 3 安装直接 sudo apt install xdotool 就好了","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://ir1d.cf/tags/Minecraft/"}]},{"title":"leetcode-cli","slug":"leetcode-cli","date":"2018-10-02T06:54:39.000Z","updated":"2018-10-02T06:56:29.190Z","comments":true,"path":"2018/10/02/leetcode-cli/","link":"","permalink":"https://ir1d.cf/2018/10/02/leetcode-cli/","excerpt":"LeetCode-cli","text":"LeetCode-cli 一直想写一个 cli 工具来简化提交到 OJ 的过程= = 鸽了多年的 TerminalOJ 终于可以瞑目了吧…… 1npm install -g leetcode-cli https://skygragon.github.io/leetcode-cli/commands 功能也蛮强大的说实话，要是能自带 alias 就好了 XD 我现在加上这两个，更方便一些 12alias Leetcode='leetcode'alias Another='leetcode show -q eDL -t algorithms -gxe'","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://ir1d.cf/tags/leetcode/"}]},{"title":"数算MOOC 3.4 思考题","slug":"数算MOOC-3-4-思考题","date":"2018-10-01T01:52:07.000Z","updated":"2018-10-01T01:58:36.962Z","comments":true,"path":"2018/10/01/数算MOOC-3-4-思考题/","link":"","permalink":"https://ir1d.cf/2018/10/01/数算MOOC-3-4-思考题/","excerpt":"","text":"只用 front, rear 两个变量，长度为 n 的队列，最多能容纳多少个元素？ 最多容纳 n-1 个元素。一个最多元素个数为 n-1 的队列，它有 n 个状态，需要用 front 和 rear 的距离来表示这种状态，所以需要一个空位置。 如果不愿意浪费队列的存储单元，还可以怎么办？ 可以把这个存储单元拿出来，单独开一个变量表示队列元素个数或者表示队列是否为空。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"MOOC","slug":"MOOC","permalink":"https://ir1d.cf/tags/MOOC/"},{"name":"数算","slug":"数算","permalink":"https://ir1d.cf/tags/数算/"}]},{"title":"为什么 pop() 返回值是 void","slug":"为什么-pop-返回值是-void","date":"2018-09-30T15:54:31.000Z","updated":"2018-09-30T17:08:05.374Z","comments":true,"path":"2018/09/30/为什么-pop-返回值是-void/","link":"","permalink":"https://ir1d.cf/2018/09/30/为什么-pop-返回值是-void/","excerpt":"ref: http://cpptruths.blogspot.com/2005/10/why-does-stdstackpop-returns-void.html","text":"ref: http://cpptruths.blogspot.com/2005/10/why-does-stdstackpop-returns-void.html 数算 MOOC 的思考题：STL 为什么把 pop 和 top 分开？ pop 如果有返回值的话，显然不能返回一个引用。如果是值的话，就不是很高效了——它会产生至少一次多余的构造函数调用。 如果 std::stack&lt;T&gt; 是一个模板类， pop 返回的结果需要调用复制构造函数。如果这个构造函数内部足够复杂，甚至出发了异常，那么这里面的 pop 的返回值就是一个 rvalue…… 在过程中就丢失了…… 并没有办法找回","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://ir1d.cf/tags/c/"},{"name":"pop","slug":"pop","permalink":"https://ir1d.cf/tags/pop/"},{"name":"void","slug":"void","permalink":"https://ir1d.cf/tags/void/"}]},{"title":"ics datalab 小结","slug":"ics-datalab-小结","date":"2018-09-30T04:37:27.000Z","updated":"2018-09-30T05:07:09.244Z","comments":true,"path":"2018/09/30/ics-datalab-小结/","link":"","permalink":"https://ir1d.cf/2018/09/30/ics-datalab-小结/","excerpt":"datalab","text":"datalab ref http://aggregate.org/MAGIC/ https://graphics.stanford.edu/~seander/bithacks.html https://github.com/lmichalek/CodeSamples/blob/master/bit-manipulation/bits.c https://github.com/mrseaman/15213-datalab/blob/master/bits.c http://hackersdelight.org","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"ics","slug":"ics","permalink":"https://ir1d.cf/tags/ics/"},{"name":"datalab","slug":"datalab","permalink":"https://ir1d.cf/tags/datalab/"}]},{"title":"给canvas截图并保存","slug":"给canvas截图并保存","date":"2018-09-30T04:13:45.000Z","updated":"2018-09-30T04:37:12.260Z","comments":true,"path":"2018/09/30/给canvas截图并保存/","link":"","permalink":"https://ir1d.cf/2018/09/30/给canvas截图并保存/","excerpt":"","text":"需求是把网页给截图并保存下来，搜了下有两个 js，一个是 html2canvas，另一个是 canvas2image。 刚开始用 canvas2image，遇到一堆问题，最后还是换了 html2canvas。 123456789101112131415var canvas = document.getElementsByTagName('canvas')[0]; html2canvas(document.body, &#123; width: 720, height: 480 &#125;).then(function (canvas) &#123; console.log(\"???\") var image = canvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\"); // here is the most important part because if you dont replace you will get a DOM 18 exception. var a = document.createElement('a'); a.href = image; a.download = '860_rain.png'; a.click(); &#125; );// Canvas2Image.saveAsPNG(canvasObj, 720, 480);&#125; 然而貌似打开图片之后是缩放了的…… 这个 720x480 其实是把原图裁了一部分…… 还没搞清楚怎么让它不缩放我的图片…… 貌似不能用 js 来 resize 一个 canvas，似乎只能在加载图片的时候就这么搞。 然后还顺便发现一个神奇的事情，如果不停地下载同一个文件名的文件…… 它至多能下 100 次。就是会有 download, download (1), 一直到 download (100)。然后就下不下来了……","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://ir1d.cf/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"https://ir1d.cf/tags/html2canvas/"}]},{"title":"DailyNotes 18/9/20","slug":"DailyNotes-18-9-20","date":"2018-09-20T15:45:20.000Z","updated":"2018-09-20T16:26:28.049Z","comments":true,"path":"2018/09/20/DailyNotes-18-9-20/","link":"","permalink":"https://ir1d.cf/2018/09/20/DailyNotes-18-9-20/","excerpt":"ics 小班课 XD","text":"ics 小班课 XD 余数的符号和被除数一样 负数右移和除法结果不一样 -1 &gt;&gt; 3 == -1 ssh-tunnel: https://cherrot.com/tech/2017/01/08/ssh-tunneling-practice.html 把一个数转换成二进制： 12std::bitset&lt;16&gt; y(-1);std::cout &lt;&lt; y; (x|-x) &gt;&gt; 31 除了在 0 那里，其他地方都是 -1 -2147483648 满足 x=-x nan 不满足 x=x","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"DailyNotes","slug":"DailyNotes","permalink":"https://ir1d.cf/tags/DailyNotes/"}]},{"title":"算导并查集笔记","slug":"算导并查集笔记","date":"2018-09-18T08:33:00.000Z","updated":"2018-09-18T13:41:44.846Z","comments":true,"path":"2018/09/18/算导并查集笔记/","link":"","permalink":"https://ir1d.cf/2018/09/18/算导并查集笔记/","excerpt":"算法导论并查集部分笔记 CLRS 上面称它为“用于不相交集合的数据结构”。（第 21 章）","text":"算法导论并查集部分笔记 CLRS 上面称它为“用于不相交集合的数据结构”。（第 21 章） 基本操作我们要找一个 disjoint-set data structure 维护一个不相交动态集的集合。每个集合有一个代表元。在很多应用中，我们不关心哪个成员被用来代表，只关心动态集合的代表不应当在动态集合没有修改的时候发生变化。 当然，这个代表元并非随便选取，可能有时会有某种规则（比如选取最小的元素） 我们希望支持以下三中操作： MAKE-SET(x)：建立一个新的集合。UNION(x, y)：合并包含 x 和 y 的两个动态集合。FIND-SET(x)：返回一个指针，指向包含 x 的集合的代表。 不难发现，这样的数据结构可以用来快速维护一个无向图的连通分量。 链表表示每个集合的对象包含 head 属性和 tail 属性， head 属性指向表的第一个对象， tail 属性指向最后一个对象。链表中的每个对象都包含一个集合成员。 在这种表示法中，UNION 操作的耗时最多，对于每个对象，我们必须更新指向集合对象的指针，这与所在链表长度呈线性关系。 事实上，一个 UNION 操作的摊还时间为 $\\Theta(n)$ 加权合并启发式策略：如果两个集合都有 $\\Omega(n)$ 个成员，则单个的 UNION 操作仍需要 $\\Omega(n)$ 时间。而一个具有 m 个操作（三种一共）的操作序列，使用启发式合并，需要的时间为 $O(m + nlogn)$。 由于每个 UNION 操作合并两个不相交集，因此至多执行 $n-1$ 次 UNION 操作。我们知道对于任意的 $k \\leq n$，在 x 的指针被更新 $\\lceil logk \\rceil$ 次之后，结果集合一定至少有 k 个成员。因为最大集合至多包含 n 个成员，故每个对象的指针在所有的 UNION 操作中最多被更新 $\\lceil logn \\rceil$ 次。因此在所有的 UNION 操作中被更新的对象的指针总数为 $O(nlogn)$。 不相交集合森林考虑更快的实现。我们用有根树来表示集合，树中每个结点包含一个成员，每棵树代表一个集合，在一个不相交集合森林中，每个成员仅指向父结点。每棵树的根包含集合的代表，且其为自己的父结点。在之前的实现中，一个包含 $n-1$ 个 UNION 操作的序列可以构造出一个恰好有 n 个结点的线性链的树。我们需要使用下面两个 trick 来得到一个渐进最优的不相交集合数据结构。这两种做法都是能改进运行时间的启发式策略。 按秩合并类似上面链表中的加权合并启发式策略，每次使具有较少结点的树的根指向具有较多节点的树的根。算导中表示并不需要显式地记录每个结点为根的子树的大小，而是采用一种“易于分析”的方法。对于每个结点，维护一个秩，它表示该结点高度的一个上界。在使用按秩合并的时候，我们让具有较小秩的根指向具有较大秩的根。 路径压缩在 FIND-SET 的时候，让查找路径的每个结点直接指向根。路径压缩并不改变任何结点的秩。 启发式策略对运行时间的影响如果单独使用按秩合并或者路径压缩，他们每一个都能改善不相交集合森林上操作的运行时间。单独按秩合并：$O(mlogn)$，且上界是紧的。单独路径压缩：$\\Omega(n+f \\times (1+log_{2+f/n}n))$然而只有一起使用的时候最坏情况运行时间为 $O(m\\alpha(n))$，这里 $\\alpha(n)$ 是阿克曼函数的反函数。 按秩合并+路径压缩的分析证明太硬核了…… 我要跳过它 思考题脱机最小值12345678OFF-LINE-MINIMUM(m, n) for i = 1 to n determine j such that i in K[j] if j != m + 1 extracted[j] = i let l be the smallest value greater than j for which set K[l] exists K[l] = K[j] ∪ K[l], destroying K[j] return extracted","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://ir1d.cf/tags/算法导论/"},{"name":"并查集","slug":"并查集","permalink":"https://ir1d.cf/tags/并查集/"}]},{"title":"DailyNotes 18/9/17","slug":"DailyNotes-18-9-17","date":"2018-09-17T15:21:57.000Z","updated":"2018-09-18T10:54:56.311Z","comments":true,"path":"2018/09/17/DailyNotes-18-9-17/","link":"","permalink":"https://ir1d.cf/2018/09/17/DailyNotes-18-9-17/","excerpt":"ics 数算实习","text":"ics 数算实习 今日体验了 ics…… 感觉看日程表即将炸裂 QAQ 数算实习讲了一节课并查集…… 惊了它竟然在算导上单独占一章 nan 平方 $\\geq 0$ ics 课上讨论是不是浮点数平方大于等于 0 一直成立…… 12double x = 1/0.;if (x * x &gt;= 0) printf(\"= =\"); 平均复杂度 &amp; 平摊 说一下我的理解前者是指输入满足某种概率分布，然后考虑输入的平均情况进行分析。后者应该是把总代价平均到一个周期内来承担。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"DailyNotes","slug":"DailyNotes","permalink":"https://ir1d.cf/tags/DailyNotes/"}]},{"title":"DailyNotes 18/9/15","slug":"DailyNotes-18-9-15","date":"2018-09-15T03:13:11.000Z","updated":"2018-09-15T16:12:39.936Z","comments":true,"path":"2018/09/15/DailyNotes-18-9-15/","link":"","permalink":"https://ir1d.cf/2018/09/15/DailyNotes-18-9-15/","excerpt":"","text":"Transpose Matrix把一个矩阵转置 掌握了二维数组 reserve 的姿势 1vector&lt;vector&lt;int&gt;&gt; res(A[0].size(), vector&lt;int&gt;(A.size())); 输入一个指针一定要各种判是不是空的，比如给你的 root = = 好像 cv2.resize 和 scipy.imresize 不一样啊？？看 EDSR 的 issue 区里面有人说有 artifact，然后作者说你是不是没用 bicubic。人家说我用的啊，最后发现把 cv2 的换成 scipy 就好了…… 好神奇哎 https://stackoverflow.com/questions/26823140/imresize-trying-to-understand-the-bicubic-interpolation/26823261#26823261","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Dailynotes 18/9/14","slug":"Dailynotes-18-9-14","date":"2018-09-14T12:14:29.000Z","updated":"2018-09-14T17:50:21.687Z","comments":true,"path":"2018/09/14/Dailynotes-18-9-14/","link":"","permalink":"https://ir1d.cf/2018/09/14/Dailynotes-18-9-14/","excerpt":"","text":"名词解释Zero-shot learning 指的是我们之前没有这个类别的训练样本。但是我们可以学习到一个映射X-&gt;Y。如果这个映射足够好的话，我们就可以处理没有看到的类了。 One-shot learning 指的是我们在训练样本很少，甚至只有一个的情况下，依旧能做预测。如何做到呢？可以在一个大数据集上学到general knowledge（具体的说，也可以是X-&gt;Y的映射），然后再到小数据上有技巧的update 颓废终日。。。 no gain this week….","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"DailyNotes 9.10","slug":"DailyNotes-9-10","date":"2018-09-10T14:22:48.000Z","updated":"2018-09-10T18:33:59.986Z","comments":true,"path":"2018/09/10/DailyNotes-9-10/","link":"","permalink":"https://ir1d.cf/2018/09/10/DailyNotes-9-10/","excerpt":"其实今天没有读什么文章，不过昨天配了 reddit 的订阅，感觉很厉害。 用上 hexoeditor 以及 hexo new 学会加引号之后，感觉操作上顺畅了很多。","text":"其实今天没有读什么文章，不过昨天配了 reddit 的订阅，感觉很厉害。 用上 hexoeditor 以及 hexo new 学会加引号之后，感觉操作上顺畅了很多。 Are result images in research papers on GANs and image attribution hand-picked or random很有趣的一个问题，文章中的效果图是随机的吗，还是精心挑选的？ 显然这是挑出来的吧（肯定要选效果最好的啊甚至还有这样的评论 In a presentation by Goodfellow he says that he copy pasted the original images as the gan quality wasnt very good. “我没有撒谎，我只是没有说出全部真相”感觉大家都是在挑对自己有利的事实来说话……","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"summer2018 总结","slug":"summer2018-总结","date":"2018-09-10T08:08:11.000Z","updated":"2018-09-10T16:19:30.248Z","comments":true,"path":"2018/09/10/summer2018-总结/","link":"","permalink":"https://ir1d.cf/2018/09/10/summer2018-总结/","excerpt":"summer2018","text":"summer2018 为什么今天来写呢…… 因为今天自作主张给自己放了一天假，整理一下XD 期末考之后自信满满，觉得肯定成绩特别好，然而后来发现完全翻车，比上学期还惨烈。对于这种事情我觉得还是完全是自己的原因，比如期中的时候就说期末一定要考这块内容，然后期末的时候忙着忙着就忘记了…… 然而期中的时候我这块没有错，期末的时候记混了然后就翻车了。期中的时候就有遇到细节上翻车，期末的时候又因为哪里少了什么什么结果扣了一堆分……完全是在造孽啊，你想大一干了这么多事情，有什么可以写进 cv 的？最后不还是 GPA 写了进去= = 运气好的是，刘老师收留了我，虽然感觉自己可能很快就被自己劝退了，但是感觉接触到这个崭新的世界也是一件蛮有意思的事情呢（啧，感觉自己最近很喜欢说“一件蛮有意思的事情呢”）。这个夏天主要在学一些很基础的事情，开始写周报，读了一些论文，python 水平有了很大提升，也认识到了一些局限，不过也认识到了很 nice 的新朋友们，也有了一些希望。万分感激！ 后来去搞 OI Wiki，也下了很大功夫，最大的决心来自于程设考试前立了个 flag，说考完试我肯定要把这些东西好好总结总结…… 然后考完试就忘记了…… 有天夜里突然想起来，到 ExOJ 群里问了下 “你们觉得怎样”，然后趁机拉了个群。开始的时候其实完全是自己在写，后来跟高中的几个小伙伴交流了一下，得到了一些支持，再后来松给了我一份资料Qrz…… 然后就很努力地在宣传，非常感谢各方朋友们的支持，遇到了一些志同道合的小伙伴，感觉还是很有希望的呢。关于 2016-2018，在 footer 里这么写，是因为用了一些 2016 年的和褚老板郑老板一起搞的那个项目里的东西啦～至于为什么想要做这个 wiki，那就说来话长暂且不表……这个暑假搞这个项目让我明白了很多人和很多事，感觉如果没有这段经历，可能不会有这么多思考吧 XD折腾的过程中也涨了很多姿势，虽然不知道以后能不能用得上，但是还是蛮有成就感的呢 开学之后瀚哥就不留在北京了，不知何时才能再相见…… 十分感激这段时间的帮助，感谢对我的种种 naive 的包容，这段经历对我改变很大，谢谢！woc hexo 竟然不需要空行就能分段…… 学到了 军训…… 太扎心了，暂且不表。三院的大夫也非常 nice，他不和你说治不好了，他说是终身疾病………… 下学期课一定要好好学习…… 别去搞什么乱七八糟的了。很久以前就看过“时间规划是王道”，然而还是把自己搞得一团糟。写个人陈述的时候找到了很有趣的一段话，“I will prioritize my interests”，感觉是这样…… 要好好的 昨天起八听说 shaonv 去了头条，我们都有光明的未来，嗯","categories":[],"tags":[]},{"title":"Github Bot 踩坑","slug":"Github-Bot-踩坑","date":"2018-09-10T07:22:01.000Z","updated":"2018-09-10T08:07:57.585Z","comments":true,"path":"2018/09/10/Github-Bot-踩坑/","link":"","permalink":"https://ir1d.cf/2018/09/10/Github-Bot-踩坑/","excerpt":"https://github.com/24OI/linter","text":"https://github.com/24OI/linter 主要在搞如何跑一个自动格式化 markdown 代码的 bot，尝试了 probot，直接 octokit，最后发现实在是还不如自己写个 .sh 来搞= = 是这样的，probot 的问题是 app 安装在主仓库里，权限限制在主仓库里，如果想要给 pr 里面 push 更新，就需要 fork 里面也安装了这个 app，然而这个体验实在是太糟糕了…… 至于 octokit，实际上 probot 调用的也是这个接口，就想要不直接用它？然而发现它的 api 是调用的 updateFile，一直报错。得知这东西会对每个修改的文件建一个 commit，感觉即使调出来了也是要爆炸= = 干脆直接上 .sh 来搞这个 lint 的过程好了，octokit 仅用来操作 webhook。 介绍一下一些坑吧…… 开始写这种总结发现搞到最后其实很难记得都遇到过哪些问题，真的佩服那些把教程写得清清楚楚的大佬们 nodejs 的 exec 如果运行一个 .sh 的话，它的环境变量是空的，source 或者指定 uid 好像都不好用，要手动声明一下才行。 抄 travis 的 log 学到了高超的 git 技巧，可惜后来没用上。 哦还有 probot 需要那个 installation_id，如果直接 redeliver payload 可能会爆出各种错。 slack 里面维护者回复很及时…… 真的厉害。后来还看到原来 probot 在 gsoc 里面…… QAQ","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://ir1d.cf/tags/Github/"},{"name":"probot","slug":"probot","permalink":"https://ir1d.cf/tags/probot/"},{"name":"Node.js","slug":"Node-js","permalink":"https://ir1d.cf/tags/Node-js/"}]},{"title":"mathjax-node-踩坑","slug":"mathjax-node-踩坑","date":"2018-09-05T02:47:34.000Z","updated":"2018-09-05T12:22:45.173Z","comments":true,"path":"2018/09/05/mathjax-node-踩坑/","link":"","permalink":"https://ir1d.cf/2018/09/05/mathjax-node-踩坑/","excerpt":"配置 mathjax-node","text":"配置 mathjax-node motivation 是发现 OI Wiki 上面有的页面现在就已经有大量公式了…… 本机就能渲染上 3-4s，感觉日后再堆公式进去可能吃不消。 然后就研究了下 mathjax-node，发现这玩意需要手动分析 DOM 把 mathjax 部分取出来喂给它…… 于是鸽了好久，直到有一天在 mathjax-node 的 README 最底下看到了个 mathjax-node-page，发现这个已经封装好了，直接把 html 丢给它就可以啦。 跑了下发现情况不妙…… preview 没有关掉，导致现在会双倍公式，试了下没啥好方法，于是用 regex 给搞掉了（写法参考 OI Wiki 的仓库） 然后就遇到了个问题：中文的字体用的 monospace，会重叠起来。开了个 issue 人家表示因为是 server-side 确定字的大小，你需要自己调这玩意= = https://github.com/mathjax/MathJax-node/issues/424 然后听说 monospace 在 win 上面有可能 fall-back 成宋体= = hmmmmm 我觉得其实还可以接受啊？ upd: 好像可以浏览器端自己设置，那就这样吧，不管了 upd: 啧，发现公式不能自己断行，手机上显示效果很不好（其实不是断行，原版的话公式比较长会溢出。。现在的会把公式缩小= = 以及发现 netlify 真的是个好东西…… 之前找了很久忘记在哪看到的，后来发现果然是 RSSHub 里面= = server-side render 本机跑很久然而放到 travis 和 netlify 上面好像还没超时（ hmmmmm 看了下 netlify 上跑一次需要 3min 我觉得海星？","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"mathjax-node","slug":"mathjax-node","permalink":"https://ir1d.cf/tags/mathjax-node/"}]},{"title":"Rain Streak Removal for Single Image via Kernel Guided CNN","slug":"Rain-Streak-Removal-for-Single-Image-via-Kernel-Guided-CNN","date":"2018-09-03T04:38:31.000Z","updated":"2018-09-03T14:53:34.627Z","comments":true,"path":"2018/09/03/Rain-Streak-Removal-for-Single-Image-via-Kernel-Guided-CNN/","link":"","permalink":"https://ir1d.cf/2018/09/03/Rain-Streak-Removal-for-Single-Image-via-Kernel-Guided-CNN/","excerpt":"Rain Streak Removal for Single Image via Kernel Guided CNN","text":"Rain Streak Removal for Single Image via Kernel Guided CNN Rain Streak Removal for Single Image via Kernel Guided CNNmotivation 是已有方法不能很好地处理 line-pattern texture 和 rain streak。 本文中作者表示既然雨线是因为 motion blur 和 scattering 产生的，不妨把雨线导致的降质看作是 motion blur。然后这里假设，对于一个小 image patch 来说，里面的雨线都是一个近似的 blur kernel。 作者表示很多方法都是在 high-level component 上进行去雨，然后他们就选了最好实现的 guided filter model 来当成 low-pass filter。这样就把一个 rainy patch 给 decompose 成了两个部分：texture component 和 detail component。 texture component 会包含所有的雨线、而且还更加 sparse，所以在 texture component 上面训练就足够 sufficient 且 compact。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"RESCAN 踩坑","slug":"RESCAN-踩坑","date":"2018-09-01T11:20:12.000Z","updated":"2018-09-12T14:24:47.264Z","comments":true,"path":"2018/09/01/RESCAN-踩坑/","link":"","permalink":"https://ir1d.cf/2018/09/01/RESCAN-踩坑/","excerpt":"Recurrent Squeeze-and-Excitation Context Aggregation Net for Single Image Deraining","text":"Recurrent Squeeze-and-Excitation Context Aggregation Net for Single Image Deraining 用 Rain 800 中的 700 张当训练集，100张当验证集，用 rain100H 中取出来的 100 张当测试集。 release 的 data 里面 test_syn 其实是 val，training 其实是 train，testset 就自己去从 rain100H 里找 100 张吧。（我也不知道，我随便说的 关于 DataLoader 就挂掉的问题： 12345try: batch_t = next(dt_train)except StopIteration: dt_train = sess.get_dataloader('train') batch_t = next(dt_train) 关于 conda 怎么也装不上 pytorch 0.4 上午怎么搞都只能装上 pytorch 0.12，可能是因为 cudnn 装不上更高版本吧…… 然而人家 pip 直接就上了 0.4 测试用 code 运行不起来 因为 dataloader 和 train 的时候的不一样…… 手写一下就吼了 对于这种 combine 到一起的图，掌握了 np.hsplit(a, 切分个数) 的新技能= = 以及还出现了多次把 ground truth 传进去测试的情况…… 不过发现一个很有意思的事情，ground truth 传进去之后输出也会丢失细节。 以及 B, O = np.hsplit(img_pair, 2) 被我写成了 O, B = np.hsplit(img_pair, 2) 测出来比它文章里高很多啊QAQ ，原来是这不同的代码测起来还可以结果不一样的。 test 的时候 batch_size 改成 1 刚开始直接用的训练的时候的 64， 发现不能对齐，就把数据都给转成一样大小的了 np.rot90 到底是不是无损的 np.narrow 是对闭区间操作的 [l, l + len] 莫名其妙测出来的 ssim 0.98 最后还是因为搞错了数据集 后来又测出来一次 0.98，仔细检查了很久过程上没有出问题…… 最后发现果然= =，大家都这么厉害了…… cv2.imwrite() 和 img.imsave() 的输出效果好像不太一样，混用导致了色偏 1// import matplotlib.image as img 我一起写到这里吧…… eigen13 的 code 测出来会有一圈边框…… 导致直接测的话 psnr 很低 = =，删掉边框会正常一些。 测 Rain100L 上面 psnr 现在大家做到快 40 了，真的可怕= = 话说昨天跑 DetailNet 发现它是一个一个图读进来的 hmmm 然后发现 DetailNet 只能测 RGB 的图，单通道的 model 喂不进去…… 然而 RESCAN 就可以的啧 DetailNet 训出来 Loss 很低，但是也有之前跑 SRGAN 的时候遇到的纯蓝色色块之类的现象= = 很迷，不知道为啥 cv2.imwrite() 和 matplotlib 里面的img.imsave() 不能混用 test 的时候 batch_size 要改成 1，因为两个代码都是把结果 concat 起来，可能原paper的数据集图片都是一样大的 不同的层要分开定义，否则实际上相当于 share weight 了 pytorch_total_params = sum(p.numel() for p in model.parameters())，这个会把model里定义的东西都算进去，求出来的不一定是实际上使用的 parameter 个数。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"},{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"}]},{"title":"Manipulating Attributes of Natural Scenes via Hallucination","slug":"Manipulating-Attributes-of-Natural-Scenes-via-Hallucination","date":"2018-09-01T01:43:21.000Z","updated":"2018-09-03T04:43:30.391Z","comments":true,"path":"2018/09/01/Manipulating-Attributes-of-Natural-Scenes-via-Hallucination/","link":"","permalink":"https://ir1d.cf/2018/09/01/Manipulating-Attributes-of-Natural-Scenes-via-Hallucination/","excerpt":"Manipulating Attributes of Natural Scenes via Hallucination Everybody Dance Now 用上 hexoeditor 之后放图真心方便了","text":"Manipulating Attributes of Natural Scenes via Hallucination Everybody Dance Now 用上 hexoeditor 之后放图真心方便了 Manipulating Attributes of Natural Scenes via Hallucination 本文提出的方法可以让人们直接操作自然场景中的 high-level 信息，从而转换场景。 Everybody Dance Now","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Gitment 配置","slug":"gitment-配置","date":"2018-08-22T07:04:07.000Z","updated":"2018-08-22T07:45:06.460Z","comments":true,"path":"2018/08/22/gitment-配置/","link":"","permalink":"https://ir1d.cf/2018/08/22/gitment-配置/","excerpt":"","text":"Gitment 原版的貌似没有在维护，后来改用了 Gitmint （加了统计和翻译），然而发现 gitment 的评论区是一个裸的 textarea，外面没有包上 form，然后 mkdocs-material 是判断不在 form 里来触发搜索功能的关键字的…… https://github.com/Ir1d/gitment/issues/20 （鸣谢褚老板发现这个坑） 然后为了修这个给 mkdocs-material 开 pr，人家表示正常的 textarea 都在 form 里面，你这种完全可以通过自定义 gitment 来搞定。 搜了下发现需要改 gitment 里面 render 的过程：https://github.com/24OI/OI-wiki/blob/master/static/disqus.html#L13-L26 12345678910111213141516171819202122232425262728293031323334const myTheme = &#123; render(state, instance) &#123; const container = document.createElement(&apos;div&apos;) container.lang = &quot;zh-CN&quot; container.className = &apos;gitment-container gitment-root-container&apos; const divv = document.createElement(&apos;form&apos;) // container.appendChild(instance.renderSomething(state, instan) container.appendChild(instance.renderHeader(state, instance)) divv.appendChild(instance.renderEditor(state, instance)) container.appendChild(divv) container.appendChild(instance.renderComments(state, instance)) container.appendChild(instance.renderFooter(state, instance)) return container &#125;, renderSomething(state, instance) &#123; const container = document.createElement(&apos;div&apos;) container.lang = &quot;zh-CN&quot; if (state.user.login) &#123; container.innerText = `Hello, $&#123;state.user.login&#125;, 来说点什么吧？` &#125; return container &#125;&#125;const gitment = new Gitment(&#123; id: &apos;&#123;&#123; page.title | default(&quot;404&quot;, true) &#125;&#125;&apos;, theme: myTheme, owner: &apos;Ir1d&apos;, repo: &apos;gitment&apos;, oauth: &#123; client_id: &apos;d6a911c8fba0194626d4&apos;, client_secret: &apos;867ec7e13cc99b420bd147cbb62d5cfec271ba81&apos;, &#125;,&#125;)gitment.render(&apos;gitment_container&apos;) 然后直接推上生产（昨晚 Travis CI 和 Github 的通讯 bug 了，CI 过了但是 Github 上还是 pending = =） 然后发现点预览的时候会刷新整个页面= =，然后之前评论框里还没有提交的东西就丢了= = 搜了下发现 form 里面的 button 需要加上个 type=&#39;button&#39; 才可以不跳转。 这个就必须要改 renderEditor 里面的东西了，索性把整个 gitment.js 都给换掉好了…… 在 gitment 的 issue 里搜了下，发现 https://www.kymjs.com 的这位大佬搞了个翻译好的，就稍微改下，拿过来用了。 修改在：https://github.com/24OI/24oi.github.io/blob/master/gitment.js#L3063 其他的修改都是细节上魔改，与整体配置无关（x 所以就让 mkdocs 用上 gitment 啦！ 完整配置在：https://github.com/24OI/OI-wiki/blob/master/static/disqus.html","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"gitment","slug":"gitment","permalink":"https://ir1d.cf/tags/gitment/"},{"name":"github","slug":"github","permalink":"https://ir1d.cf/tags/github/"}]},{"title":"Nginx HTTPS 配置","slug":"nginx-HTTPS-配置","date":"2018-08-22T06:50:44.000Z","updated":"2018-09-30T04:20:06.519Z","comments":true,"path":"2018/08/22/nginx-HTTPS-配置/","link":"","permalink":"https://ir1d.cf/2018/08/22/nginx-HTTPS-配置/","excerpt":"","text":"教程https://bjornjohansen.no/optimizing-https-nginx 这一套文都很厉害，包含了 nginx 以及 openssl 的安装、配置、优化。 以及真的佩服这位 dalao 给每篇文章都配上插图。 两个生成配置用的工具https://mozilla.github.io/server-side-tls/ssl-config-generator/ https://wiki.mozilla.org/Security/Server_Side_TLS 测试工具https://myssl.com/ https://www.ssllabs.com acme.shhttps://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert wiki 里面没有说多个域名怎么配，其实就是直接把单个域名的合到一起就好了。就比如我 1acme.sh --issue -d oi-wiki.org -d *.oi-wiki.org -d oi-wiki.cf -d *.oi-wiki.cf --dns dns_dp 这里 dns_dp 是指 dnspod，第一个 -d 后面的域名是会显示在证书上（比如说访问 https://oi-wiki.cf ，会显示证书是给 https://oi-wiki.org 的）。 用 dns 来验证真的方便，因为配了旧域名到新域名的跳转，nginx 验证总是不过。 改成 dns 之后就一波带走…… https://github.com/Neilpang/acme.sh/tree/master/dnsapi brotlihttps://www.howtoing.com/how-to-install-nginx-with-brotli-compression-on-ubuntu-1804","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ir1d.cf/tags/nginx/"},{"name":"https","slug":"https","permalink":"https://ir1d.cf/tags/https/"}]},{"title":"OI Wiki 征稿与招募启事","slug":"征稿与招募启事","date":"2018-08-11T16:49:17.000Z","updated":"2018-08-11T16:51:38.645Z","comments":true,"path":"2018/08/12/征稿与招募启事/","link":"","permalink":"https://ir1d.cf/2018/08/12/征稿与招募启事/","excerpt":"","text":"（本文得到了很多朋友的指点，十分感谢！） 文章于 11 日下午发于 知乎，以及 LOJ、 UOJ、 Judge Duck 的讨论区。 OI Wiki 征稿与招募启事咦？ OI Wiki 是个啥？其实是某大型游戏线上攻略啦，围观地址：Getting Started - OI Wiki 亲爱的 OIer 同学们： OI Wiki 致力于成为一个免费开放且持续更新的知识整合站点，大家可以在这里学习到关于 OI 竞赛有趣又实用的知识。我们为大家准备了 OI 竞赛中的基础知识、常见题型、解题思路以及常用工具等内容，帮助大家更快速深入地学习 OI 竞赛。 目前，OI Wiki 正在完善各大方向的基础知识，以便于初学者更好地学习。当然，OI Wiki 基于 OI，却不会局限于 OI。OI Wiki 也会努力完善以下内容： 应用在 ACM-ICPC 竞赛中的进阶知识 算法竞赛中的优质题目 与此同时， OI Wiki 源于社区，提倡知识自由，在未来也绝不会商业化，将始终保持独立自由的性质。 在过去的一个月中，OI Wiki 见证了 199 次更新，十余位热心同学参与了条目的编写与完善，项目也得到了很多朋友的大力支持。目前，我们已经完成了原计划中 28 % 的内容，工作仍然还处于初期阶段，在此诚挚向诸君征稿： 我们欢迎各种形式的 OI 相关的内容，不论是知识点、题目、赛制介绍，还是可能会使用到的工具软件，只要你觉得可以对别人有帮助，我们都热诚欢迎。 联系方式：Telegram 群组： @OIwiki ；QQ 群：588793226。欢迎各位加入～ F.A.Q.Q：你们是为什么想要做这个 Wiki 的呢？ A：不知道你在学 OI 的时候，面对庞大的知识体系，有没有感到过迷茫无助的时候？OI Wiki 想要做的事情可能类似于“让更多竞赛资源不充裕的同学能方便地接触到训练资源”。当然这么表述也不完全，做 Wiki 的动机可能也很纯粹，只是简单地想要对 OI 的发展做出一点点微小的贡献吧。XD Q：我很感兴趣，怎么参与呢？ A：OI Wiki 现在托管在 Github 上，你可以直接访问这个 repo 来查看最新进展。参与的途径包括在 Github 上面开 Issue、Pull Request，或者在交流群中分享你的想法、直接向管理员投稿。目前，我们使用的框架是 mkdocs，支持 Markdown 格式（当然也支持插入数学公式）。 Q：可是我比较弱…… 不知道我能做点什么？ A：一切源于热爱。你可以协助其他人审核修改稿件，帮助我们宣传 OI Wiki ，为社区营造良好学习交流氛围！ Q：现在主要是谁在做这件事啊？感觉这是个大坑，真的能做好吗？ A：现在主要是一些退役老年选手在做这件事，靠的都是信仰。这种“用爱发电”的事情，困难重重，我们也不知道能不能做好。但是如果这件事能够推动 OI 的发展，也是蛮有意义的呢。我们希望在这里打的这个广告，可以帮助这个团队遇见更多志同道合的人。 Q：听说过 nocow 吧，OI Wiki 怎么保证我们添加的内容不会像 nocow 那样突然间就不见了呢？ A：我们把内容托管在 Github 上面，即使我们的服务器翻车了，内容也不会丢失。另外，我们也会定期备份大家的心血，即使有一天 Github 倒闭了（？），我们的内容也不会丢失。 Q：OI Wiki 好像现在大部分内容都是空的啊？ A：是的，目前进度只完成了 28%，还远远称不上是一个合格的 Wiki。在过去的一个月里，主要添加的内容也比较基础。所以在这里进行征稿和招募，希望可以遇到有同样想法的朋友，我们一起把 OI Wiki 完善起来。 感谢你看到了最后，我们现在急需的，就是你的帮助。 OI Wiki Team 2018.8","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"OIWiki","slug":"OIWiki","permalink":"https://ir1d.cf/tags/OIWiki/"}]},{"title":"derain2018部分小结","slug":"derain2018部分小结","date":"2018-08-11T16:42:43.000Z","updated":"2018-08-11T17:03:24.954Z","comments":true,"path":"2018/08/12/derain2018部分小结/","link":"","permalink":"https://ir1d.cf/2018/08/12/derain2018部分小结/","excerpt":"直接粘过来好了，和大家分享一下 内容是 9 篇 single image deraining 的工作，是不完全整理。 paper list 参见：https://github.com/flyywh/Rain-Removal","text":"直接粘过来好了，和大家分享一下 内容是 9 篇 single image deraining 的工作，是不完全整理。 paper list 参见：https://github.com/flyywh/Rain-Removal xUnit Spatial Activation instead of perpixel activation —&gt; learn use fewer layers to match the performance (also fewer param) use less training example 一个位置的信息通过 ReLU 的时候要么乘上0 要么乘1。 考虑改成乘 $e^{-d_k^2}$ xUnit 的结构既有 nonlineariry(ReLU)，又有spatial processing (depth-wise convolution) 可视化结果发现很多 xnet activation和1（白色）接近，说明更多的channel 参与了 denoising 它把denoising 的 network 直接用来去雨，得到很不错的结果 DID-MDN 一个网络可能不能很好处理不同密集程度的雨线 文中把去雨过程分成两部分，先对雨线密集程度进行分类，然后再进行去雨 分类的过程是用和后面去雨那部分一样的网络结构，相当于是两个 branch，后一个branch另外加上了雨线密集程度的信息。 为什么不直接用 vgg fine-tune 呢？因为 vgg tend to pay more attention to localize the discriminative objects，雨线相对较小，难以在 high-level feature 中 很好地 localize. training detail classfier 的 训练是two stage，刚开始单独训练 resudual feature extraction network，来估计 residual part，然后再用 estimation 结果当做输入带训练 classification sub-network。最后再 joint optimize multi scale 是考虑雨线的大小不一样，用不同的 receptive field 来捕捉这方面信息。 表格信息（NLEDN 里面好像没有这篇里面自己效果这么好） Removing rain based on a cycle generative adversarial networkCycleGAN-based Industrial Electronics and Applications (ICIEA) 深研院的 Loss functions Cycle loss: strengthen the generator ability to distinguish between rain line and background Color loss: to solve the problem of color shift in deraining images. Texturue loss (transform into grayscale) Dark channel loss TV Loss : obtain a smooth result DualCNN DualCNN。将structure与details分别训练 loss 是 l2 loss detail + structure ignore detail_loss in derain Our goal is to learn the filtered image which does not contain rich details. —&gt; $\\gamma = 0$ 用在 derain 的时候，structure 部分是用的 clean image Residual-Guide Network 把 Basline block 简单串联起来效果并不好，需要利用中间信息来引导后面的 block 提取新的信息。 每一个大 block 里面是不断循环的（相当于是用同样的卷积层） （kernel reuse） 后面的每一个小块都加上最开头的那个小块（propagate all information forward from output of the first layer within each block） 最后面用 1x1 卷积 来 merge 所有的中间结果得到最终结果 ResGuideNet_5 是有 5 个 大block 且 没有进行 merge的 Semi-supervised CNN for Single Image Rain Removal the short-of-training-sample and bias-to-supervised-sample issues can be evidently alleviated use the network to formulate the residual between an input and its expected clear image (as a mixture of gaussian distribution) objective function is the combination of supervised data loss (least square loss) and unsupervised data loss optimized by least square residuals on supervised samples &amp; patch-wised MoG (P-MoG) loss on unsupervised ones 网络的输出是 negative residual (opposite of the rain layer) 非监督部分：最小化 negative 雨线分布的 log-likelihood NLEDN non-locally enhanced encoder-decoder network fully exploit hierarchical features &amp; capture the long-distance dependencies and structural information multi-scale non-local enhancement (原图分成8x8块) dense block 和 resguide 一样 Joint Bi-Layer Optimize locate rain-dominated regions &amp; estimate dominant direction extract rain patches from regions to model the rain pattern 保真项 三个 prior Sparsity prior: CSR: centralized sparse representation Rain direction prior: 假设不和雨线方向垂直的 gradients 不太可能是属于雨线 Rain layer prior：在B上 regularize 可能会 smooth out 一些 背景信息，这个项的作用是 用 weighted laplacian term 优化方法 先更新B 交替地更新 $\\alpha$ 和 B 后更新RSimulated+Unsupervised (S+U) learning uses unlabeled real data to refine the synthetic images refiner network l_real指的是refine之后的合成图片(x_i’)和真实图片Y之间的loss。l_reg是原始合成图片x_i和被refine之后的合成图片的x_i’之间的loss。lambda是一个高参 Refiner的目标就是尽可能的糊弄判别器D，让判别器没有办法区分一个图片是real还是合成的。判别器D的目标正好相反，是尽可能的能够区分出来 self-regularization loss 就是让refine之后的图片像素点和原始的图片的像素点之间的差不要太大 用refined的历史图片作为一个buffer而不单单是当前的mini-batch来更新分类器 在每一轮分类器的训练中，我们先从当前的batch中采样b/2张图片，然后从大小为B的buffer中采样b/2张图片，合在一起来更新判别器的参数。然后这一轮之后，用新生成的b/2张图片来替换掉B中的b/2张图片 instead of global discriminator, out discriminator classifies all local image patches separately. 好处是输入更小，感受野更小，而且会对每张原图得到更多让判别器学习的指标","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"GAN","slug":"GAN","permalink":"https://ir1d.cf/tags/GAN/"},{"name":"derain","slug":"derain","permalink":"https://ir1d.cf/tags/derain/"}]},{"title":"给mkdocs用上gitment","slug":"给mkdocs用上gitment","date":"2018-08-11T16:35:51.000Z","updated":"2018-08-11T16:47:15.492Z","comments":true,"path":"2018/08/12/给mkdocs用上gitment/","link":"","permalink":"https://ir1d.cf/2018/08/12/给mkdocs用上gitment/","excerpt":"","text":"我用的是 mkdocs-material 这个主题，作者代码、文档写得都很清楚，在 Github 上面也很活跃，反馈也很快。 换一套好用的评论系统，困难是 disqus 和 livere 访问速度都不太行，livere 更过分的是还要去调用一个 Google Analytics 的 js = = 决定试一下 gitment，发现用在 wiki 里面可以很好地避免标题过长，超过 issue 限制的问题（相对于个人博客乱写的标题而言）。 具体方法是改那个 disqus.html 然后部署的时候 https://github.com/24OI/OI-wiki/blob/master/build.sh#L21： 1cp ./static/disqus.html mkdocs-material/material/partials/integrations/disqus.html 改的时候不要忘记留着 https://github.com/24OI/OI-wiki/blob/master/static/disqus.html#L7： &lt;h2 id=&quot;__comments&quot;&gt; foo &lt;/h2&gt;，这个 id 是用来在右侧的目录里面加一个到 “评论区” 的跳转。 上面这顿操作实际上就是替换了 disqus 加载 js 的过程，由于偷懒，在设置（mkdocs.yml）里面还是要标记成正在使用 disqus。","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"gitment","slug":"gitment","permalink":"https://ir1d.cf/tags/gitment/"},{"name":"mkdocs","slug":"mkdocs","permalink":"https://ir1d.cf/tags/mkdocs/"}]},{"title":"pytorch小结","slug":"pytorch小结","date":"2018-08-03T11:52:26.000Z","updated":"2018-08-03T16:19:41.615Z","comments":true,"path":"2018/08/03/pytorch小结/","link":"","permalink":"https://ir1d.cf/2018/08/03/pytorch小结/","excerpt":"","text":"官方 tutorial 里面下下来的 cifar-10-python 大小是 341M。= = 请做好心理准备 backward 的时候是把 gradient 加上去，所以每次操作一个新的 mini-batch 的时候，都要手动先 .zero_grad() 另外好像现在不用每个东西后面跟一堆 .cuda()，好像直接 net.to(device) 就好了？唯一需要注意的就是输入输出也要在相同的 device 上面？","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"https://ir1d.cf/tags/pytorch/"}]},{"title":"conda重置environment状态","slug":"conda重置environment状态","date":"2018-08-02T08:56:27.000Z","updated":"2018-08-04T01:23:03.416Z","comments":true,"path":"2018/08/02/conda重置environment状态/","link":"","permalink":"https://ir1d.cf/2018/08/02/conda重置environment状态/","excerpt":"","text":"看到一个 comment 是说 conda 应该 base 留空，然后各种包开新的 environment 实验。 可是我已经装了一堆东西，又不想重装 conda = = 搜了下发现还是有这个 feature 的。 https://stackoverflow.com/questions/41914139/how-to-reset-anaconda-root-environment 12conda list --revisionsconda install --rev 0 0 就是要回退到哪个版本","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"},{"name":"conda","slug":"conda","permalink":"https://ir1d.cf/tags/conda/"}]},{"title":"pix2pix踩坑","slug":"pix2pix踩坑","date":"2018-07-31T16:30:25.000Z","updated":"2018-07-31T16:36:29.325Z","comments":true,"path":"2018/08/01/pix2pix踩坑/","link":"","permalink":"https://ir1d.cf/2018/08/01/pix2pix踩坑/","excerpt":"","text":"找了个 pytorch 实现的 pix2pix 踩了不少坑== 用的这个人的：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix 注意 doc 里面说可以怎么怎么样，然而代码里写的是 pix2pix 必须得用正方形的图= = 然后趁机掌握了 cv2 resize 的各种姿势= = 看 options 里面有很多选项，其实直接用 scripts 文件夹里现成的就好了 要注意的是训练和测试的方向= = 看好自己要 AtoB 还是 BtoA （以及有个 qa.md 和 tips.md）根本没有链接，藏在代码里头 12345# trainpython train.py --dataroot ./AB / --name rain --model pix2pix --which_direction AtoB --gpu_ids 0,1 --fineSize 480 --resize_or_crop crop# testpython test.py --dataroot ./AB --name deraindrop_pix2pix --model pix2pix --which_model_netG unet_256 --which_direction AtoB --dataset_mode aligned --norm batch --resize_or_crop none 上面好像并不对 还有个参数，是控制测试的时候用多少张的，默认是 50 = =，要手动改成自己的才行。 mark 一下尝试跑通了 attentive-GAN 1CUDA_VISIBLE_DEVICES=0 python test.py --mode demo --input_dir ./100/input/ --output_dir ./100/output/ hmmmm test.py 我自己重写了，大概就是把 demo 和 test 合到一起= =，既存结果又测 psnr。 要占用 7G+ 的显存= =","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"},{"name":"pix2pix","slug":"pix2pix","permalink":"https://ir1d.cf/tags/pix2pix/"}]},{"title":"python-opencv","slug":"python-opencv","date":"2018-07-30T02:36:08.000Z","updated":"2018-07-30T02:45:43.111Z","comments":true,"path":"2018/07/30/python-opencv/","link":"","permalink":"https://ir1d.cf/2018/07/30/python-opencv/","excerpt":"","text":"打开多张图片后内存不足的问题https://stackoverflow.com/questions/19414289/python-and-memory-consumption-when-opening-tiff-images 12import gcgc.collect() condaconda clean --all","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://ir1d.cf/tags/opencv/"},{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"}]},{"title":"ss在局域网共享","slug":"ss在局域网共享","date":"2018-07-30T00:48:19.000Z","updated":"2018-07-30T00:49:44.491Z","comments":true,"path":"2018/07/30/ss在局域网共享/","link":"","permalink":"https://ir1d.cf/2018/07/30/ss在局域网共享/","excerpt":"","text":"https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-local.asciidoc 看这里有一个 -b &lt;local_address&gt; 在 ss-local 的命令后面加上 -b 0.0.0.0 就好了= = 如果是用配置文件，写法是 https://github.com/shadowsocks/shadowsocks-libev/issues/1441#issuecomment-293134272","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://ir1d.cf/tags/shadowsocks/"}]},{"title":"为网页上选中部分设置高亮","slug":"为网页上选中部分设置高亮","date":"2018-07-28T16:07:34.000Z","updated":"2018-07-29T08:11:05.096Z","comments":true,"path":"2018/07/29/为网页上选中部分设置高亮/","link":"","permalink":"https://ir1d.cf/2018/07/29/为网页上选中部分设置高亮/","excerpt":"","text":"喜欢 vijos 可以在题面上做标注的那个功能好久了…… 今天决定动手写一下 搜了好久搜不出来什么方法，发现可以获取 selection 的 range 然后操作一下，懵逼。不知道如果选中的是两个标签内的咋整。 后来学习了一下 vijos 的 源码，发现可以用 HiliteColor 这个东西。搜了下，就发现了一些方法。 https://stackoverflow.com/questions/2756931/highlight-the-text-of-the-dom-range-element 至于怎么做悬浮工具栏还没有想好，目前用的 这个，自己的配色也很丑，功能和 vijos 比差远了= = 不过写出来了还是好赞啊 XD 遇到了一个问题，因为全局监听的是 mouseup，然后触发 popup-tag 的 click 就会冲突。 搜到应该用一个 event.stopPropagation(); 还有一个坑是发现莫名奇妙 click 的时候 selection 变成空的了。 第一个想法是 select 的时候就存下当前的 range，结果发现竟然每 select 一次都会存下来，然后 click 的时候会把所有存下来的 range 都触发= = 解决办法是把 popup-tag 的 click 换成了 mousedown 哎…… vijos 是真的厉害","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ir1d.cf/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://ir1d.cf/tags/前端/"}]},{"title":"运维小结","slug":"运维小结","date":"2018-07-28T15:51:16.000Z","updated":"2018-09-07T15:49:58.406Z","comments":true,"path":"2018/07/28/运维小结/","link":"","permalink":"https://ir1d.cf/2018/07/28/运维小结/","excerpt":"","text":"MongoDB莫名其妙挂掉= = 讲道理之前要么内存不够要么磁盘满了，这回都没事，结果 service mongod restart 就是没反应，而且 log 里面也没写，非常懵逼。 查看磁盘空间df -hl 看各个磁盘 du -sh [目录名] 返回该目录的大小 然后发现 pm2 的 log 占了 4G。原来是 mongod 挂掉期间执行了一次 schedule，然后不停循环= = 作死用 vim 打开，结果生成了 1G 的 .swp = = 在自动补全都不好使的情况下努力给删掉了 = = 发现还是跑不起来 查看 logsystemctl status mongod.service journalctl -xe 我开始的时候是 exit-code 100 找到 /var/lib/mongod 下的 mongod.lock 删掉就好了= = 之前看到一堆人说要删掉，结果自己没发现自己文件夹有这东西 后来变成 1 了，然后就好了。 MongoDB 数据备份http://www.runoob.com/mongodb/mongodb-mongodump-mongorestore.html 用 &gt;mongodump -h dbhost -d dbname -o dbdirectory MongoDB 相关log 位置 /var/log/mongod/mongod.log 删了 log 之后要 touch 一个，以及要改 log 的 chown 数据库位置 /var/lib/mongod/ 注意这里面要 chown 给 mongodb 这个用户 不要用 root 开 Judge Duck= = 掌握了 Django 技能，尝试了多种前端框架 论这活真难= = Google Analytics 服务端https://eason-yang.com/2016/11/04/google-analytics-via-nginx/ 这样搞就 ok 了，后端再跑 node 传的话感觉多一道手续= =","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://ir1d.cf/tags/运维/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://ir1d.cf/tags/MongoDB/"}]},{"title":"Daily Notes 7.17 - 18","slug":"dailynotes-8","date":"2018-07-17T01:01:42.000Z","updated":"2018-07-19T02:38:56.883Z","comments":true,"path":"2018/07/17/dailynotes-8/","link":"","permalink":"https://ir1d.cf/2018/07/17/dailynotes-8/","excerpt":"感觉周末好像不在状态啊，一直在浪，昨天换了设备之后迁移一晚上，然后又开始浪= = Improved Techniques for Learning to Dehaze and Beyond: A Collective Study","text":"感觉周末好像不在状态啊，一直在浪，昨天换了设备之后迁移一晚上，然后又开始浪= = Improved Techniques for Learning to Dehaze and Beyond: A Collective Study Improved Techniques for Learning to Dehaze and Beyond: A Collective Study仔细研究研究（ 本文介绍了在新提出的 RESIDE 数据集上面进行的两方面的工作，一个是尝试在单张图片上去雾（low-level），另一个是尝试在有雾的图片上进行 high-level 的视觉理解（比如 object detection）。对于第一个工作，文中尝试了多种 loss function，并得到结论是 perception-driven loss 可以显著地提升去雾性能。对于第二个工作，作者得到很多解决方案，包括在检测及去雾过程中使用更先进的模型，以及 Domain Adaptive 的 object detection 方法。 Introduction由于多种因素（air pollution, dust, mist, fume 等等），室外拍摄的照片往往是有复杂的、非线性的、和数据相关的噪声（统称为 haze），这对很多 high-level 的视觉任务（比如 object detection 和 recognition）产生一定的挑战。因此 dehazing 是一个研究很广泛的领域，早期的工作经常需要额外的关于场景 depth 的信息，或者是通过比对多张照片获得的信息。后来，很多方法提出对自然图片学习先验并做一些统计上的分析。近来，dehazing 算法应用了神经网络计数，效果很好。文中举了 AOD-Net 做例子，那篇工作中训练了一个 end-to-end 的去雾 + 检测（用的是 Faster R-CNN）的模型。 文中主要是两个任务，一是想要提升单张图片的去雾效果（作为 image-restoration 的问题），另一个是希望提升有雾情况下的 object detection 性能。（第一次看到有内容是加粗的……） 作者提倡对于提升物体检测性能给予更多的关注，因为是 final goal。和 low-resolution，noise，blur 不同的是，haze 对人的视觉影响不大（甚至有时还会获得额外的美学效果），但是 haze 在室外环境中不受约束，可以对影响视觉系统的功能。拿自动tian驾驶举例，hazy 和 foggy 的天气会对车载摄像头产生影响，比如造成 reflection 和 glare。 去雾方法I(x) = J(x)t(x) + A(1 - t(x))其中 $I(x)$ 是观察到的有雾的图， $J(x)$ 是需要恢复出来的干净背景。参数 $A$ 代表全局环境光，$t(x) = e^{-\\beta d(x)}$ 是 transmission 矩阵。$\\beta$ 是散射系数， $d(x)$ 代表物体和镜头的距离。传统的单张图去雾方法一般是学习自然图片的先验，比如 dark channel prior， color-attenuation prior，和 non-local color cluster prior，再对、做一些统计学上的分析来复原 transmission matrix t(x)。进来，CNN 被应用到去雾模型，比如 multiscale CNN (MSCNN)，DehazeNet，AODNet。 把去雾看做图像修复在这篇工作中，我们尝试找到和人类感知更 match 的 loss function 来训练去雾神经网络。我们用 AOD-Net （原网络用 MSE loss）来做骨架并用如下 loss function 替换： $l_1$ Loss: L^{l_1}(P) = \\frac{1}{N}\\sum_{p \\in P}|x(p) - y(p)|这里 N 是图像块 P 中的像素个数，p 是用来表示一个像素位置，x(p) 和 y(p) 用来分别表示生成的图像和 ground truth 图像的像素值 SSIM Loss: \\begin{aligned} SSIM(p) & = \\frac{2\\mu_x\\mu_y+C_1}{\\mu_x^2+\\mu_y^2+C_1} \\frac{2\\sigma_{xy}+C_2}{\\sigma_x^2+\\sigma_y^2+C_2} \\\\ & = l(p)cs(p) \\end{aligned}其中平均值和标准差是通过一个标准差是 $\\sigma_G$ 的高斯滤波器，这样就可以得到对于 SSIM 的 loss function 了。 L^{SSIM}(p) = \\frac{1}{N}\\sum_{p \\in P}1 - SSIM(p) MS-SSIM Loss:上面的式子中 $\\sigma_G$ 的选择会影响到 SSIM 的训练效果。在这篇工作中，我们选用了 multi-scale SSIM ，即提前选好 M 个不同的 $\\sigma_G$ 并进行融合： L^{MS-SSIM}(P) = l_M^{\\alpha}(p) \\prod_{j = 1}^Mcs_j^{\\beta_j}(p) MS-SSIM + $l_2$ Loss:使用一个把 MS-SSIM loss 和 $l_2$ loss 加权合并起来的结果： L^{MS-SSIM-l_2} = \\alpha \\cdot L^{MS-SSIM} + (1 - \\alpha) \\cdot G_{\\sigma_G^M} \\cdot L^{l_2}这里给 $l2$ loss 逐点地乘上一个 $G{\\sigma_G^M}$，作为 loss function 里面的 $l_2$ loss 部分。因为 MS-SSIM 反向传播在 q 这个像素点的错误的时候是基于它对于中心点 $\\tilde{q}$ 的 MS-SSIM 的贡献的，而这个贡献是由高斯权重来确定的。 MS-SSIM + $l_1$ Loss:使用一个把 MS-SSIM loss 和 $l_1$ loss 加权合并起来的结果： L^{MS-SSIM-l_1} = \\alpha \\cdot L^{MS-SSIM} + (1 - \\alpha) \\cdot G_{\\sigma_G^M} \\cdot L^{l_!}$l_1$ loss 也用相似的方法加权。 我们使用了 1000 张图片（室内室外都有）作为验证集，剩下的用于训练。最开始的学习率是 0.01，mini-batch 大小是 8，所有的权重用高斯随机变量初始化（除非特殊指定）。我们设定动量是 0.9，weight decay 是 0.0001。我们也进行 gradient clipping，阈值是 $\\pm 0.1$。所有的模型在 GTX 1070 上训练 14 个 epoch,经验上来看会收敛。对于 SSIM loss，$\\sigma_G$ 设置为 5，$C_1$ 和 $C_2$ 是 0.01 和 0.03。 实验表明单单是替换 loss function 就会得到显著的性能上变化。其中 $MS-SSIM-l_2$的效果最好。然后我们进一步对这个模型 fine-tune，（使用一个预先训练好的 AOD-Net 作为 warm initialization，并使用更小的学习率和更大的 mini-batch 大小）。 辅助目标检测的去雾使用 detection module 串联来增强去雾效果作者表示，看到之前 AOD-Net + Faster-RCNN 的效果不错，决定尝试使用不同模型串联：去雾模型选择 DCP，DehazeNet，AOD-Net，DCPDN；目标检测模型选择 Faster R-CNN，SSD，RetinaNet，Mast-RCNN。然后由于有雾的图像常常对比度较低，我们还使用了增强对比度的模型（CLAHE）。 实验结果表明，直接简单地把目标检测模型换成更复杂的模块并不能显著提升去雾检测的心梗，因为有雾/去雾后图片和干净的图片（典型检测模块在这上面训练的）是有 domain gap 的。更加复杂的检测模型可能会在干净图片这个 domain 上面 overfit 了，有一次证明了在解决真实世界检测问题时处理 domain shift 的重要性。此外，一个更好地去雾模型(从复原效果上来看）并没有在它预先处理过的图片上更好的检测效果（比如 DPDCN）。而且，添加去雾的与处理过程后并不总能保证得到更好的检测效果。我们发现实验中 AOD-Net 倾向于生成平滑但是对比度较低的结果，有可能对 detection 造成影响。这样考虑的话，我们设计两个三阶段的串联模型，发现用 DCP 处理 AOD-Net 的去雾结果之后可以得到更好地结果（而且对比度增强）。 Domain-Adaptive Mask-RCNN我们受 domain adaptive Faster-RCNN 的启发，设计了 Domain-Adaptive Mask-RCNN。 DMask-RCNN 的首要目标是对 feature extraction 网络生成的特征进行 mask 操作，使得它具有 domain invariant 的性质（干净的图片和有雾的图片两个 domain）。具体来说，它在 Mask-RCNN 的基础的特征提取卷积神经网络后放了一个 domain adaptive 结构，引入一个 domain classfier 的 cross entropy loss。 文中实验结论： Domain-Adaptive 的检测方法非常 promising，效果远好于之前的方法 使用合适的 domain adaptation 可以充分发挥 detection model 的能力。另外，在没有 joint tuning 的时候，MSNN 效果比 AOD-Net 好。 target domain 的选取对结果影响较大，应当选取 domain discrepancy 较小的。 实验结果表明 MSCNN + DMask-RCNN 的串联模型效果最好 Commenttypo 很多，竟然这样就可以发 arxiv = = upd: 竟然是 course project….","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"python对比两个图片的差异并记录","slug":"python对比两个图片的差异并记录","date":"2018-07-14T16:48:40.000Z","updated":"2018-07-30T00:49:37.215Z","comments":true,"path":"2018/07/15/python对比两个图片的差异并记录/","link":"","permalink":"https://ir1d.cf/2018/07/15/python对比两个图片的差异并记录/","excerpt":"","text":"1234567891011from PIL import Image, ImageChops, ImageStatim1 = Image.open(&quot;a.jpg&quot;)im2 = Image.open(&quot;b.jpg&quot;)diff = ImageChops.difference(im1, im2)diff.show()diff.save(&quot;c.jpg&quot;)stat = ImageStat.Stat(diff)sum_channel_values = sum(stat.mean)max_all_channels = len(stat.mean) * 100diff_ratio = sum_channel_values/max_all_channelsprint(diff_ratio)","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"}]},{"title":"Daily Notes 7.13","slug":"dailynotes-7","date":"2018-07-13T01:02:33.000Z","updated":"2018-07-14T16:48:05.982Z","comments":true,"path":"2018/07/13/dailynotes-7/","link":"","permalink":"https://ir1d.cf/2018/07/13/dailynotes-7/","excerpt":"Deep residual learning for image recognition","text":"Deep residual learning for image recognition TermsJaccard index用来衡量两个集合的相似程度。$J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}$ Deep residual learning for image recognition为什么 ResNet 和 Inception 网络可以得到比 VGG 更高的精度和更小的网络，但是在计算 perceptual loss 的时候还是一直在使用 VGG 的 feature map 呢？ 看到一种解释是 VGG 是逐层训练得到的，网络是分段卷积，是一个效果良好的 feature extractor。","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Daily Notes 7.12","slug":"dailynotes-6","date":"2018-07-12T01:56:22.000Z","updated":"2018-07-14T16:48:00.526Z","comments":true,"path":"2018/07/12/dailynotes-6/","link":"","permalink":"https://ir1d.cf/2018/07/12/dailynotes-6/","excerpt":"Network In Network Going deeper with convolutions","text":"Network In Network Going deeper with convolutions TermsWeight decay之前是$w = w - \\eta * \\frac{\\partial L}{\\partial W}$ 加上 weight decay 之后就是$w = w 0.99 - \\eta \\frac{\\partial L}{\\partial W}$ 相当于是 regularization 操作，用于防止过拟合 Momentum$v = \\beta v - \\alpha dx$$x = x + v$ 其中 $\\beta$ 是 Momentum 系数 Network In Network之前的卷积结构相当于是在对上一层特征做仿射变换，作者指出如果索要提取的特征不是线性可分的那么需要使用大量的滤波器。作者认为可以在卷积过程中选择对感受野进行更加复杂的操作，本文中介绍了 MLP 卷积层的设计。 MLP 卷积层的设计就是用多层 fc 代替。 f_{i, j, k_1}^1 = max((w_{k_1}^1)^Tx_{i,j} + b_{k_1}, 0)… f_{i, j, k_1}^n = max((w_{k_n}^n)^Tf_{i,j}^{n - 1} + b_{k_n}, 0)这里的 n 表示 multilayer perceptron 是 n 层的。这个过程也可以看作是对每一位置的不同通道进行线性变换（跨通道的交互和信息整合），相当于是在做1 x 1的卷积。 对多个线性函数进行 maxout 操作可以得到一个分段函数，这样的分段函数可以近似任何一个凸函数。 f_{i, j, k} = max_m{w^T_{km}x_{i, j}}可以看出二者是不同的。 文中还提出了一个操作是叫全局均值池化。之前的网络结构是把最后一个卷积层的输出传给全连接层然后再给一个 softmax 层做 logistic regression 。这个结构把卷积层看作是特征提取工具。但是这里面的全连接层很容易发生过拟合，导致整个网络的泛化性能不好。 本文中的全局平均池化是为了代替这个全连接层。文中的方法是对每一种类别生成一个 feature map 之后，并没有再加一个全连接层上去，而是直接对这些 feature map 内部求平均（每张 map 平均成一个数），之后再用 softmax 处理一下。这样做的好处是得到的信息更接近卷积层得到的分类信息，feature map 就可以转化为 categories confidence map。另一个好处是池化的过程没有额外的参数，可以避免过拟合。这个过程实际上就是强制网络学到用 feature map 来表示分类结果的方法。 这里发现了之前的一个错误理解，1 x 1的卷积是多个 feature channel 的线性叠加，这里 channel 不一定只有一个，所以不一定是只能用来 scaling。事实上，可以起到降维、通过后面接的非线性函数来增强非线性性之类的效果。 Going deeper with convolutions本文中指出 1 x 1 的卷积有两个用处，一是用来降维，二是用来去除计算瓶颈，这使得网络结构可以变深、变宽。 R-CNN 把目标检测的问题分成两个子问题：利用 low-level 的信息（比如颜色和纹理来生成目标区域），和利用 CNN 分类器对得到的区域里的物体进行分类。 文中表示神经网络努力变深变宽带来一个问题是参数变多，另一个问题是会导致在 filter 数量上升的时候，深层网络的计算成本是指数级增长的。文中提出了解决办法，可以引入 sparsity。但是稀疏的数据会在计算过程中产生额外的成本。 文中提出了 Inception 结构，主要是考虑如何用现有的组件来近似卷积网络，同时降低成本。文中引入1 x 1的卷积来实现降维，把降维后的信息在传给代价昂贵的3 x 3和5 x 5。多引入的卷积层还附带了非线性激活函数，增强模型的非线性性。最后还使用了 max-pooling 层来把网络的大小减半。作者表示，实验发现目前结构仍然不是很理想，适合在更高的层使用而让低层结构使用传统的卷积神经网络结构。 这个结构的优点之一是使得每一阶段增加节点数不会导致之后阶段的总计算复杂度 “uncontrolled blow-up”。作者认为这一设计和传统直觉是一致的，处理图像信息的时候从不同尺度来捕捉。 网络中在一层里包含多个卷积核，这样每一层都能学到稀疏和不稀疏的特征。另外文中引入了 DepthConcat 来对的一层里的信息整合，代替了常见的 ReLU 之类的非线性激活函数。 ref: https://stats.stackexchange.com/questions/184823/how-does-the-depthconcat-operation-in-going-deeper-with-convolutions-work 然后作者表示之前 Alexnet 使用的 cropping approach 看起来很不错，我们也用了，虽然优点不是很大。就是测试的时候把图片按照（256\\，288，329，352 四种大小）切出来的四个角落和中间部分喂给网络输入。","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Daily Notes 7.11","slug":"dailynotes-5","date":"2018-07-11T00:29:31.000Z","updated":"2018-07-14T16:47:53.322Z","comments":true,"path":"2018/07/11/dailynotes-5/","link":"","permalink":"https://ir1d.cf/2018/07/11/dailynotes-5/","excerpt":"Very deep convolutional networks for large-scale image recognition","text":"Very deep convolutional networks for large-scale image recognition Very deep convolutional networks for large-scale image recognition (VGG)本文中对数据的预处理也用了 Alexnet 里提到的方法，就是把数据的像素 RGB 值减去整个训练集的平均值。同时还利用了1 x 1的卷积核，文中认为1 x 1的卷积核相当于是对输入的通道做了一次线性变换。文中还提到不是所有的卷积层后面都跟着 max-pooling 层，感觉也是很神奇。 然后作者表示 Alexnet 的 LRN 操作并没有起到多大作用。作者认为在整个网络里使用3 x 3的卷积核可以让网络获得深度（其中会有更多的 rectification 层来让判别），另一方面通过堆叠（三层）3 x 3来获得7 x 7的感受域的话所需权重的数量要少一些，减少训练过程中的内存占用。文中认为使用1 x 1的卷积（后面跟着 ReLU ）可以增强决策函数的非线性性而不对感受域的大小造成影响。本质上可以把1 x 1的卷积看作是在空间中的一次线性变换。 VGG 里面也使用了 dropout。作者表示我们的方案比 Alexnet 需要训练的 epoch 数要少，一是因为更深的网络和更小的卷积核隐式地起到了 regularize 的功能，二是因为一些层进行了参数的初始化。 在训练的时候先预训练一个图片大小固定的（384，训 384 的时候用训 256 的时候的参数初始化），然后再训练的时候用 384 的参数来初始化，每处理一张图的时候，都从$[256, 512]$里随机一个数来表示图片的大小。作者认为这样的操作可以捕捉由于图像中目标大小不一致引入的信息。 文中表示做了数据的水平翻转来增强，但是没有用 Alexnet 里面提到的那个多次取样放到网络里训，因为这里的网络结构用卷积层替换掉了原来的全连接层，就可以直接在整张图上操作了。 实验部分中，作者提到选用多个模型融合（对结果求平均）可以取得更好地结果。 Terms Stochastic Gradient Descent 考虑到最初的梯度下降对于每次迭代都使用全部的样本，成本较高，SGD 简化了这个过程，在每次迭代的时候只对一个样本计算梯度，可以看做是 online learning 。 Mini-Batch Gradient Descent SGD 每次只用一个样本，如果遇上了噪声则很容易陷入局部最优解，所以使用 mini-batch 的思想，每次使用一批放进去计算梯度来更新。","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Daily Notes 7.10","slug":"dailynotes-4","date":"2018-07-09T16:43:38.000Z","updated":"2018-07-11T00:53:05.450Z","comments":true,"path":"2018/07/10/dailynotes-4/","link":"","permalink":"https://ir1d.cf/2018/07/10/dailynotes-4/","excerpt":"Imagenet classification with deep convolutional neural networks","text":"Imagenet classification with deep convolutional neural networks Imagenet classification with deep convolutional neural networks本文提出的 AlexNet，突破性地在 ImageNet 数据集上取得了极好的效果。作者特别自信地表示如果更快的 GPU 和更大的数据集出现，他们可以得到更好地结果。 我注意到一点很有趣的事情，他们处理数据的时候是直接把短边变成 256，然后直接裁中间的那部分。感觉这样很有可能导致最后的输入图像里只有部分信息，不知道是不是都这么做的。（感觉也没有别的办法了？总不能先跑一遍 detection？）另外，他们把图像的像素减去了数据集像素的平均值。 网络总共有8层，其中有5个卷积层和3个全连接层。 文中提出使用 ReLU 是不饱和的非线性函数，在梯度下降的时候训练速度要快。像$f(x)=tanh(x)$ 和 $f(x)=(1+e^{-x})^{-1}$是饱和的非线性函数（从图像可以看出）。 由于网络结构太大显存放不下，本文作者在两个 GPU 上面并行地跑。其中本文要求 GPU 只在特定的层才相互交换信息，来控制信息交换的代价在整个计算过程中的占比。 Local Response Normalization，翻译过来是局部响应归一化。首先又夸了 ReLU 的好处是不需要对输入数据做归一化因为它不饱和 —— 只要给 ReLU 的输入是正的，它的梯度就不为0。然后作者表示发现 local normalization 操作一下之后可以让网络有更好的泛化效果。注意$a_{x,y}^{i}$表示的是在$(x, y)$这个位置操作第i个卷积核的结果。局部归一化就是对每一个a，用相邻的n个卷积核结果来归一化。 b_{x, y}^{i} = a_{x, y}^{i} / {\\left( k + \\alpha \\sum_{j=max(0, i-n/2)}^{min(N-1, i+n/2)}(a_{x, y}^{j})^2 \\right)}^ \\beta其中 $k,n,\\alpha, \\beta$ 是超参数，在 validation set 上面决定的。这里作者并没有给数据减去它们的平均值。这个操作放在一部分 ReLU 层之后。好像说是 LRN 效果并不明显，在日后新网络结构中使用很少 作者表示发现如果允许池化层池化的部分又重叠，可以让网络不那么容易就过拟合、并减少错误率。 网络目标是最大化一个多项式的 logistic 回归，相当于是最大化数据输出的正确类别的可能性的平均值 文中使用的数据增强方法只需要很少的计算，这样增强之后多出来的数据不需要提前放到硬盘上。实现中用 CPU 来增强数据， GPU 同时训练上一批数据，所以对计算资源没有影响。第一种增强的方法是从256 x 256的图片中随机的取224 x 224的块，然后也加入水平翻转后的结果，这样就把数据集扩大为原来的2048倍。测试的时候也是取出来四个角落和中心的224 x 224的块以及他们的水平翻转，把这十张图的结果求平均当做是原图的测试结果。 第二种数据增强的方法是改变输入数据 RGB 通道亮度。文中对每张图片都做 PCA，$p_1, p_2, p_3$是特征向量，$\\lambda_1, \\lambda_2, \\lambda_3$是特征值。每次图像被用来训练的时候，都重新生成三个$\\alpha_i$，然后把原图上的每个像素加上$[p_1, p_2, p_3][\\alpha_1 \\lambda_1, \\alpha_2 \\lambda_2, \\alpha_3 \\lambda_3]^T$。这里面的$\\alpha_i$是从一个均值为0，标准差为0.1的高斯随机数发生器产生，注意这里对于同一张图在同一次训练过程中使用同一组$\\alpha_i$。作者表示这样操作可以使得学到的物体特征不受亮度和光照颜色的影响，captures an important property of natural images。文中表示实验结果证明可以减少错误率。 同时还使用了 dropout，就是让前两个全连接层的神经元有一定概率（文中0.5）不参与前向和反向传播。这样每次数据输入进来的时候，神经网络都给出一个不一样的结构，但是这些结构是共享权重的。这种操作可以减少神经元之间的依赖，因为如此下来神经元不能依赖于某个其他神经元的存在来处理信息，也就迫使神经元尝试学习到更加强大的可以和其他神经元的随机子集共同工作的特征。在测试的时候，本文中使用全部的节点，只不过把它们的输出都乘上0.5 作者表示初始化权重的时候用标准差为0.01的零均值高斯分布。给某些卷积层的神经元偏置设为1，使得初期阶段传给 ReLU 的输入是正的，其余层的偏置用0初始化。另外，如果在验证集上的错误率停止进步，就把学习率除以10 Terms Toeplitz matrix a.k.a diagonal-constant matrix. 主对角线上的元素相等，$A{i,j} = A{i+1,j+1}$ 不一定是个方阵 Factorial Distribution 要求一组变量中变量之间没有相互作用 $P(x|y) = P(x)$ non-saturating neurons 不饱和神经元，就是说梯度不接近0，还可以有效地调整权重","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"ubuntu防止打字误触触摸板","slug":"ubuntu防止打字误触触摸板","date":"2018-07-09T06:05:33.000Z","updated":"2018-07-09T06:06:36.009Z","comments":true,"path":"2018/07/09/ubuntu防止打字误触触摸板/","link":"","permalink":"https://ir1d.cf/2018/07/09/ubuntu防止打字误触触摸板/","excerpt":"","text":"123sudo add-apt-repository ppa:atareao/atareaosudo apt updatesudo apt install touchpad-indicator ref: http://ubuntuhandbook.org/index.php/2018/04/install-touchpad-indicator-ubuntu-18-04-lts/","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ir1d.cf/tags/ubuntu/"}]},{"title":"Daily Notes 7.9","slug":"dailynotes-3","date":"2018-07-09T00:07:32.000Z","updated":"2018-07-10T12:39:56.525Z","comments":true,"path":"2018/07/09/dailynotes-3/","link":"","permalink":"https://ir1d.cf/2018/07/09/dailynotes-3/","excerpt":"Image De-raining Using a Conditional Generative Adversarial Network Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks Image-to-Image Translation with Conditional Adversarial Networks","text":"Image De-raining Using a Conditional Generative Adversarial Network Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks Image-to-Image Translation with Conditional Adversarial Networks Image De-raining Using a Conditional Generative Adversarial Network本文提出了用conditional-GAN来生成无雨背景的方法 生成器从雨图中学习生成无雨背景，然后判别器来判断是真实背景还是生成的 然后提出损失函数中不应只有 perceptual loss，还应当加入 per-pixel 的 loss 和 adversarial loss 一起，不过文中并没有提到三个loss的权重是怎么学出来的 最后提到缺点是不能处理图像上的白块，猜测可能是数据集中没有出现类似情况导致的，以及指出数据集难以包含整个 rain streak 的可能情况 Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks本文介绍了从大量无标签数据集中学习可重复使用的特征表示的一些结果 文中也展示在图像数据集上用无监督的方法也可以得到很有趣的层次信息 文中总结了优化GAN的一些方法： 在判别器用 strided convolution, 在生成器用 fractional convolution 来代替所有的 pooling 层 在判别器和生成器中用 batch normalization 用更深的结构来替换掉全连接的隐藏层 生成器里除了最后一层都用 ReLU 来做 activation，最后一层用 Tanh 判别器里所有层都用 LeakyReLU 做 activation （激活函数） Image-to-Image Translation with Conditional Adversarial Networks很多视觉的 task 可以看作是在把输入图像翻译成输出图像，本文提出的 cGAN 技术可以学到这种翻译的对应关系，也学到一个对应的 loss function 来训练这个对应关系。最为著名的应用是 pix2pix。 conditional GAN 学习一个 structured loss，惩罚网络的输出在结构上的不同。 这里的 conditional 的最大区别在于，输入的 edge map 也要喂给判别器。同时文中提出，使用 L1 距离代替 L2 距离来要求生成器的输出和 groud truth 更近，可以鼓励减少模糊。 U-net看起来就是加上了 skip connection 的 encoder-decoder network 。比如给图片上色的时候，突出的边缘的位置信息是输入和输出共享的，如果直接把它们从输入层传到输出层（避免经过 bottle neck），情况会好很多。具体来说，U-net形式里面把第 i 层和第 n-i 层里所有的通道都通过 skip connection 直接连接起来 PatchGAN，就是每次对结构的惩罚是在一个 patch 的层级来操作的。就是对整个图而言，是每次考虑一个 n * n 的 patch 是真的还是假的。实验证明，甚至 n 和整个图的大小相比可以很小。这样下来判别器相当于把图片看作是一个 Markov random field，其中假设了距离超过一个 patch 的直径的像素点之间是独立的。这样的 PatchGAN 可以看作是一种 材质/风格 的 loss 文中还提到了一些优化，比如生成器要最大化$log\\ D(x, G(x, z))$而不是最小化$log\\ (1 - D(x, G(x, z)))$；另外在训练判别器的时候，把目标函数除以 2，用来减小 D 相对于 G 学习的速度，然后每次 D 下降一步，G 也下降一步。 文中还有个很神奇的地方，作者表示在 inference time，生成网络和训练的时候是完全一样使用的，就是说这里面的 dropout 部分在测试的时候也没有移除。 Terms image patch 图像块的意思= = Leaky ReLUs leaky ReLU 的特点是在 $x \\leq 0$ （inactive）的时候允许有一个小的正梯度（0.01） 而 Parametric ReLU 在这里更进一步，让那个正梯度变成一个参数，在神经网络反向传播的时候可以得到更新 注意在$a \\leq 1$的时候，PReLU 相当于 $max(x, ax)$，这个形式和 maxout 网络有一定关联","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"},{"name":"GAN","slug":"GAN","permalink":"https://ir1d.cf/tags/GAN/"}]},{"title":"Daily Notes 7.8","slug":"dailynotes-2","date":"2018-07-07T23:40:44.000Z","updated":"2018-07-10T12:47:53.326Z","comments":true,"path":"2018/07/08/dailynotes-2/","link":"","permalink":"https://ir1d.cf/2018/07/08/dailynotes-2/","excerpt":"什么也没读，沉迷标数据不能自拔 Joint Bi-layer Optimization for Single-image Rain Streak Removal","text":"什么也没读，沉迷标数据不能自拔 Joint Bi-layer Optimization for Single-image Rain Streak Removal 作息过于糟糕，下午回去看数分结果很快就睡着了，还是闹钟免疫的那种。。。。 Joint Bi-layer Optimization for Single-image Rain Streak Removal本文做的是去除单张照片上雨纹的工作，具体来说是尝试把一张照片分成有雨和无雨的两层。整个最优化过程是同时把雨纹的细节从无雨层去掉，和把无雨的信息从雨纹层去掉. 拿到一张图，文中方法首先尝试确定 rain-dominated 的区域，然后利用这部分区域来确定雨的方向，并提取出 rain-patch，之后用 joint bi-layer optimization 方法来迭代地得到两层。 我怎么有个问题。。感觉一张图里的 rain streak 完全有可能角度差得很大啊？ 比如前景和后景完全可以反向 Terms Frobenius norm a.k.a Euclidean norm, $\\left\\lVert A \\right\\rVert = \\sqrt{\\sum{i=1}^m{\\sum{j=1}^n{|a_{ij}|^2}}}$ fidelity term 保真项 Jensen’s inequality The mean value of a convex function is never lower than the value of the convex function applied to the mean. \\begin{align} - \\log p(x) &= - \\log \\int p(x,y) dy \\\\ &= - \\log \\int q(y\\vert x) \\frac{p(y,x)}{q(y\\vert x)}dy \\\\ &\\leq - \\int q(y\\vert x) \\log \\frac{p(y,x)}{q(y\\vert x)} dy \\end{align} L0 regularization l0 norm 是统计数组中的非零元素","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"Daily Notes 7.7","slug":"dailynotes-1","date":"2018-07-06T16:41:13.000Z","updated":"2018-07-10T12:43:41.579Z","comments":true,"path":"2018/07/07/dailynotes-1/","link":"","permalink":"https://ir1d.cf/2018/07/07/dailynotes-1/","excerpt":"学数学 + 下午睡过头了","text":"学数学 + 下午睡过头了 Terms Checkerboard Artifacts Checkerboard Pattern 是黑白格交替的图案 神经网络生成的图像在细节处往往会出现像素点颜色交替的现象 ref: https://distill.pub/2016/deconv-checkerboard/ transposed-conv 时出现 overlap 会导致这种现象 Sobel operator 用于 edge detection https://en.wikipedia.org/wiki/Sobel_operator skip connection 用在 resnet 里面","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[]},{"title":"Daily Notes 7.6","slug":"dailynotes","date":"2018-07-06T11:22:15.000Z","updated":"2018-07-09T08:48:27.020Z","comments":true,"path":"2018/07/06/dailynotes/","link":"","permalink":"https://ir1d.cf/2018/07/06/dailynotes/","excerpt":"","text":"经久不衰的 Daily Notes 系列又来了！ 今天读的这篇：Perceptual Losses for Real-Time Style Transfer and Super-Resolution Terms记录一些今天关注的内容 Transposed - conv 就是把卷积层反过来的感觉， 可视化效果：https://github.com/vdumoulin/conv_arithmetic stride cs231n 的课程页面上写得很清楚，就是步长 GAN basics 略 Dilated Convolutions ref: Dilated Convolutions and Kronecker Factored Convolutions 它的一大优点是可以指数级地扩大感受域（receptive field），而参数是对数级的。这带来一个问题，需要加条件才能保证可以参数共享。 上文中表示需要卷积操作相当于Kronecker product才行 CNN channel 【CNN】理解卷积神经网络中的通道 channel - CSDN博客 置信区间 展现的是，这个总体参数的真实值有一定概率落在与该测量结果有关的某对应区间 SSIM — Structural SIMilarity 衡量两幅图像相似度，其值越大越好，最大为1 ref: https://blog.csdn.net/edogawachia/article/details/78756680 PSNR — Peak signal-to-noise ratio 峰值信噪比,是一种评价图像的客观标准 1234def cal_psnr(im1, im2): mse = (np.abs(im1 - im2) ** 2).mean() psnr = 10 * np.log10(255 * 255 / mse) return psnr Fractionally-strided convolution ref: https://towardsdatascience.com/types-of-convolutions-in-deep-learning-717013397f4d 就是之前提到的反卷积，这东西别名太多 为什么叫分数步长呢？ 我们通过在原矩阵中间补0来使得正向的卷积结果相当于是反向的卷积，这是在原矩阵中的步长就可能是分数了 Perceptual Loss — 《Perceptual Losses for Real-Time Style Transfer and Super-Resolution》很多工作都可以看作是对图像进行转换操作 —— 输入一张图，输出转换后的一张图 按像素比较的loss function 不能捕捉全局的（？perceptual）信息 perceptual loss function 不比较对应位置像素的信息，而是比较high-level的信息，比如预先训练好的卷积神经网络中的特征表示（feature representations） 本文的工作是训练了一个用perceptual loss训练一个单向的（feed forward）网络，又快又好 本文主要关注图片风格转换和单张图的超分辨率重建（四倍和八倍） Feed-forward image transformation 翻译过来是前馈神经网络 高品质的风格转换要求对较大的区域进行一致的，而本文方法使得感受域变大。 Residual Connections ，认为可以方便地让网络学到恒等变换，这对风格转换很重要，因为大多数地方输出和输入是相同的。 Loss Function有两部分，一个是Feature Reconstruction Loss，另一个是Style Reconstruction Loss。 前者是feature representation的欧几里得距离除以feature map的大小（$C H W$）。最小化第一个损失函数可以保留视觉内容和整体空间上的结构，但是颜色、纹理和具体的形状不一定保留。 后者在内容不同是进行惩罚，也惩罚风格上的不同。表达式是大小为$C * C$的Gram矩阵的L2距离。 注意到很有趣的一点，结果中人像比较清晰但是背景并不清晰。一种可能的解释是VGG-16的特征大多是在人像和动物上训练的，我们的风格转换网络是在学习保留VGG-16学到的特征，这样我们的网络学到的背景的信息比较少","categories":[{"name":"summer2018","slug":"summer2018","permalink":"https://ir1d.cf/categories/summer2018/"}],"tags":[{"name":"paperReading","slug":"paperReading","permalink":"https://ir1d.cf/tags/paperReading/"}]},{"title":"扎心的2018年上半场小结","slug":"2018上半场","date":"2018-07-02T09:52:31.000Z","updated":"2018-07-02T10:32:10.307Z","comments":true,"path":"2018/07/02/2018上半场/","link":"","permalink":"https://ir1d.cf/2018/07/02/2018上半场/","excerpt":"迟到的总结…… hmmmmm","text":"迟到的总结…… hmmmmm 转过年是上学期的期末考试，扎心的三科考完就回家了。 寒假很长，做了个六重，装了很多次caffe，此外似乎也没干什么正经事 开学，选的课比较少，想要好好弄弄成绩 帮忙重构科协的网站 参与ICPC总决赛的工作 然后就是校赛 漫长的期中坚持了一个月 甚至如果算上史纲的学期论文可以认为期中和期末连着的 考试周的前几天完成了大部分课程，码了一周多的dp去考程设 看起来很没有营养的上半场，收获大概是python技能增强，对Java的热情逐渐失去，Node.js的东西已经可以上手写了；另一方面是成绩更加扎心了，要更加努力才行。 蹭了不少pr进各种仓库，以后要避免莫名其妙就花了那么多时间的情况了 freecodecamp也刷了不少，感觉这个项目有点转型了，还是安心leetcode去吧XD 接下来的日子，要很努力很努力才行","categories":[],"tags":[]},{"title":"泛做","slug":"cssx/泛做","date":"2018-06-27T08:01:24.000Z","updated":"2018-06-30T01:58:09.021Z","comments":true,"path":"2018/06/27/cssx/泛做/","link":"","permalink":"https://ir1d.cf/2018/06/27/cssx/泛做/","excerpt":"Educational Codeforces Round 45 的 B 和 C 不错 (CF #996)","text":"Educational Codeforces Round 45 的 B 和 C 不错 (CF #996) B. Micro-World 给一列数 每个a[i]可以覆盖[a[i] + 1 .. a[i] + k] 这个区间 如果有a[j]在这个区间里，那么称i可以被j吃掉，问最后最少剩几个 这个区间描述的关系是被吃的指向吃的，所以应该反过来，用a[j]引出[a[j] - k, a[j] - 1]这个区间，这时的含义是j可以吃覆盖的区间里的。答案就是没有被覆盖的a[i]的个数 把每个区间起点打标记+1，终点后一个位置-1，求个前缀和。如果一个位置是0那么就是没被覆盖过的 C. Bracket Sequences Concatenation Problem 给一堆括号序列，问有多少二元组，拼起来之后算是合法的 核心在于如何求一个括号序列左侧需要补多少左括号和右侧需要补多少右括号才合法 尝试过程略去，说一下结论 12345678f(i, 0, n) if (buf[i] == '(') &#123; ++r[idx];&#125; else &#123; if (r[idx]) --r[idx]; // 这里是需要不减成负的 // 如果会变成负的，那多出来的右括号是留给左侧，左侧用左括号补上的 // 就不需要右侧管了，所以要保证计数器不减成0&#125; POJ 1191 棋盘分割 方差的式子可以拆开 \\sigma = \\sqrt{\\frac{\\sum_{i=1}^n(x_i - \\bar x)^2}{n}} \\\\\\\\ = \\sqrt{\\frac{S}{n}}\\begin{align}S &amp; = \\sum_{i=1}^n(x_i - \\bar x)^2 \\\\&amp; = \\sum(x_i^2-2x_i\\bar{x}+\\bar{x}^2) \\\\&amp; = \\sum{x_i^2} - \\sum{2x_i\\bar{x}} + n{\\bar{x}^2} \\\\&amp; = \\sum{x_i^2} - 2n\\bar{X} + n\\bar{x}^2 \\\\&amp; = \\sum{x_i^2} - n\\bar{X}\\end{align} 用dp[n][x1][y1][x2][y2]表示这块区域切n刀 记忆化搜索，前缀和预处理 张三丰的传人 后三种剪枝其实是在说一件事，题目要求分组，但是组内不要求顺序。 但是dfs肯定是有设定了顺序的，所以剪枝方案说：第一个如果不行，换了也不行，直接减掉；最后一个如果不行，换了也不行； 当然我们从长到短枚举就人为给了数据一个顺序，这样的话就可以避免了重复枚举，不会在已知不可能的情况多次尝试、浪费时间 康拓展开 可以用来求排列的序号，比如问1..5的第16个排列是哪一个 也可以对给出的一组排列问它在所有的排列里排第几 https://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutation_index.html $ans = \\sum_{i=1}^{n}{(a[i]右侧比a[i]小的数的个数) * (n - i)!)}$ 逆向就是每次除以一个阶乘，余数继续。每次的商就是会有多少个数比这一位的数要小。可选的数字集合每次在变 用线段树搞一下就是nlogn查询了吧 (没写) 思考：如果允许元素重复呢？ 换言之，并不是严格意义上的排列 https://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutation_index_ii.html 后面乘的阶乘除以重复那部分 $\\frac{(\\sum{a_i})!}{\\Pi{(a_i!)}}$ 这样的 POJ 1037: A decorative fence c[i][k][0/1] 是前i个木棒中以第k短的开头，然后这一个是 下降/上升 的方案数 边界：c[1][1][0] = c[1][1][1] = 1 后面还要计算第C个方案是啥，类似于排列计数 依次假设第x短的木棒放在那，然后看此时的方案数是否&gt;= c 如果否，就用第x + 1短的木棒 LIS 计数 http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1376 http://www.cnblogs.com/dirge/p/5958808.html 考虑一个$O(n^2)$的算法 用a[i]表示原数组，l[i]表示以i结尾的LIS长度，dp[i]表示最长的这个的个数 我们每次处理a[i]如果它可以接在a[j]后面，那么l[i] = max(l[j]) + 1 然后我们同时可以发现，如果l[i] &gt; l[j] + 1，那么，dp[i] = dp[j]，因为最长的长度更新了，要重新计数；如果l[i] == l[j] + 1，那么更新进去，dp[i] += dp[j]. 用树状数组维护每一块的（用块里的数结尾的）LIS长度和对应个数 树上第i个位置代表的是以值i结尾的LIS的最长长度和对应个数 处理a[i]的时候，先看之前的用小于a[i]的数结尾的（这里是二维偏序）LIS的长度和对应个数 然后把长度更新 再插回树状数组里。 https://github.com/Ir1d/Fantasy/blob/master/51NOD/1376.cpp POJ 1390 方盒游戏 就是考虑最右侧的块，有两种选择，要么直接消了，要么把它左边消了，等着合并。 注意第二种方案不是和左边一起直接消了，而应该递归进入子问题 所以dp[i][j]并不够用，要加一维，用dp[i][j][len]，表示把[i .. j]这段，和与a[j]相等且长度为len的一块合并的最大得分 左边的同色大块可能有很多个，到底和哪个合并最好，不知道，只能枚举 upd: 细节是要先游程编码，然后对编码之后的序列搜能方便一些。程设2018考了个类似的，死活没调出来 HDU 1423 LCIS https://www.cnblogs.com/Howe-Young/p/5082611.html 用dp[i][j]表示str1和str2分别以i和j结尾的LCIS，第一维空间可以省掉 如果s1[i] == s2[j]更新一下答案，用什么更新呢？ 就是先预处理出来s1[i]对应的，s2[j] &lt; s1[i]且让dp[j]最大的j 由于i在外层固定，所以循环的时候按顺序记一下这个j就好了","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"https://ir1d.cf/tags/程设/"}]},{"title":"算导 动态规划部分 笔记","slug":"算导dp笔记","date":"2018-06-25T14:59:18.000Z","updated":"2018-06-27T13:15:07.505Z","comments":true,"path":"2018/06/25/算导dp笔记/","link":"","permalink":"https://ir1d.cf/2018/06/25/算导dp笔记/","excerpt":"动态规划应用于子问题重叠的情况","text":"动态规划应用于子问题重叠的情况 要去刻画最优解的结构特征 尝试递归地定义最优解的值（就是我们常说的考虑从i - 1转移到i） 计算最优解 利用计算出的信息构造一个最优解 钢条切割给定一段钢条，和不同长度的价格，问如何切割使得总价格最大 为了求解规模为n的原问题，我们先求解形式完全一样，但规模更小的子问题。即当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。 最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解 动态规划的两种实现方法 带备忘的自顶向下法 （记忆化搜索） 自底向上法 （将子问题按规模排序，类似于递推） 算导用子问题图上按照逆拓扑序求解问题，引出记忆化搜索。 重构解（输出方案）：转移的时候记录最优子结构的位置 矩阵链乘法给出n个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算 （认为$p q$的矩阵与$qr$的矩阵相乘代价是$pqr$） 完全括号化方案是指要给出谁先和谁乘 动态规划原理两个要素： 1. 最优子结构具有最优子结构也可能是适合用贪心的方法求解 注意要确保我们考察了最优解中用到的所有子问题 证明问题最优解的第一个组成部分是做出一个选择 对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。 要保持子问题空间尽量简单，只在必要时扩展 最优子结构的不同体现在两个方面： 原问题的最优解中涉及多少个子问题 确定最优解使用哪些子问题时，需要考察多少种选择 子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边 经典问题 无权最短路径 具有最优子结构性质 无权最长（简单）路径 此问题不具有，是NP完全的 区别在于，要保证子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解。 相关 —— 求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用 2. 子问题重叠子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。 重构最优解存表记录最优分割的位置，就不用重新按照代价来重构 最长公共子序列子序列允许不连续 每个c[i][j]只依赖于c[i - 1][j]、c[i][j - 1]和c[i - 1][j - 1] 记录最优方案的时候可以不需要额外建表（优化空间），因为重新选择一遍（转移过程）也是$O(1)$的 最优二叉搜索树给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小 考虑当一棵子树成为了一个节点的子树时，答案（期望搜索代价）有何变化？ 由于每个节点的深度都增加了1，这棵子树的期望搜索代价的增加值应为所有概率之和 tD / eD 动态规划：状态空间是$O(n^t)$的，每一项依赖其他$O(n^e)$项 经典问题（来自习题）DAG 中的最长简单路径$dp[i] = max(dp[j] + 1), ((j, i) \\in E)$ 最长回文子序列 dp[i][i + len] = \\begin{cases} dp[i + 1][i + len - 1] + 2, & \\text{if $s[i] == s[i + len]$} \\\\[2ex] max(dp[i + 1][i + len], dp[i][i + len - 1]), & \\text{else} \\end{cases}边界：$dp[i][i] = 1$ 注意：$dp[i][j]$ 表示的是闭区间 也可以转化为LCS问题，只需要把a串反转当做b，对a和b求lcs即可 证明在： https://www.zhihu.com/question/34580085/answer/59539708 注意区分子串（要求连续）的问题 最长回文子串$O(n^2)$：$dp[i] = max(dp[j] + 1), s(j + 1 .. i) 是回文$ $(O(n))$： Manacher Manacher $p[i]$ 表示从i向两侧延伸（当然要保证两侧对应位置相等）的最大长度 为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的）#，开头加一个$ 这样得到的回文串长度就保证是奇数了 考虑如果按顺序得到了$p[1 .. i - 1]$，如何计算$p[i]$的值 如果之前有一个位置比如说是id，有p[id] + id &gt; i 那么i这个位置是被覆盖了的，根据id处的对称性，我们找p[id * 2 - i]延伸的部分被p[id]延伸的部分所覆盖的那段，显然这段对称回去之后是可以从i处延伸出去的长度。 如果找不到呢？就先让p[i] = 1吧。 之后再暴力延伸一下。 可以证明是$O(n)$的 至于如何找是否有这么一个id呢？递推的时候存一个max就好了 代码在：https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp 双调欧几里得旅行商问题好像出成了某一年程设期末 upd：其实是推荐练习里面的 off-topic：惊了，原来 hexo 内链是可以这么写的：程设期末推荐练习 书上的提示是：从左到右扫描，对巡游路线的两个部分分别维护可能的最优解 说的就是把回路给拆开吧 思路一：$dp[i][j] 表示\\ 1..i\\ 和\\ 1..j\\ 两条路径$ 我们可以人为要求 $1..i$ 是更快的那一条路径 这样考虑第i个点分给谁 如果是分给快的那条： $dp[i][j] = min(dp[i - 1][j] + dis[i - 1][i]),\\ j = 1..i$ 如果是慢的，原来是慢的那条就变成了快的，所以另一条是到i - 1那个点： $dp[i][j] = min(dp[i - 1][j] + dis[j][i]),\\ j = 1..i$ 答案是$min(dp[n][i] + dis[n][i])$（从一开始编号，终点是n） 代码：https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp 思路二把$dp[i][j]$定义反过来，不是$1..i$和$1..j$ 改成是$i..n$和$j..n$，不要求哪个更快 这样的转移更好写 我们记k = max(i, j) + 1 k这个点肯定在两条路中的一个上，$dp[i][j]$取两种情况的最小值即可 $dp[i][j] = min(dp[i][k] + dis[k][j], dp[k][j] + dis[i][k])$ 边界是：$dp[i][n] = dp[n][i] = dis[n][i]$ 答案是$dp[1][1]$ 整齐打印希望最小化所有行的额外空格数的立方之和 注意到实际问题要求单词不能打乱顺序，所以就好做了起来 # 论不要把题目看复杂 $dp[i] = min(dp[j] + cost[j][i])$ 不知道这样可不可做= = 有n个单词，可以不按顺序打印，问怎么安排，使得把他们打印成m行之后，每行的空格之和最小 编辑距离变换操作有6种，复制、替换、删除、插入、旋转、终止（结束转换过程） 最优对齐问题把空格符插入到字符串里，使得相似度最大 定义了按字符比较的相似度 然后发现最优对齐问题可以转换为编辑距离问题 相当于仅有三个操作的带权编辑距离 123copy : 1replace : -1insert : -2 公司聚会计划没有上司的舞会 dp[x][0]是没去 dp[x][1]是去了 $dp[u][0] = max(dp[v][0], dp[v][1]), v \\in son(u)$ $dp[u][1] = w[u] + dp[v][0], v \\in son(u)$ 译码算法Viterbi algorithm之前写词性标注的时候有用到，好像用在输入法里面也是类似的。 本题中用来实现语音识别，其实就是找一条对应的概率最大的路径 ref：https://segmentfault.com/a/1190000008720143 基于接缝裁剪的图像压缩玩过 opencv 的应该有印象，seam carving 就是在做 dp 题中要求每一行删除一个像，每个像素都有代价，要求总代价最小 限制：要求相邻两行中删除的像素必须位于同一列或相邻列 $dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]， dp[i - 1][j + 1]) + cost[i][j]$ 边界：$dp[1][i] = cost[1][i]$ 字符串拆分相当于问怎么按顺序拼起来使得总代价最小 等价于之前那个最优二叉搜索树 $dp[i][j] = min(dp[i][k] + dp[k][j]) + l[j] - l[i] + 1,\\ k = i + 1\\ ..\\ j - 1$ 注意l[i]表示的是第i个切分点的位置 边界：$dp[i][i] = 0$ 就按照区间 dp 的姿势来写就好了 投资策略规划 可以证明存在最优投资策略，每年都将所有钱投入到单一投资中 这是个很有趣的结论，dp 问题中很常见 https://fogsail.github.io/2017/05/08/20170508/ 剩下的就是个二维 dp，想成从$(1, i)$走到$(n, m)$的路径的问题，然后收益和代价就是边权，网格图只能往右下方走。 库存规划生产多了少了都有额外的成本，问怎么安排生产策略使得额外的成本尽可能地少 $cost[i][j]$ 表示剩下i个月，开始的时候有j台库存的最小成本 https://walkccc.github.io/CLRS/Chap15/Problems/15-11/ 签约棒球自由球员$v[i][j]$ 是考虑i之后的位置，总费用为x，的最大收益 https://walkccc.github.io/CLRS/Chap15/Problems/15-12/ 类似于背包问题 当选取的状态难以进行递推时（分解出的子问题和原问题形式不一样），考虑将问题状态分类细化，增加维度","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://ir1d.cf/tags/矩阵乘法/"},{"name":"算法导论","slug":"算法导论","permalink":"https://ir1d.cf/tags/算法导论/"}]},{"title":"Codeforces Round 492 (Div. 2) [Thanks, uDebug!]","slug":"cf/cf996","date":"2018-06-25T12:45:31.000Z","updated":"2018-06-25T14:14:53.425Z","comments":true,"path":"2018/06/25/cf/cf996/","link":"","permalink":"https://ir1d.cf/2018/06/25/cf/cf996/","excerpt":"花式过 pp ，专业 fst 选手大显身手","text":"花式过 pp ，专业 fst 选手大显身手 A. Hit the Lottery dp肯定是对的，至于为什么可以贪心呢？ B. World Cup 模拟 C. Tesla 半个小时过去没人过的那种…… 写了半天还是WA 题意是一个两排车道，要求把车停到路边（道牙子上），求方案 题解：先把能放的放进去。把双排道看成一个环，如果有空位能转动就一定有解 这种题坐标一定要按照题目要求来，不能题里是1开头你自己用0开头读入 D. Suit and Tie 数据是成对的，但是被打乱了，问最少要操作多少次可以恢复 注意到最开头的那个数没必要动，于是它对应的那个数必须换过来。以此类推，搞定 E. Leaving the Bar 输入一堆向量，问如何给他们定向(1 / -1)，使得他们的和的模长符合条件。 现场写的贪心的，竟然过了pp 然后发现有dalao加了个如果不符合条件就random shuffle之后重新贪心 哎…… 咋就没想到呢 http://codeforces.com/contest/995/submission/39644972 woq…… stm 发现了一个从后往前贪心过了的= = 题解里证明说每三个模长合格的里面总是能找到两个组成一个模长合格的，这样最后直到只剩两个，顶多是$\\sqrt{2} r$","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://ir1d.cf/tags/codeforces/"}]},{"title":"程设期末上机汇总","slug":"cssx/程设期末上机汇总","date":"2018-06-24T11:41:06.000Z","updated":"2018-06-29T03:04:54.771Z","comments":true,"path":"2018/06/24/cssx/程设期末上机汇总/","link":"","permalink":"https://ir1d.cf/2018/06/24/cssx/程设期末上机汇总/","excerpt":"","text":"A02:马走日 dfs的时候别忘了起点也要标记为vis A04:鸣人的影分身 整数划分，允许分出来0 1234567g(i, 1, 20) dp[0][i] = 1;g(i, 1, 20) &#123; g(j, 1, 20) &#123; if (i &gt;= j) dp[i][j] = dp[i][j - 1] + dp[i -j][j]; else dp[i][j] = dp[i][i]; &#125;&#125; A09:Stupid cat &amp; Doge 永远的痛 https://blog.csdn.net/sssSSSay/article/details/52097617 B04:猴子摘桃 可以尺取 注意枚举区间的姿势：如果枚举的是闭区间的端点，应该是g(j, l, r) 别漏了 [r..r] 这个 B09:变换的迷宫 注意到不能原地不动，所以还是会有无解的情况= = 忘了输出感叹号了 vis[x][y][ti % k] 来标记是否可以再走 B02:夺宝探险 没什么特别的，dfs就可以了 但是又WA又T 发现自己看题里说第一行第一列就写了个dfs(1, 1, 1)，然而是从0开始读入的 B10:游览规划 枚举天数，二维代价dp ref: https://blog.csdn.net/niwatori1217/article/details/51869474 C01:浮点数求高精度幂 输出的时候好难受，其实分开写就好了 先输出小数点前的，判一下是不是需要小数点 再看小数点后面的 C05:生理周期 扩展欧几里得是y -= a / b * x 数据水 C08:恼人的青蛙 最核心的剪枝是判断第一个点不合法的那个 就是先排序了嘛，然后当前的第二个点步长过大，之后的点不会更好，所以就得出是第一个点的问题 怎么判断步长是不是过大呢？就看跳当前答案次还到没到头 从小到大枚举可以让答案很快就变得足够大，方便剪枝 还有一个坑点是，枚举的是第一个点和第二个点，那么前一个位置（回退回去）不能在田里 C09:放苹果 盘子相同，允许空 12if (i &gt;= j) dp[i][j] = dp[i][j - 1] + dp[i - j][j];else dp[i][j] = dp[i][i]; 边界：dp[0][i] = 1 E05:抓住那头牛 开始以为是贪心啥的，后来发现bfs就可以啦 # 论搜索的时候要判断起点是不是就是重点了 E06:宠物小精灵之收服 二维代价的01背包 dp[i][j][k] 是前i个精灵，最多用j个精灵球，伤害最多为k，能捉到的最大个数 第一维可以省去 然后求最小伤害就是找dp[n][i] == dp[n][V]的最小的i E09:棋盘问题 莫名其妙写了好久 其实可以按顺序一格一格搜，放或者不放 也可以一行一行来 莫名其妙WA D02:要变多少次 可以求个LIS 也可以先求一下前缀有多少个1，枚举在哪分割 char不能当int用= = D05:表达式的期望值 想了一天 其实就是dp[i][j]表示前i个操作，结果是j的概率 然后这个题我直接拆开每位单独考虑了，也不知道合在一块能不能过 code：https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/ftall/d5.cpp ref: https://blog.sengxian.com/algorithms/probability-and-expected-value-dynamic-programming D07:忍者道具 状压dp，掌握了数组元素直接用PII的姿势 而且这东西可以直接用min来更新，省掉了显式用if判一下的步骤 dp[S]是一个pair&lt;int, int&gt;，first是放了多少包了，second是最后一包放了多大空间了 然后枚举S和最后一个放的i，要么放最后一个，要么新开了一个包 D10:ACM/ICPC 2018 HDU 5445 做两遍多重背包 第一遍对点心，求出总能量不小于p的最小体积minv，第二遍对卡车，求出总容积不小于minv的最小花费minc 找不到容积足够大的则输出FAIL “甜点可以切分，但是运过去的必须是整个甜点”，这里其实就在暗示，选甜点和装车是独立的两个过程 D11:机智的弗兰克 把障碍物移到远端（右上角） 在左下角枚举矩形，求个最大","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"https://ir1d.cf/tags/程设/"}]},{"title":"Codeforces Round 491 (Div.2)","slug":"cf/cf991","date":"2018-06-23T17:46:29.000Z","updated":"2018-06-25T14:16:17.826Z","comments":true,"path":"2018/06/24/cf/cf991/","link":"","permalink":"https://ir1d.cf/2018/06/24/cf/cf991/","excerpt":"好久没打了，根本不在状态，深夜掉分场","text":"好久没打了，根本不在状态，深夜掉分场 A. If at first you don’t succeed… 坑点在判断数据是否合法，忘了加上$a &lt; c$，$a &lt; n$之类的，WA了一发 B. Getting an A 问最少修改多少个数满足条件 统计个数然后判一判，WA 于是排个序暴力做 double 转 int 竟然是 直接截断 // 埋下伏笔 C. Candies 交了九发= = 题意是一个人每天吃k个，另一个人每天吃$10%$，问最少的k，使得第一个人吃的至少为总共的一半 这题不能用 * 0.1 应该用 / 10 qls: 整数题怎么有人写 double 的 题面写的是“第一个人吃的至少为总共的一半”，如果总数是奇数，是上取整，换言之，要求第一个人吃的比第二个人多 又WA又T一时爽 D. Bishwock 给一个 $2 * n$ 的棋盘，问最多能放多少个L型的块 贪心放就好了，WA了一发少考虑了几种情况 upd: fst…. 少判了几种情况 E. Bus Number 给一个$1e18$范围的数，问选择里面的一部分数字（要求每种都得出现），重排之后能排出来多少种不同的数 当时就写了个爆搜上去 TLE 最后五分钟想起来加个记忆化 最后半分钟发现 hash 函数返回值竟然没写 导致一直过不去样例 加上return s就交，最后一秒钟返回pp upd: fst…. sb了 hmmm 发现又枚举各个数字的个数过了的 题解：http://codeforces.com/blog/entry/60181","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://ir1d.cf/tags/codeforces/"}]},{"title":"程设期末推荐练习","slug":"cssx/程设期末推荐练习","date":"2018-06-23T03:13:56.000Z","updated":"2018-06-26T07:16:06.902Z","comments":true,"path":"2018/06/23/cssx/程设期末推荐练习/","link":"","permalink":"https://ir1d.cf/2018/06/23/cssx/程设期末推荐练习/","excerpt":"","text":"04:What a Ridiculous Election 注意搜的时候到同一个点有不同的状态，判断的时候不是判断是否vis，而是要看当前的step和上一次的比较dp[s][i][j]表示到达s状态用了i次操作一和j次操作二的结果然后注意输出答案的时候要在终点枚举所有的i和j 05:42点 写的时候想得复杂了，其实注意到可以交换顺序，所以这个东西其实只需要每次找两个数操作一下，然后放回去就好了。这样甚至考虑到了括号嵌套的问题 减法和除法是有顺序的，所以要两种都做一下 ref 这个题 这里面还要处理不能整除的情况，要用double = = 06:A Knight’s Journey 深搜注意回退删除标记 = =用时间戳表示vis数组的时候，不是每个 case 开始的时候都清空，需要保证全局唯一 07:Sudoku 数独，多case要初始化，深搜回退要恢复状态= = 10:股票买卖 ll[i] 表示 i 左侧极差rr[i] 表示 i 右侧极差这样答案就是 $max{ll[i], rr[i + 1]}$ 先用 ll[i] 得到 i 左侧最小的数和a[i]的差，然后对ll[i]求个前缀 max 就好了 12:开餐馆 dp[i] 最后一个在 i 开，最大的价值答案是数组的最大值 11:Tour POJ 2677 想了好几天，把一来一回的路径拆开，考虑$dp[i][j] 表示 1..i 和 1..j 两条路径$，然后考虑下一个点（i）是从谁接过来的 https://blog.csdn.net/xiaoxiaoluo/article/details/7636592 这里人为要求 $i \\geq j$ https://blog.csdn.net/ECNU_LZJ/article/details/71211855 这个更直观，把路径反向，方便转移 14:DNA 调了半天，甚至还换了种思路写，最后发现问题是在于求重叠部分的长度又写错了 首先没想到的是，如果一个串被另一个包含了，那么短的直接删掉就好了 思路一：长度很少，枚举全排列，拼起来 思路二：状压dp，$dp[st][i]$表示已经拼了st里面这些字符串i是最后一个的答案，记忆化搜之 求重叠部分的写法： 123456int res = std::min(len[a], len[b]);while (res) &#123; if (strstr(s[b], s[a] + len[a] - res) == s[b]) break; --res;&#125;return res; 论善用strstr的重要性 13:上机 按顺序考虑，前i个人的结果受前i-1个人的结果和第i与第i-1的顺序的影响 设计：$dp[i][l][r]$表示处理到第i个人，左侧 / 右侧有没有人 转移：dp[i][k][t] = std::max(dp[i][k][t], dp[i - 1][j][k ^ 1] + a[i][k + t]); 注意带如果第i个人左侧的状态是k，那么对于第i-1个人而言，他右侧的状态就是k ^ 1 注：用k + t简化，a[i][0]就是都没人，a[i][1]就是有一个,a[i][2]就是两侧都有人 这里的j是不造成影响的，转移的过程中要考虑每一个j（0 / 1）","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"https://ir1d.cf/tags/程设/"}]},{"title":"openjudge动态规划","slug":"cssx/openjudge动态规划","date":"2018-05-25T11:42:16.000Z","updated":"2018-06-24T11:40:54.559Z","comments":true,"path":"2018/05/25/cssx/openjudge动态规划/","link":"","permalink":"https://ir1d.cf/2018/05/25/cssx/openjudge动态规划/","excerpt":"感觉之前使用md的姿势好像不对 = =","text":"感觉之前使用md的姿势好像不对 = = ref: https://fancypei.github.io/OpenjudgeDP/ LCIS $O(n^2)$ dp[i][j] 表示a串前i个和以b[j]结尾的串的LCIS的长度 转移是： dp[i][j]=max(dp[i][j],dp[i-1][k]+1) a[i]==b[j]&amp;&amp;b[k]&lt;b[j] 1&lt;=k&lt;j dp[i][j]=max(dp[i][j],dp[i-1][j]) a[i]!=b[j] 123456789101112131415for (i = 1; i &lt;= m; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; dp[i][j] = 0; if (x[i] != y[j]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; for (k = 1; k &lt; j; ++k) &#123; if (dp[i][j] &lt; dp[i - 1][k] &amp;&amp; y[k] &lt; y[j]) &#123; dp[i][j] = dp[i - 1][k]; &#125; &#125; dp[i][j] += 1; &#125; &#125;&#125; 第二个式子i从i-1转移过来，所以可以把i放到外层。这样内层循环的时候a[i]是固定的。根据第一个式子，a[i] == b[j] &gt; b[k]，实际上要找的是b[j] &lt; a[i] 的最大的dp[i - 1][j]，在内层循环的同时存一下就好了，不需要再去枚举那个k了。所以平方的复杂度就能做了 1234567891011121314for (i = 1; i &lt;= m; i++) &#123; mlen = 0; for (j = 1; j &lt;= n; j++) &#123; dp[i][j] = dp[i - 1][j]; //更新mlen if (y[j] &lt; x[i] &amp;&amp; dp[i - 1][j] &gt; mlen) &#123; mlen = dp[i - 1][j]; &#125; //计算dp[i][j] if (y[j] == x[i]) &#123; dp[i][j] = mlen + 1; &#125; &#125;&#125; https://github.com/Ir1d/Fantasy/blob/master/POJ/2127.cpp （openjudge没有spj） 记录路径的姿势都忘光了= = 1234567x = n; p = 0;while (ans--) &#123; st[++p] = b[y]; while (a[x] != b[y]) --x; y = pre[x][y]; --x;&#125; ref: http://blog.fly2best.com/algorithm/2013/05/11/longges-common-increasing-subsequence/ 山区建小学 http://noi.openjudge.cn/ch0206/7624/ 四边形不等式 7627 鸡蛋的硬度 f[i][j]=min(1+max(f[i-1][t-1],f[i][j-t]) 1234567for (int i = 1; i &lt;= 100; i++) f[1][i] = i;for (int i = 2; i &lt;= 10; i++)for (int j = 1; j &lt;= 100; j++) &#123; f[i][j] = 1 + max(f[i - 1][0], f[i][j - 1]); for (int t = 2; t &lt;= j; t++) f[i][j] = min(f[i][j], 1 + max(f[i - 1][t - 1], f[i][j - t]));&#125; 9265:取数游戏 自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是相邻的两个不可以同时被取走. 答案是斐波那契数，考虑最后一个取(dp[i - 2])，或者不取（dp[i - 1]）. 9267:核电站 加强，变成不能连续m个 12345g(i, 0, m) dp[i] = 1LL &lt;&lt; i;--dp[m];g(i, m + 1, n) &#123; dp[i] = 2 * dp[i - 1] - dp[i - m - 1];&#125; 9268:酒鬼 不能连续取三个，问取出的最大权值和 123456// f是最远，g是到i结束// 答案是f[n]for (i = 3; i &lt;= n; i++) &#123; g[i] = v[i] + max(f[i - 2], v[i - 1] + f[i - 3]); f[i] = max(g[i], f[i - 1]);&#125; POJ3046 https://blog.csdn.net/jaihk662/article/details/77951670 需要滚动数组 dp[i][j]表示前i个集合取j个数的种类数 然后 $dp[i][j] = \\sum_{k=0}^{min(cnt_i, j)} dp[i - 1][j - k]$ 9288:Zju2061 Buy the Ticket 排队买票 卡特兰数 相当于在一个格点阵列中，从 (0, 0) 点走到 (n, m) 点且不穿过对角线 x = y 的方法数 。 最后答案要乘上排列数（阶乘） 6046:数据包的调度机制 区间dp，dp[i][j] 是把[i, j]这一段的数据包发出去的最小代价，然后转移的时候枚举这一段里面哪一个是最后发出的。因为是个栈，所以最后一个发出的那个包前面的是第一段，那个包后面的是第二段。 https://github.com/Ir1d/Fantasy/blob/master/openjudge/6046.cpp 4149:课程大作业 dp[i][S]表示前i天完成S的最小代价 过不了 dp[S]表示完成S的最小代价，每次枚举第一个完成哪个，记忆化搜索 https://github.com/Ir1d/Fantasy/blob/master/openjudge/4149.cpp 1481 Maximum sum ll[i]为以i为终点rr[i]为以i为起点 ls[i]为前i个rs[i]为后i个 边界数据 12312-1 -1 时间复杂度O(n) 162 Post Office dp[i][j]表示前i个位置放j个post office的最小代价转移是dp[i][j] = min{dp[k][j - 1] + cost[k + 1][i]};cost数组可以v^2p预处理 时间复杂度O(v^2p) 考虑优化：(四边形不等式) 证明略 决策变量k具有单调性 从而优化到O(v^2) 1759 LIS *lower_bound(dp, dp + n, a[i]) = a[i]; 1768 最大子矩阵 枚举起始与终点行，转化为最大子段和 1775 采药 01背包 1808 公共子序列 LCS 1944 吃糖果 Fibonacci 1996 登山 转化成求两遍LIS 2421 Exchange Rates 题目比较坑 dp[i][0], dp[i][1]分别是两种全部转化后最大多少 一定存在一种最优策略是每次全部转化的 2718 移动路线 dp[i][j] += dp[i - 1][j] + dp[i][j - 1]; 2728 摘花生 数字正方形 dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]) + a[i][j]; 2984 数字组合 dp[i][j] 表示前i个数拼成j的方案数 然后滚动数组优化成一维空间 2988 计算字符串距离 dp[i][j] 表示s的前i与t的前j的距离 然后转移就是分各个情况就好 注意和LCS不同之处在于预处理 LCS刷0即可 然而这个地方要12g(i, 1, n) dp[i][0] = i;g(i, 1, m) dp[0][i] = i; 2989 糖果 转移是有条件的 123456g(i, 1, n) f(j, 0, k) &#123; int tee = (j - a[i] % k + k) % k; dp[i][j] = dp[i - 1][j]; if (dp[i - 1][tee] || !tee) dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][(j - a[i] % k + k) % k] + a[i]);&#125; 3531 判断整除 原来这个条件很常见。。。 同上题 ………………刷表法的话就不用特判了= = 3532 最大上升子序列和 LIS 变个形 4977 怪盗基德的滑翔翼 求一下两个方向的LIS求max即可 4978 宠物小精灵之收服 二维费用的01背包问题 背包九讲(https://github.com/tianyicui/pack/blob/master/V2.pdf) 4982 踩方格 爆搜 或者打个表发现 12f[0] = 1,f[1] = 3;f[i] = f[i - 1] * 2 + f[i - 2]; 6045 开餐馆 dp[i]表示到i为止的最大收益 O(n^2T) 8787 数的划分 dp[i][j]表示将i分成j份的方案数dp[i][j]=dp[i-j][1]+dp[i-j][2]+dp[i-j][3]+…+dp[i-j][j-1]+dp[i-j][j]; 时间复杂度是n*k^2 O(n*k)的方法： dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j]; dp[i-1][j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+…+dp[(i-1)-(j-1)][j-1]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1]; 因此， dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1]+dp[i-j][j]=dp[i-1][j-1]+dp[i-j][j]; 666 放苹果 假如将7个苹果放进3个盘子里，可以分2种情况考虑：1，空着一个盘子不放，即将7个苹果放进2个盘子里；2，先每个盘子均放进一个苹果，再按照本规则继续放下去。 于是有递推公式：F(X,Y)=F(X,Y-1)+F(X-Y,Y) F(X,1)，F(1,Y),F(0,Y),F(X,0)都等于1 当X&lt;Y时，即比如说将5个苹果放进8个盘子里，根据题意，和将5个苹果放进5个盘子是一样的结果 ①最少的盘子放了一个，这样每个盘子至少一个，n个盘子先放上n个，剩下的m-n个可以随便放②最少的盘子没有放，这样剩下的n-1个盘子还是随便放m个 6049 买书 考虑分别记录拼出i这个数最后一个用了啥 注意到拼数的方案与顺序无关，因此可以递增地来考虑 123456789101112131415161718if (i &gt;= 10) &#123;dp[i][0] += dp[i - 10][0];&#125;if (i &gt;= 20) &#123;dp[i][1] += dp[i - 20][0];dp[i][1] += dp[i - 20][1];&#125;if (i &gt;= 50) &#123;dp[i][2] += dp[i - 50][0];dp[i][2] += dp[i - 50][1];dp[i][2] += dp[i - 50][2];&#125;if (i &gt;= 100) &#123;dp[i][3] += dp[i - 100][0];dp[i][3] += dp[i - 100][1];dp[i][3] += dp[i - 100][2];dp[i][3] += dp[i - 100][3];&#125; 6252 通配符字符串匹配 dp[i][j]表示s[1..i]与t[1..j]是否匹配 12345678910g(i, 1, n) &#123; tee = dp[i - 1][0]; if (s[i] == '*') dp[i][0] = tee; g(j, 1, m) &#123; tee |= dp[i - 1][j]; // dp[i][j] if (s[i] == '?' || s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1]; if (s[i] == '*') dp[i][j] = tee; &#125;&#125; 7113 Charm Bracelet 01背包 747 Divisibility 同3531 判断整除 而且数据更强？ 奥妙重重 强烈怀疑3531放了个什么奇怪的数据 刷表法姿势不对竟然也能过= = 1234567891011dp[0][0] = 1;g(i, 1, n) &#123; scanf(\"%d\", &amp;x); x = abs(x); x %= k; f(j, 0, k) if (dp[i - 1][j]) &#123; dp[i][(j + x) % k] = 1; dp[i][((j - x) % k + k) % k] = 1; &#125;&#125;if (dp[n][0]) puts(\"Divisible\"); 7614 最低通行费 dp[i][j][k]表示到(i,j)走了k步的最小代价 7624 山区建小学 同162 Post Office 7625 三角形最佳路径问题 数字三角形 7627 鸡蛋的硬度 http://blog.csdn.net/jerry99s/article/details/48802527 8462 大盗阿福 saffah出过，2014暑假集训中 8464 股票买卖 DP……预处理后缀最大值、最大获利、前缀最大值之类的求一下对应组合的max 8467 鸣人的影分身 同666 8471 切割回文 dp[i]表示s[1..i]最小需要的切割次数 8780 拦截导弹 LIS 8782 乘积最大 dp[i][j]表示前i个分成j份 8785 装箱问题 01背包 90 滑雪 DAG最长路 8786 方格取数 费用流/DP","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"openjudge","slug":"openjudge","permalink":"https://ir1d.cf/tags/openjudge/"},{"name":"dp","slug":"dp","permalink":"https://ir1d.cf/tags/dp/"}]},{"title":"openjudge补习","slug":"cssx/openjudge补习","date":"2018-05-25T05:07:23.000Z","updated":"2018-06-29T03:53:33.304Z","comments":true,"path":"2018/05/25/cssx/openjudge补习/","link":"","permalink":"https://ir1d.cf/2018/05/25/cssx/openjudge补习/","excerpt":"","text":"8758 2的幂次方表示 印象中什么时候好像调了好久的样子，其实就是直接递归的做就好了 整数划分 12345dp[0][0] = 1;g(i, 1, n) &#123; g(j, 1, i) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];&#125;// dp[i][j] 是i分成j份的方案数 zipper 问A和B两个串 能否交叉组合成C，要求AB内部相对顺序不变 dp[i][j] 表示A[1..i]和B[1..j] 能否拼成C[1..i+j] 转移就判一下最后一个字符是否匹配 复杂的整数划分问题 第一行: N划分成K个正整数之和的划分数目第二行: N划分成若干个不同正整数之和的划分数目第三行: N划分成若干个奇正整数之和的划分数目 ref: https://blog.csdn.net/tp7309/article/details/54880495 n划分成可相同的正整数 dp[i][j] 表示把i分成不超过j的数的和dp[i][j] = dp[i][j - 1] + dp[i - j][j]要么每个数都小于j，要么至少有一个等于j，把那个j去掉。 i &lt; j时 dp[i][j] = 0 边界：dp[0][0] = 1; 不相同 dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1]要么每个数都小于j，要么有一个数等于j，把唯一的那个j去掉，剩下的数都小于j了。 k个数 dp[i][j] 表示把i分成j份dp[i][j] = dp[i - j][j] + dp[i - 1][j - 1]要么给之前的j组每个数加一，要么取出来一个1单独装一组 i &lt; j时 dp[i][j] = dp[i][i] 边界：dp[0][i] = 1; 分成奇数 f[i][j] 表示i分成j个正奇数g[i][j] 分成正偶数 g[i][j] = f[i - j][j]偶数来自每一组奇数加一f[i][j] = f[i - 1][j - 1] + g[i - j][j]奇数来自偶数加一，或者最后一个1单独一组边界：f[0][0] = g[0][0] = 1 6047:切蛋糕 dp[i][j[k]表示i*j大小的切k块的答案（最大块面积的最小值） 转移的时候就枚举横竖的切法就可以了 123456789101112131415161718g(i, 1, 20) &#123; g(j, 1, 20) &#123; dp[i][j][1] = i * j; g(k, 2, 20) &#123; dp[i][j][k] = oo; f(r, 1, i) &#123; f(p, 1, k) &#123; dp[i][j][k] = std::min(dp[i][j][k], std::max(dp[r][j][p], dp[i - r][j][k - p])); &#125; &#125; f(c, 1, j) &#123; f(p, 1, k) &#123; dp[i][j][k] = std::min(dp[i][j][k], std::max(dp[i][c][p], dp[i][j - c][k - p])); &#125; &#125; &#125; &#125;&#125; 感觉比之前菜多了…… 重开几页补补题吧QAQ","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"openjudge","slug":"openjudge","permalink":"https://ir1d.cf/tags/openjudge/"}]},{"title":"程设算法上机练习小结","slug":"cssx/程设算法上机练习小结","date":"2018-05-19T13:16:05.000Z","updated":"2018-06-29T03:52:48.853Z","comments":true,"path":"2018/05/19/cssx/程设算法上机练习小结/","link":"","permalink":"https://ir1d.cf/2018/05/19/cssx/程设算法上机练习小结/","excerpt":"","text":"练习一 A:浮点数求高精度幂 正常的高精度快速幂，处理小数点的位置注意一下 B:Integer Inquiry 高精度加法 C:Communication System 每一类选一个使得最后的 最小带宽/总价格 最大 可以枚举最小的带宽是啥 然后贪心找价格最小的 dp的话dp[i][j]表示到第i类，带宽是j的答案 当时一直在想j的范围没给不是很好办，后来看代码发现开到1k就可以了 代码： https://github.com/Ir1d/Fantasy/blob/master/POJ/1018.cpp 注意 POJ 1018 得用 C++ 交，不知道为啥 D:判断闰年 if就好了 E:生理周期 枚举或者CRT F:完美立方 枚举 G:画家问题 枚举第一行的结果，然后之后的操作就确定了，找答案最小的就可以了 H:恼人的青蛙 枚举？ upd： 枚举 https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/ftall/c8.cpp I:放苹果 应该直接组合数吧？ dfs过了 J:古代密码 就是给每个字母的出现次序排个序看能不能对应上","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"https://ir1d.cf/tags/程设/"}]},{"title":"爬虫小结","slug":"爬虫小结","date":"2018-05-19T02:32:00.000Z","updated":"2018-05-19T02:35:14.446Z","comments":true,"path":"2018/05/19/爬虫小结/","link":"","permalink":"https://ir1d.cf/2018/05/19/爬虫小结/","excerpt":"","text":"爬虫小结 爬了个小站，其实对方主要是在防注入（？），并没有怎么反爬所以其实不太困难，美中不足的是写挂了好多地方，然后有懒得增量更新爬到的结果，所以反反复复算是爬了三次，给服务器带来了不少压力。 其实是第一次用py写模拟登录（惭愧） 首先是患者列表，在翻页的时候抓包发现没有请求，翻开发者工具发现是藏在IndexedDB里面，然后补习了一下导出的姿势 12345678910111213141516171819202122232425var db;var DB_NAME = '';var DB_VERSION = 1;var STORE_NAME = '';var request = indexedDB.open(DB_NAME, DB_VERSION);request.onupgradeneeded = function() &#123; // Create a new object store if this is the first time we're using // this DB_NAME/DB_VERSION combo. request.result.createObjectStore(STORE_NAME, &#123;autoIncrement: true&#125;);&#125;;request.onsuccess = function() &#123; db = request.result; // Enable our buttons once the IndexedDB instance is available.&#125;;var res;var transaction = db.transaction(STORE_NAME, 'readonly');var objectStore = transaction.objectStore(STORE_NAME);if ('getAll' in objectStore) &#123; // IDBObjectStore.getAll() will return the full set of items in our store. objectStore.getAll().onsuccess = function(event) &#123; res = event.target.result; &#125;;&#125; 然后就是常规操作，模拟登录什么的，然后有一个坑点是request库遇到302会跟着重定向过去，但是cookie没有存= = 解决方案是开个Session 12REQ = requests.Session()r = REQ.post(loginUrl, headers=header, data=payload) 对于Cookie的处理选择用dict，然后面向StackOverflow编程学习到了崭新的更新dict的操作 12dic = REQ.cookies.get_dict()cookie = &#123;**cookie, **dic&#125; 然后也学习到了从Chrome的工具里header变成python dict的方法和把dict变成Cookie串的方法= =回想当年自己真的是太naive了呀 1234567# Convert Chrome headers to Python's Requests dictionary dict([[h.partition(':')[0], h.partition(':')[2]] for h in rawheaders.split('\\n')])def gen(s): # Converts dict to cookie string res = \"\" for k in s: res += k + '=' + s[k] + ';' return res 以及regex中加个括号得到group可以只选中匹配出来的字符串的一部分，真的赞！ 捕捉异常的方法：123try:except Exception as e: logging.exception(\"message\") 创建文件夹： 123456if not os.path.exists('&#123;&#125;_res/&#123;&#125;'.format(CRAWL_ID, idx)): try: os.makedirs('&#123;&#125;_res/&#123;&#125;'.format(CRAWL_ID, idx)) except OSError as exc: # Guard against race condition if exc.errno != errno.EEXIST: raise # 套在 try except里面 下载图片： 1234photoRes = requests.get(curUrl, headers=newHeader)# if photoRes.status_code == 200:with open('&#123;&#125;_res/&#123;&#125;/&#123;&#125;.&#123;&#125;'.format(CRAWL_ID, idx, idNum, curName.split('.')[-1]), 'ab') as f: f.write(photoRes.content) 最后一个坑： 1photoNames = [x['picId'] for x in jsonRes['result'] if \"X光\" in str(x['tags'])] 注意到x[&#39;tags&#39;]可以是None 所以加上 str","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ir1d.cf/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://ir1d.cf/tags/爬虫/"}]},{"title":"程设语言部分笔记","slug":"cssx/程设语言部分笔记","date":"2018-05-19T02:27:43.000Z","updated":"2018-06-23T04:52:19.889Z","comments":true,"path":"2018/05/19/cssx/程设语言部分笔记/","link":"","permalink":"https://ir1d.cf/2018/05/19/cssx/程设语言部分笔记/","excerpt":"","text":"断更了好久…… 其实也说不清在忙什么…… 莫名其妙的…… 雾：下文内含大量typo（拼音输入法） OpenJudge - B:按距离排序 给struct重载() 来当比较器传给std::sort OpenJudge - G:你真的搞清楚为啥 while(cin &gt;&gt; n) 能成立了吗？ 123operator bool() &#123; // 重载强制类型转换&#125; 修改指针一定要小心，尤其是模板里面 *a = *b 注意指针指向的地址是否变了 是否只改变了值 OpenJudge - C:山寨版istream_iteratoroperator *() 重载解引用运算符 operator ++(int) 是后缀自增运算符 OpenJudge - E:很难蒙混过关的CArray3d三维数组模板类 写得很痛苦，的确没有蒙混过关，还是应该老实的…… 建议做法： a[i][j][k] 这个表达式的第一个[]返回一个内部类的对象，该内部类也重载了[],且返回值为指针。 必要时需重载对象到指针的强制类型转换运算符 OpenJudge - F:我自己的 ostream_iterator 刚开始一直在想怎么让他赋值进去就直接能输出，后来发现实际上是后面有一个++的过程，++的时候输出就好了。然后再就是*x=*a重载的是*运算符不是等号= = OpenJudge - A:List 简直惨痛。。。 merge自己到自己的操作要忽略掉就好了= = 果然还是应该写对拍 OpenJudge - F:冷血格斗场 听说是当年pkusc的题，就是找lowerbound 然后再找前面的一个 比较比较就好了 没考虑到的地方是可能lowerbound的前面找到的那个并不是id最小的，要再lowerbound一下= = OpenJudge - 08:编程填空：维护平面点 OpenJudge - H:编程填空：数据库内的学生信息 比较器的写法 123456789template &lt;class T&gt;struct Greater &#123; bool operator() (const T&amp; x, const T&amp; y) const &#123; return x &gt; y; &#125; typedef T first_argument_type; typedef T second_argument_type; typedef bool result_type;&#125;; upd：重写了 后三个typedef 不是必须的OpenJudge - 11:编程填空：数据库内的学生信息 太难了= = static的初始化方式 printf — %x 十六进制 期中复习 常引用：不是引用的内容不能修改，是不能通过常引用修改const T 或者 const T &amp;类型不能用来初始化 T&amp;类型，除非经过了强制类型转换调用内联函数的语句前必须已经出现内联函数的定义（整个函数体），不能只有声明同名函数只有参数表不同才算是重载，两个同名函数的参数表相同而返回值不同不是重载，是重复定义new分配的空间一定要delete释放，否则程序运行结束后也不会被系统收回一个string对象的大小（sizeof）是固定的（在不同编译器中并不相同，与字符串长度无关）string对象中只存放地址和其他信息大写字母ASCII码小于小写字母struct默认公有，class默认私有局部变量存储空间是动态分配在栈中的CTest* pArray[3] = {new CTest(4), new CTest(1, 2)}; 只生成了两个对象，第三个没有生成复制构造函数的参数一般用const引用，这样既能以常量对象，也能以非常量对象作为参数函数的参数对象以及作为函数返回值的对象，在消亡时也会引发析构函数调用12345678910CDemo::CDemo(int a, int b) &#123;// 构造函数&#125;CDemo dl;CDemo Test() &#123; // 返回值是临时对象 foo(); return dl;&#125;CDemo d4;d4 = 6; // 这里6先被转换成临时对象，然后再赋值。语句执行完毕后临时对象消亡，调用析构函数 并非所有对象生成的时候都通过上面的构造函数初始化，作为参数和返回值的时候是调用复制构造函数，需要另外再写不能通过对常量对象调用普通成员函数，但是可以调用const的两个成员函数的名字和参数表相同，但是一个const，另一个不是，算重载封闭类生成的时候先执行所有成员对象的构造函数，再执行封闭类自己的构造函数消亡的时候是先执行封闭类的析构函数，后执行成员对象的。常量型成员变量和引用型必须要在构造函数的初始化列表中初始化友元函数内部可以访问该类对象的private不能吧其他类的私有成员函数声明为友元交叉调用的时候允许写一个提前声明class s;但是在定义出现之前，不允许任何会导致该类对象被生成的语句。使用该类的指针或者引用是没有问题的可以声明另一个类是自己的友元友元关系不能传递类的非内联成员函数的函数体只能出现在某一个.cpp文件中，不能放在头文件中被多个.cpp文件包含，否则链接时会发生重复定义的错误如果编写了构造函数，则编译器不自动生成默认构造函数，一个类不一定会有默认（无参）构造函数，但是一定会有复制构造函数=只能重载为成员函数在delete之前判断是否是NULL注意赋值给自己的时候的指针的处理参数os只能是ostream的引用，而不能使ostream对象，是因为ostream的复制构造函数是私有的，不能生成参数对象类型强制转换运算符是单目运算符，只能被重载为成员函数 operator double() {}++a或者--a前置：CDemo&amp; operator ++();a++或者a--后置：CDemo operator ++(int);运算符重载不改变优先级不能被重载的运算符：. .*（成员指针访问运算符） :: ?: sizeof重载() [] -&gt;或者 赋值=时，只能重载为成员函数派生类的成员函数只能访问所作用的那个对象（this指向的）的基类保护成员，不能访问其他基类对象的基类保护成员如果一个派生类对象使用默认复制构造函数初始化的，那么他内部包含的基类对象也要用基类的复制构造函数初始化封闭类类似派生类对象生成的时候，先从上至下执行所有基类的构造函数，再按照成员对象的定义顺序执行各个成员对象的构造函数，最后执行自身的消亡时，先执行自身的，后面与够早的次序相反如果是public派生，派生类对象也是基类对象，如果是private或者protected，就不成立多态的函数调用语句被称为是动态联编的虚函数表的地址在对象存储空间的最前端成员函数（静态成员函数、构造函数、析构函数除外）中调用其他虚成员函数是多态的析构函数和构造函数中调用的虚函数不是多态只要基类中的某个函数被声明成虚函数，则派生类中的同名、同参数表的成员函数及时前面没写virtual也是虚函数虚析构函数：只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual声明，都是虚析构函数一个类如果定义了虚函数，则最好将析构函数也定义成虚函数独立的抽象类的对象不存在，但是被包含在派生类对象中的抽象类的对象是可以存在的抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能cerr clog 不能被重定向cerr 不使用缓冲区 clog 使用while (cin &gt;&gt; n) 是因为把ostream到bool的转换重载了 顺序容器：vector, deque, list关联容器：set, multiset, map, multimap容器适配器：stack, queue, priority_queuerend():只想容器中的第一个元素前面的位置的反向迭代器1for (auto it = v.rbegin(); it != v.rend(); ++it); 容器 迭代器功能 vector 随机 deque 随机 list 双向 set/ multiset 双向 map/ multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器 12345ostream_iterator&lt;int&gt; output(cout,\" \");copy (v.begin(), v.end(), output);std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dest1)); 考完试： 1234567template&lt;class T, int sz&gt;class A &#123; public: static int c;&#125;;template &lt; &gt; int A &lt;int, 40&gt;::c = 0;template &lt; &gt; int A &lt;int, 50&gt;::c = 1; const算不算重载什么时候需要在初始化列表里初始化","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"程设","slug":"程设","permalink":"https://ir1d.cf/tags/程设/"},{"name":"C++","slug":"C","permalink":"https://ir1d.cf/tags/C/"}]},{"title":"efb转发微信消息到tg","slug":"efb转发微信消息到tg","date":"2018-03-10T15:57:50.000Z","updated":"2018-06-23T04:50:32.629Z","comments":true,"path":"2018/03/10/efb转发微信消息到tg/","link":"","permalink":"https://ir1d.cf/2018/03/10/efb转发微信消息到tg/","excerpt":"","text":"折腾很多坑 在NanoApe指点下得知应该装v1.6.6 然后就很好办啦 ref: https://konano.github.io/2018/02/17/EFB-use/ upd(2018.5.19): 经常掉线 其实很不好用= =","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"ehForwarderBot","slug":"ehForwarderBot","permalink":"https://ir1d.cf/tags/ehForwarderBot/"},{"name":"telegram","slug":"telegram","permalink":"https://ir1d.cf/tags/telegram/"}]},{"title":"安装wxPython","slug":"安装wxPython","date":"2018-02-28T23:55:54.000Z","updated":"2018-06-23T04:47:38.430Z","comments":true,"path":"2018/03/01/安装wxPython/","link":"","permalink":"https://ir1d.cf/2018/03/01/安装wxPython/","excerpt":"","text":"你可能需要这个【 https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560 甚至可能需要手动编译整个wxwidgets","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"wxPython","slug":"wxPython","permalink":"https://ir1d.cf/tags/wxPython/"}]},{"title":"telegram-bots","slug":"telegram-bots","date":"2018-02-24T03:49:44.000Z","updated":"2018-06-23T04:46:57.857Z","comments":true,"path":"2018/02/24/telegram-bots/","link":"","permalink":"https://ir1d.cf/2018/02/24/telegram-bots/","excerpt":"","text":"写 Telegram bot 的时候遇到了问题，一直在纠结为什么我的 bot 需要 /asdf@bot 而不是 /asdf 就行= = 最后发现问题在这里：https://core.telegram.org/bots#privacy-mode 官方API：https://core.telegram.org/bots/api 一些现成的整理：https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets 以及 TG bot 传文件大小是50M= = 图片是10M","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"telegram","slug":"telegram","permalink":"https://ir1d.cf/tags/telegram/"}]},{"title":"机器学习记录","slug":"机器学习记录","date":"2018-02-09T08:03:20.000Z","updated":"2018-06-23T04:47:43.635Z","comments":true,"path":"2018/02/09/机器学习记录/","link":"","permalink":"https://ir1d.cf/2018/02/09/机器学习记录/","excerpt":"","text":"[done] Andrew NG coursera 机器学习 cs229 https://see.stanford.edu/course/cs229 UFLDLUFLDL2西瓜书《机器学习》 机器学习实战 机器学习基石（林轩田）机器学习技法 李宏毅 配合着台湾林轩田的《机器学习基石+技法》把李航的《统计学习方法》这本书走一遍 http://speech.ee.ntu.edu.tw/~tlkagk/courses.htmlhttps://www.youtube.com/channel/UC2ggjtuuWvxrHHHiaDH1dlQ/playlists 花书 Neural Network for Machine Learning-coursera-多伦多大学 cs224n cs231n Neural Networks for NLP http://neuralnetworksanddeeplearning.com/chap1.html deeplearning http://speech.ee.ntu.edu.tw/~tlkagk/courses.htmlhttp://blog.csdn.net/zouxy09/article/details/8775360https://www.cs.ox.ac.uk/people/nando.defreitas/machinelearning/ drl CS 294 MIT 6.S191 (bilibili未搬运) https://www.youtube.com/watch?v=JN6H4rQvwgY&amp;index=1&amp;list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI David Silver https://www.coursera.org/specializations/machine-learning deeplearning.ai coursera http://gameaibook.org 《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》Machine Learning A Probabilistic Perspective Learning http://deeplearning.net/reading-list/","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://ir1d.cf/tags/机器学习/"}]},{"title":"2017小结","slug":"notes/2017小结","date":"2018-02-08T04:11:09.000Z","updated":"2018-06-23T04:49:37.255Z","comments":true,"path":"2018/02/08/notes/2017小结/","link":"","permalink":"https://ir1d.cf/2018/02/08/notes/2017小结/","excerpt":"","text":"今天小年偶然看到学妹发的WC2018的节目，发现时间原来过得好快这三年WC上24OI都有节目，也算是很妙的一件事吧 好在一届更比一届强，并非不务正业XD本来以为都忘记了的事，突然发现原来记得清清楚楚翻了翻知乎上几个OI相关的问题，pyc问的时候我还是个上台拿衣服的孩子吧= =转眼间，大半的答主都不认识了高三一年下来，不那么跳了，写了很久的很长的东西，却还是完全没有剖析清楚内心出了些意外，不过还好无大碍高考还算可以，靠着pkusc的运气还是混进了园子还是很喜欢你可能每次写回忆录写得都是一篇流水 也并没有什么特别值得叙说的事就当是结局圆满吧2018 愿安 希望可以变得自信点愿大家诸事顺遂，永远行走在光明向上的路上。","categories":[{"name":"回忆录","slug":"回忆录","permalink":"https://ir1d.cf/categories/回忆录/"}],"tags":[]},{"title":"20180206comments","slug":"notes/20180206comments","date":"2018-02-06T14:24:42.000Z","updated":"2018-06-23T04:49:42.947Z","comments":true,"path":"2018/02/06/notes/20180206comments/","link":"","permalink":"https://ir1d.cf/2018/02/06/notes/20180206comments/","excerpt":"","text":"高中同学聚会，见到大家其实很开心 有人喝酒 听到了不少劲爆的消息 有个老哥还喝醉了 喝醉的老哥感觉很爱面子 一直反复在说高考 是梦魔吧……sigh 愿安 很容易就想起你了","categories":[{"name":"回忆录","slug":"回忆录","permalink":"https://ir1d.cf/categories/回忆录/"}],"tags":[]},{"title":"cprimerplus","slug":"cprimerplus","date":"2018-02-05T14:10:39.000Z","updated":"2018-06-23T04:50:36.553Z","comments":true,"path":"2018/02/05/cprimerplus/","link":"","permalink":"https://ir1d.cf/2018/02/05/cprimerplus/","excerpt":"","text":"八进制 023 %o %lo 十六进制0xdbf %x %lx &#39;\\007&#39;, &#39;\\07&#39;, &#39;\\7&#39;都是八进制表示 3.4l表示使数字成为long double类型，默认是double c只保证float有6位精度 当缓冲区满、遇到换行符、需要输入的时候刷新缓冲区 或者使用fflush()函数 %p输出指针 %% 百分号 %5.2f是字符宽度为5，小数点后2位的浮点数 %10d是右对齐 %-10d是左对齐 printf返回值是输出成功的个数printf的float和double都是%f而scanf的float是%fdouble是%lf","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"C","slug":"C","permalink":"https://ir1d.cf/tags/C/"}]},{"title":"bsgs","slug":"bsgs","date":"2018-01-28T04:06:16.000Z","updated":"2018-06-23T04:49:58.592Z","comments":true,"path":"2018/01/28/bsgs/","link":"","permalink":"https://ir1d.cf/2018/01/28/bsgs/","excerpt":"","text":"BSGS 可以用来求离散对数 http://kzoacn.is-programmer.com/posts/97193.html http://blog.csdn.net/FromATP/article/details/56013530 注意朴素的 BSGS 要求 a 和 c 互质 POJ 2471 用 map 很容易 TLE ，手动开 -O2 过的 #pragma GCC optimize(&quot;O2&quot;)交G++ 扩展BSGS是不断提取a和c的公因子直到互质 http://blog.csdn.net/clove_unique/article/details/51227328 简易hash= =把冲突的往后一个位置堆直到不冲突= =","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"BSGS","slug":"BSGS","permalink":"https://ir1d.cf/tags/BSGS/"}]},{"title":"矩阵乘法小优化","slug":"矩阵乘法小优化","date":"2018-01-27T23:56:59.000Z","updated":"2018-06-25T15:00:01.811Z","comments":true,"path":"2018/01/28/矩阵乘法小优化/","link":"","permalink":"https://ir1d.cf/2018/01/28/矩阵乘法小优化/","excerpt":"看叉姐的repo翻到矩阵相关的板子","text":"看叉姐的repo翻到矩阵相关的板子 然后发现里面有这样一句话 乘法的时候将$B$数组转置一下然后$C[i][j] = \\sum{A[i][k]\\times B[j][k]}$会有奇效。 然后操作了一番发现的确是这么回事 Qrz%%% 1234567891011121314srand(time(0));f(i, 0, 233) f(j, 0, 233) a[i][j] = rand(), b[i][j] = rand();double st = clock();f(i, 0, 233) f(j, 0, 233) f(k, 0, 233) c[i][j] += a[i][k] * b[k][j];double ed = clock();f(i, 0, 233) f(j, 0, 233) &#123; d[i][j] = b[j][i]; c[i][j] = 0;&#125;f(i, 0, 233) f(j, 0, 233) f(k, 0, 233) c[i][j] += a[i][k] * d[j][k];double e2 = clock();printf(\"%lf\\n\", ((e2 - ed) - (ed - st)) / CLOCKS_PER_SEC);printf(\"%d\\n\", CLOCKS_PER_SEC); 本机大概能差0.02s 以及惊讶地发现CLOCKS_PER_SEC在新电脑上是1e6了","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://ir1d.cf/tags/矩阵乘法/"}]},{"title":"大连六重","slug":"大连六重","date":"2018-01-27T23:28:40.000Z","updated":"2018-06-24T13:00:59.045Z","comments":true,"path":"2018/01/28/大连六重/","link":"","permalink":"https://ir1d.cf/2018/01/28/大连六重/","excerpt":"https://www.jianshu.com/p/d4881b876b8a","text":"https://www.jianshu.com/p/d4881b876b8a 忙了20多天组织完这个六重 也不知道是否值得 就当是神奇的经历吧 感谢大家的帮助 当天赶完了战报 想了好多 写起来感觉大学国文真的是白学了QAQ 准备的过程和出锅的时候甚至是满满的无力感 有种那年NOI的时候的flashback 可我怎么就没想到呢= = 不过好在是在大连做的 我们甚至可以拆了补一补做成正儿八经的六重 表白大连蓝军 2018.1.27.12:51 - 2018.1.28 14:42","categories":[{"name":"Ingress","slug":"Ingress","permalink":"https://ir1d.cf/categories/Ingress/"}],"tags":[{"name":"竹笋","slug":"竹笋","permalink":"https://ir1d.cf/tags/竹笋/"},{"name":"大连","slug":"大连","permalink":"https://ir1d.cf/tags/大连/"}]},{"title":"离散数学基础笔记","slug":"离散数学基础笔记","date":"2018-01-25T11:34:07.000Z","updated":"2018-06-23T04:52:44.237Z","comments":true,"path":"2018/01/25/离散数学基础笔记/","link":"","permalink":"https://ir1d.cf/2018/01/25/离散数学基础笔记/","excerpt":"","text":"完美的数学终于“自我相关”数理逻辑 — 用计算的方法代替人们思维中的逻辑推理过程命题演算、谓词演算悖论不能作为命题 — 真值不存在 — “这句话是错的”命题非真即假 — 这是个基本假设排中律 — 具有属性 / 不具有属性反证法就是利用的排中律 — 非假即真有穷事物可以逐个验证来判断真假 — 但是无穷事物无法逐一检验原子命题、复合命题、逻辑连接词形式化的第一步 — 抽象 — 仅关注命题的本质属性（真值）异或 — p xor q == $(p \\land \\lnot q) \\lor (\\lnot p \\land q)$p 蕴含 q — 仅在 p真q假 时为假命题公式用来把真值连接 可以看做是一个真值函数自然语言命题的形式化 — 经过抽象形式化为命题公式假言易位 — 逆否命题 — $a\\to b &lt;=&gt; \\lnot b \\to \\lnot a$归谬论 — $(a\\to b) \\land (a\\to \\lnot b) &lt;=&gt; \\lnot a$重言式代入原理 — 将重言式A的某个变元p替换为B 仍然是重言式命题公式的替换原理 — 将子公式的部分出现替换为逻辑等价的公式 得到的新命题公式和原来的逻辑等价证明逻辑等价式和逻辑蕴含式 — 真值表法、对赋值进行讨论、推演法（利用已知的，运用代入原理和替换原理）范式 — 把蕴含这个连接词去掉范式用于重言式和矛盾式的识别重言式识别：合取范式的每个析取子句都包含了至少一个互补文字对矛盾式识别：析取范式的每个析取子句都包含了至少一个互补文字对p蕴含q 利用蕴含等值式变成 $\\lnot p \\lor q$p双向蕴含q 利用等价等值式变为$(\\lnot p \\lor q)\\land(p \\lor \\lnot q)$或者$(p\\land q) \\lor (\\lnot p\\land\\lnot q)$利用德摩根律把否定词放到括号里（作用于文字）最后再用分配律一个公式的析取范式或合取范式都不是唯一的析取范式也可以同时是合取范式最为规范的范式 — 唯一性 — 主范式主析取范式 — 每个合取子句均恰好出现一次主合取范式 — 每个析取子句均恰好出现一次极小项只有唯一的成真赋值主析取范式包含的极小项的成真赋值也是主析取范式的成真赋值具有相同主析取范式的公式是等值的 — 属于同一个等值类主合取范式对应极大项和成假赋值等值类与真值函数一一对应功能完备集去掉冗余连接词得到极小的功能完备集 — 可以表示所有的真值函数Peirce记号 — $p \\downarrow q = \\lnot (p \\lor q)$形式系统 — 符号体系证明是演绎在公式集合为空集的时候的特例命题演算形式系统(PC)的公理 $A1:A\\to (B\\to A)$ $A2:(A\\to (B\\to C))\\to ((A\\to B)\\to (A\\to C))$ $A3:(\\lnot A\\to \\lnot b)\\to (B\\to A)$ 推理规则 — 分离规则$A, A\\to B / B$ 即A成立且已知A蕴含B时可以得到B成立PC的定理 — 有一个证明序列 — 是重言式演绎结果 — 存在演绎结果元（meta）定理 演绎公理 — $\\gamma \\vdash A \\to B \\iff \\gamma \\bigcup {A} \\vdash B$ 归谬定理 — $\\gamma \\bigcup {\\lnot A} \\vdash B, r \\bigcup {\\lnot A} \\vdash \\lnot B$，那么$\\gamma \\vdash A$ 穷举定理 — $\\gamma \\bigcup {\\lnot A} \\vdash B, \\gamma \\bigcup {A} \\vdash B$，那么$\\gamma \\vdash B$成立","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"https://ir1d.cf/tags/离散数学/"},{"name":"MOOC","slug":"MOOC","permalink":"https://ir1d.cf/tags/MOOC/"}]},{"title":"ubuntu视频加速","slug":"ubuntu视频加速","date":"2018-01-20T10:14:35.000Z","updated":"2018-06-23T04:47:26.718Z","comments":true,"path":"2018/01/20/ubuntu视频加速/","link":"","permalink":"https://ir1d.cf/2018/01/20/ubuntu视频加速/","excerpt":"","text":"mplayer -af scaletempo 用[和]控制速度 scaletempo是防止走音","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ir1d.cf/tags/ubuntu/"}]},{"title":"ubuntu16.04安装pycaffe","slug":"ubuntu16-04安装pycaffe","date":"2018-01-18T08:44:44.000Z","updated":"2018-06-23T04:47:06.917Z","comments":true,"path":"2018/01/18/ubuntu16-04安装pycaffe/","link":"","permalink":"https://ir1d.cf/2018/01/18/ubuntu16-04安装pycaffe/","excerpt":"","text":"https://github.com/BVLC/caffe/wiki/Ubuntu-16.04-or-15.10-Installation-Guide 装pycaffe的时候要改Makefile.config的很多地方= = http://caffe.berkeleyvision.org/installation.html#python https://gist.github.com/titipata/f0ef48ad2f0ebc07bcb9","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ir1d.cf/tags/ubuntu/"},{"name":"caffe","slug":"caffe","permalink":"https://ir1d.cf/tags/caffe/"}]},{"title":"程设笔记","slug":"cssx/程设笔记","date":"2018-01-16T01:46:37.000Z","updated":"2018-06-23T04:52:05.440Z","comments":true,"path":"2018/01/16/cssx/程设笔记/","link":"","permalink":"https://ir1d.cf/2018/01/16/cssx/程设笔记/","excerpt":"","text":"函数指针命令行参数位运算引用 - 引用作为函数的返回值不可通过常量指针修改其指向的内容动态分配空间内联函数、函数重载、缺省参数缺省参数可以在扩充函数参数是避免对原有的调用语句的修改类、成员函数、内联成员函数构造函数析构函数静态成员 — 全局 — 易于维护成员对象 — 封闭类友元函数、友元类 友元类关系不能传递、不能继承this指针比如有一个class C12C *p = NULL;p-&gt;magic(); 等价于12C *p = NULL;magic(p); 如果后一种语句合法那么前一种就合法常量对象常亮成员函数不应修改对象，也不能调用非常亮成员函数（静态除外）常引用避免构造函数的开销=返回值最好为引用 复制构造函数也要避免浅拷贝运算符可以重载为友元函数继承、派生继承关系、复合关系protected虚函数、多态 virtual关键字构造函数和析构函数中调用虚函数不是多态虚函数表会占用空间也有额外的时间开销 — 多态的函数调用过程是查询虚函数表一个基类的指针删除派生类对象的时候希望先调用派生类析构函数再调用基类的析构函数不允许虚函数作为构造函数抽象类中成员函数允许调用纯虚函数，但是构造函数、析构函数中不允许函数模板 — 泛型程序设计STL123std::ostream_iterator&lt;int&gt; output(std::cout, \" \");std::copy(a.begin(), a.end(), output);// 相当于是用 cout 输出 a 里面的元素，用空格分隔开 copy到vector的时候它不会自动扩空间智能指针 shared_ptr 不能托管数组的指针不能取地址的表达式是右值lambda表达式强制类型转换异常 八数码中不改变排列的奇偶性","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"https://ir1d.cf/tags/程设/"}]},{"title":"git代理","slug":"git代理","date":"2018-01-13T08:01:05.000Z","updated":"2018-06-23T04:46:27.635Z","comments":true,"path":"2018/01/13/git代理/","link":"","permalink":"https://ir1d.cf/2018/01/13/git代理/","excerpt":"","text":"123git config --global http.proxy socks5://127.0.0.1:1080git config --global --unset http.proxy","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ir1d.cf/tags/git/"},{"name":"代理","slug":"代理","permalink":"https://ir1d.cf/tags/代理/"}]},{"title":"ubuntu下解压文件乱码解决","slug":"ubuntu下解压文件乱码解决","date":"2017-11-23T10:03:33.000Z","updated":"2018-06-23T04:47:18.486Z","comments":true,"path":"2017/11/23/ubuntu下解压文件乱码解决/","link":"","permalink":"https://ir1d.cf/2017/11/23/ubuntu下解压文件乱码解决/","excerpt":"","text":"rar卸掉 unrar-free 安装 p7zip p7zip-full zipunzip -O GBK filename","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ir1d.cf/tags/ubuntu/"},{"name":"解压","slug":"解压","permalink":"https://ir1d.cf/tags/解压/"}]},{"title":"icpc2017北京站","slug":"icpc2017北京站","date":"2017-11-20T12:10:54.000Z","updated":"2017-11-20T12:31:55.732Z","comments":true,"path":"2017/11/20/icpc2017北京站/","link":"","permalink":"https://ir1d.cf/2017/11/20/icpc2017北京站/","excerpt":"转自知乎","text":"转自知乎 如何评价？大概就是震惊！竟然在体育馆里走了60k步！ 很长时间一直在想是为什么要做这些事情 可能是因为会沾上光有大量的太阳卡 可能是因为有机会近距离向大佬掉头 可能是因为被女队圈粉 …… 后来感觉 可能是因为我也曾和你们一样吧 =_+ 我也曾对某些事情抱有十足的热情 但是如今却没有勇气了 看到各位 就好像自己真的也在赛场上潇潇洒洒 感谢大家这次精彩的区域赛 接了很多锅，后来解决了大部分也还是很妙的 各种bug似乎也没什么需要说明的【都过去啦 补：封榜后的气球嘛，到时间的时候现场的老师说不发了，后来好像裁判组老师过来要求发的。并不是志愿者自作主张鸽掉了气球 &gt;_&lt; 首先感谢科协主席郑学长，表面上看他只是主持抽奖环节，其实是他协调安排了大部分工作。 感谢小句读老师、卿学姐解答窝奇怪的问题。 感谢志愿者、工作人员的努力和大家的配合。 最后，希望wf可以工作组织更合理我们真的可以办好XD 话说， 本来说好十点炸群，其实是我找不到怎么解散群才拖了辣么久= = 匿了 祝大家今后顺利 后会有期 永远相信美好的事情即将发生","categories":[{"name":"回忆录","slug":"回忆录","permalink":"https://ir1d.cf/categories/回忆录/"}],"tags":[{"name":"icpc","slug":"icpc","permalink":"https://ir1d.cf/tags/icpc/"}]},{"title":"opencv作业笔记","slug":"Opencv","date":"2017-11-11T16:50:36.000Z","updated":"2018-06-23T04:46:36.360Z","comments":true,"path":"2017/11/12/Opencv/","link":"","permalink":"https://ir1d.cf/2017/11/12/Opencv/","excerpt":"","text":"计算概论花了一课时讲了下opencv 但是配置作业环境废了好大劲 最后放弃了vs的项目 而是转用ubuntu下直接安装opencv linux下边的安装看这个链接就好= = https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://ir1d.cf/tags/opencv/"}]},{"title":"travis调试笔记","slug":"travis调试笔记","date":"2017-11-10T18:36:03.000Z","updated":"2018-06-23T04:47:02.969Z","comments":true,"path":"2017/11/11/travis调试笔记/","link":"","permalink":"https://ir1d.cf/2017/11/11/travis调试笔记/","excerpt":"下午用TravisCI来实现自动部署到Github Release，踩了不少坑","text":"下午用TravisCI来实现自动部署到Github Release，踩了不少坑 after_script 是在 deploy 段结束之后执行的，after_success 或者 before_deploy 是在 deploy 之前，文档里面写得很清楚 别的文章里大多写得很详细，就是不能把自己 Github 账号的 Access Token 给 push 到 repo 里。我当时 push 的时候没有注意到加了进去，不过收到了 Github 的邮件说检测到 Token 被泄露，当前这个被自动注销掉了。 推荐使用travis setup releases 来完成.travis.yml的deploy部分的编写 1sudo gem install travis -v 1.8.8 --no-rdoc --no-ri 两步验证也是个坑，简而言之就是用上边这个travis工具来写deploy部分，不要去自己到处生成Token。记得选那个secure key。 如果build的时候出现HEAD detached 应该是需要在deploy里面加上skip_cleanup: true，不清楚为什么那个工具不能自己加上。 on tags: true的作用是只对打tag的build进行deploy操作 如果需要sudo要加上sudo: enabled 检查yml写得对不对可以去 http://lint.travis-ci.org/ 话说一个build是没有时间限制的，只不过如果长时间没有输出或者类似状况会被停掉 以及build是可以设置成定时进行的，要注意的地方是Github对一次commit的状态更新次数有限制，并不能无限制地 大概就这些 有点记不清了 反正还有问题可以再问嘛","categories":[{"name":"操作","slug":"操作","permalink":"https://ir1d.cf/categories/操作/"}],"tags":[{"name":"travis","slug":"travis","permalink":"https://ir1d.cf/tags/travis/"}]},{"title":"教学计划整理-文科","slug":"collections/教学计划整理-文科","date":"2017-09-29T14:57:44.000Z","updated":"2017-10-12T14:44:41.595Z","comments":true,"path":"2017/09/29/collections/教学计划整理-文科/","link":"","permalink":"https://ir1d.cf/2017/09/29/collections/教学计划整理-文科/","excerpt":"","text":"中文系汉语言文学专业历史学系世界史专业外国语学院法语专业精读 视听说 历史 国家的地区概况 笔译 口译 报刊选读 写作 文体学 语法 英语专业文学史 普通语言学 精读 写作 视听 口语 …… 还有好多 Qrz 艺术学院没找到美术 Qrz 经济学院学科基础课 数学 高数线代概统 经济 经济学原理 微观宏观经济学 计量经济学 太多了 就不整理了 只是一点缥缈的兴趣 在如山的作业和无尽的期许面前 加油 说不定就真的成了一名理论计算机科学家","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"https://ir1d.cf/tags/课程整理/"}]},{"title":"教学计划整理-理科","slug":"collections/教学计划整理-理科","date":"2017-09-29T13:43:41.000Z","updated":"2017-10-12T14:44:41.587Z","comments":true,"path":"2017/09/29/collections/教学计划整理-理科/","link":"","permalink":"https://ir1d.cf/2017/09/29/collections/教学计划整理-理科/","excerpt":"","text":"教学计划包括四部分： 公共与基础课、核心课程、限选课程、通识与自主选修课程 公共与基础课包括全校公共必修课和学科基础课程；核心课程指以该专业中最核心的理论和技能为内容的课程；限选课程包括原部分专业必修课、专业限选课程、跨院系课程；通识与自主选修课程包括专业选修课、本科生科研训练、跨院系课程或院系自主设立的其他课程模块 数院数学与应用数学分基础数学方向（宽口径），金融数学方向保研要求 基础数学9门选修课在三年级结束时完成5门 金融数学要求所有必选课 基础：突变函数、泛函分析、偏微分方程、拓扑学、微分几何、微分流形、数论基础、群与表示、基础代数几何 金融：数理统计、金融数学引论、应用随机过程、寿险精算、证券投资学、衍生证券基础 限选中选修1门：突变与泛函（或实变函数）、金融经济学、金融数据分析导论、非寿险精算、风险理论、应用随机分析 统计学概率论方向（可分流到数学与应用数学专业）必选：数理统计、应用随机过程 限选：实变函数、应用多元统计分析、偏微分方程、微分几何、测度论、应用随机分析、泛函分析、应用回归分析、拓扑学 统计学方向专业必选：数理统计、应用随机过程 限选：应用回归分析、抽样调查、实验设计、贝叶斯统计、应用多元统计分析、应用时间序列分析、统计学习、统计计算、非参数统计 生物统计学方向（可按照应用统计学专业审核学生毕业）必选：数理统计、应用回归分析 限选：贝叶斯统计、应用多元统计分析、应用时间序列分析、统计学习、统计计算、非参数统计、应用生存分析、生物信息学方法和应用、应用随机过程 保研准备略去 信息与计算科学计算数学方向必选：数值分析、数值代数 限选：突变函数、泛函分析、最优化方法、偏微分方程、流体力学引论、偏微分方程数值解、大数据分析中的算法 信息科学必选：信息科学基础、理论计算机科学基础、数理逻辑、集合论与图论、数字信号处理 限选：程序设计技术与方法、密码学、计算机图形学、计算机图像处理、软件工程、操作系统、数据库概论、算法设计与分析、信息安全、人工智能、机器学习 这还要信科有什么用。。。 数据科学与大数据必选：数理统计、应用多元统计分析 限选：突变函数、应用回归分析、贝叶斯统计、应用时间序列分析、统计计算、统计学习或机器学习、程序设计实习、数据结构与算法、并行程序设计原理、数据整合与清理、算法设计与分析、数据库概论、自然语言处理导论、数据库仓库与数据挖掘、最优化方法或凸优化 信科 有纸质版的所以略过元培（跨学科类）数据科学与大数据技术专业核心：数据科学导引、概率论、数理统计、数值与计算方法、分布与并行计算、人工智能、深度学习、统计机器学习、大数据分析中的算法、最优化方法或者凸优化","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"https://ir1d.cf/tags/课程整理/"}]},{"title":"通识教育整理-理科","slug":"collections/通识教育整理-理科","date":"2017-09-29T06:01:05.000Z","updated":"2017-10-12T14:44:41.578Z","comments":true,"path":"2017/09/29/collections/通识教育整理-理科/","link":"","permalink":"https://ir1d.cf/2017/09/29/collections/通识教育整理-理科/","excerpt":"","text":"数学科学学院高等代数《高等代数》 北京大学数学力学系几何与代数教研室代数小组 抽象代数《抽象代数》 赵春来《代数学引论》 丁石孙 几何学《解析几何》 尤承业《解析几何》 丘维声 概率论《概率论》 何书元 《概率论引论》 汪仁官 《随机数学》钱，敏平 叶俊 《概率论基础》 李贤平 复变函数《复变函数》 谭小江 伍胜健Complex Analysis, Ahlfors L.V, 《简明复分析》 龚升 常微分方程《微分方程定性理论》 丁同仁 数学模型《数学模型讲义》 雷功炎 物理学院数学物理方法《数学物理方法》 吴崇试《数学物理方法习题集》 武仁Advanced Calculus for Applications, F.B.Hildebrand 理论力学《理论力学》 刘川Classical Mechangics, Herbert GoldsteinMechanics, L.D.Landau and E.M.Lifshitz 热力学与统计物理《热力学统计物理》 汪志诚《热力学与统计物理学》 林宗涵 平衡态统计物理// 同上 电动力学《电动力学简明教程》 俞允强 量子力学《量子力学导论》 曾谨言 固体物理学《固体物理学》 韩汝琦 《固体物理基础》 阎守胜 近代物理实验《近代物理实验》 吴思 核物理与粒子物理专题实验《辐射物理》 丁富荣 《核物理实验方法》 吴治华 前沿物理实验综合物理实验激光实验《激光实验》 北京大学物理学院基础物理教学实验中心 北京大学物理学院光学所 激光实验教学组 计算物理学《数值分析与算法》 喻文健《数值分析》 李庆扬 基础天文《天文学新概论》 苏宜 《天文学教程》 胡中为Fundamental Astronomy 天体物理《天体物理导论》 徐仁新 宇宙探测新技术引论Principles of Long Baseline Stellar Interferometry Ed. By P.R.LawsonInterferometry and Synthesis in Radio Astronomy A.R.Thompson 化院生科城环地空跳过Qrz心理与认知科学学院普通心理学《心理学与生活》 格里格·津巴多 心理统计《心理与行为科学统计》 甘怡群，张轶文，邹玲《现代心理与教育统计学》 张厚璨 社会心理学《社会心理学》 戴维·迈尔斯 实验心理学《实验心理学》 朱滢 心理测量Psychological testing: principles, applications, and issues 《心理学论文写作规范》 Handbook of Psychological Assessment 发展心理学《发展心理学：探索人生发展的轨迹》《发展心理学——人的毕生发展》 生理心理学Physiology of Behavior 认知心理学《认知心理学》 组织管理心理学《组织管理心理学》王垒 变态心理学《变态心理学》钱铭怡 信科数学分析信息科学技术概论程序设计实习数据结构与算法集合论与凸轮《离散数学教程》 耿素云 计算机系统导论csapp 代数结构与组合数学《离散数学教程》 Fundamental Approach oto Discrete Mathematics Discrete Mathematics Structures 算法设计与分析计算机组成与系统结构实习概率论与随机过程数学物理方法概率统计量子力学工学院环科跳过","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"https://ir1d.cf/tags/课程整理/"}]},{"title":"通识教育整理-文科","slug":"collections/通识教育整理-文科","date":"2017-09-28T14:51:09.000Z","updated":"2017-10-12T14:44:41.551Z","comments":true,"path":"2017/09/28/collections/通识教育整理-文科/","link":"","permalink":"https://ir1d.cf/2017/09/28/collections/通识教育整理-文科/","excerpt":"","text":"从元培大佬获得核心课程手册 整理一下通识教育 先写文科的吧 好向往的 中国语言文学系古代汉语阅读古代文献 《古代汉语》 郭锡良 现代汉语现代汉语语法学的入门知识 《现代汉语》 北京大学中文系现代汉语教研室编 中国古代文学史中文系主干基础课 《中国古代文学史》 袁世硕，陈文新（“马克思主义理论研究和建设工程”教材） 《中国文学史》 袁行霈 《中国文学史参考资料简编》 北京大学古代文学教研室 语言学概论讲解语言学基础知识 《语言学纲要》 叶蜚声 徐通锵 中国现代文学史《中国现代文学三十年（修订本）》 钱理群 温儒敏 吴福辉 中国当代文学《中国当代文学史》 洪子诚 《中国当代文学作品精选》 谢冕 洪子诚 文学原理主干基础课 《文学理论》 童庆炳 李准（”马克思主义理论研究和建设工程“教材）《文学原理》董学文 张永刚 《文学理论的未来》 拉尔夫·科恩 《当代学术入门——文学理论》乔纳森·卡勒 《论语》选读《孟子》选读经典讲读《中国古代典籍导读》 鲁惟一 中文工具书《中文工具书教程》朱天俊 李国新 中国古代文化《中国文化史纲要》 吴小如，刘宁 《中国古代文化史》 古代典籍概要《史部要籍解题》 王树民 《四库全书总目》 永瑢 比较文学原理《比较文学概论》 曹顺庆 孙景尧《比较文学原理新编》 张辉 陈跃红 民间文学概论《民间文学教程》 段宝林 阅读与写作《新编大学实用写作训练》 中国现代文学中国当代文学作品中国民俗与社会生活中国古代文化基础《中国古代文化史》 阴法鲁 中国人文地理《中国文化地理概述》胡兆量《中国历史人文地理》邹逸麟 考古历史哲学跳过外国语学院摘录窝感兴趣的法语精读《法语教程》 王文融 《大学法语课本》 杨维仪 法国文学史和文学选读《法国文学选集》《欧洲文学史》 西班牙语精读《现代西班牙语》 董燕生 西班牙语文学史和文学选读《西班牙文学史》沈石岩 《西班牙文学选集》刘永信《西班牙文学》（黄金世纪研究） 陈众议《二十世纪西班牙小说》王军 拉丁美洲文学史和文学选读《拉丁美洲文学史》 赵德明《拉丁美洲文学选集》 郑书九《西班牙与西班牙语美洲诗歌导论》 赵振江 英语精读《College English(2)》 周珊凤 张祥保 《北大英语精读》 韩敏中 英国文学史The Norton Anthology of English Literature M.H. Abrams et al. The Norton Anthology of English Literature, volumes D - F, Stephen Greenblatt 普通语言学General Linguistics Robins, R.H. Linguistics: A Course Book Hu Zhuangling 英译汉《大学英汉翻译教程》 王治奎《翻译技巧指导》 黄龙《中国译学理论史稿》 汉译英《新编汉英翻译教程》 陈宏微 李亚丹 美国文学史与选读Norton Anthology of American Literature. Norton Editors 法语精读《大学法语课本》 齐香 法语试听说《法语教程》 王文融《Festival 2》 Sylvie Poisson-Quinton《走遍法国》(Reflets II) 卡佩勒 欧洲史《欧洲史》 诺曼·戴维斯 世界史通论《世界文明史》 高毅 《世界史》 齐世荣 《全球通史——1500年后的世界》 外国史学史《西方史学史》 张广智 艺术史概论《什么事艺术学》朱青生 中国古代史《中国式纲要》翦伯赞 《中国古代简史》张帆 中国历史文选《新编中国历史文选》 中世纪欧洲史《欧洲中世纪史》 朱迪斯·本内特 艺术学院艺术学原理《艺术学原理》王一川 美术概论《艺术发展史》贡布里希 《中国绘画三千年》 杨新 《西方美术史十五讲》 丁宁 音乐概论自编讲义 参考： A history of Western Music, An Outline History Of Music, 中国传统音乐概论， 民族音乐概论，音乐人类学导论，中国传统音乐概论，20世纪西方音乐 影视理论与批评《影视批评学》 李道新 《影视鉴赏》 陈旭光 《中国电影批评史（1897-2004）》李道新 创意写作文化产业导论《文化产业导论》 向勇 艺术心理学《心理学史》 赫尔穆特·E.吕克 跨文化艺术传播学《跨文化艺术传播》 林一 Communication Between Cultures, Samovar Larry A. 中西方音乐专题《西方文明中的音乐》 保尔·亨利·朗Western Music in Context, Walter Frisch《乐贼心弦：中国音乐》 刘小龙 世界美术简史《加德纳世界艺术史 Gardner’s Art Through the Ages》 西方艺术学原著导读The Art of Art History: A Critical Anthology 中国艺术学原著导读人间词话及评论会变 中国美学史大纲 古话品录 六朝画论研究 文心雕龙注 书谱译注 司空图二十四诗品辩伪 林泉高致 画禅室随笔 石涛画学本义 中国艺术精神 意境 国关法院信管社会政管新传经济光华国发跳过","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"https://ir1d.cf/tags/课程整理/"}]},{"title":"初等数论及其应用 - 第一章","slug":"enti1","date":"2017-09-28T07:19:06.000Z","updated":"2018-06-23T04:46:16.035Z","comments":true,"path":"2017/09/28/enti1/","link":"","permalink":"https://ir1d.cf/2017/09/28/enti1/","excerpt":"","text":"算术基本定理：没个正整数可以按递增次序唯一地写成素数的乘积 现代数论的发展始于高斯 二次互反律 这个定律把素数$p$是否为模另一个素数$q$的完全平方与$q$是否为$p$的完全平方联系起来 找出大素数和分解大数在时间上的强反差是$RSA$密码系统的基石 $RSA$系统中，用户公私两把秘钥，每个用户可以用别人的公钥来加密信息，但只有拥有相应私钥的用户才能解密 一个方程若要求解为整数，则成为丢番图方程 费马大定理 x^n + y^n = z^n若$n$是大于$2$的整数，这个方程没有整数解$(x, y, z)$，这里$xyz \\neq 0$ 1995年由怀尔斯（Wiles）给出第一个证明 梅森（Mersenne）素数 形为$2^p - 1$ 看起来就是BOINC里面的某个项目= = 动手实验是研究数论所不可缺少的一部分 数学归纳法是数论（和许多数学分支）的最重要证明方法之一 整数在数论的研究中扮演着重要的角色 良序性质(The Well-Ordering Property) 每个非空的正整数集合都有一个最小元 良序性质可以作为定义正整数集合的公理 如果存在整数$p$和$q \\neq 0$，使得$r=\\fracpq$，则称实数$r$是有理数。如果$r$不是有理的，啧称为无理数 证明$\\sqrt(2)$是无理数 假设 数$\\alpha$称为代数数，如果它是整数系多项式的根；也就是说，$\\alpha$是代数数，如果存在整数$a0, \\cdots, a_n$，使得$a_n\\alpha^n+a{n-1}\\alpha^{n-1}+\\cdots+a_0 = 0.$如果$\\alpha不是代数数，称之为超越数$","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"初等数论及其应用","slug":"初等数论及其应用","permalink":"https://ir1d.cf/tags/初等数论及其应用/"}]},{"title":"笔记","slug":"笔记","date":"2017-09-28T07:14:39.000Z","updated":"2018-06-23T04:49:11.698Z","comments":true,"path":"2017/09/28/笔记/","link":"","permalink":"https://ir1d.cf/2017/09/28/笔记/","excerpt":"","text":"用来统计挖的坑 初等数论及其应用 网络科学引论 算法导论 Multivariable Calculus","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/tags/笔记/"}]},{"title":"Codeforces Round 435 (Div. 2)","slug":"cf/cf862","date":"2017-09-26T14:49:31.000Z","updated":"2018-06-29T02:18:11.826Z","comments":true,"path":"2017/09/26/cf/cf862/","link":"","permalink":"https://ir1d.cf/2017/09/26/cf/cf862/","excerpt":"Codeforces Round #435 (Div. 2) 100场div1指日可待【","text":"Codeforces Round #435 (Div. 2) 100场div1指日可待【 A问最少对集合修改几次，使得集合的mex值是给定的值 从小到大处理即可 B A loop is an edge, which connects a node with itself. Graph doesn’t contain multiple edges when for each pair of nodes there is no more than one edge between them. A cycle and a loop aren’t the same . 问可以往一个树最多加多少边使得新图仍然是二分图 注意到树本身是二分图，加边必然是在两个点集之间，而这些边最多有$l * r$条，已经有了$n - 1$条，所以答案显然 注意建树要加双向边，以及爆int的问题别忘了开long long C要求构造一个大小为n的集合使得集合里的数xor和为x 且集合里的数不超过1e6 注意到n是1e5而数是1e6这个限制条件，就是暗示$2^{17}$可以用来区分（不会重复而且不会超出） 然后就可以先放$1, 2, 3, \\cdots, n - 3$ 记它们的xor和是s 那么此时后三个数的xor和是$s\\ xor\\ x$ 就可以放$0， 2^{17}， 2^{17}\\ xor\\ s\\ xor\\ x$ 注意题中要求所有数不能相同，所以如果s和x是相等的，后两个数就相等了就不合题意了 所以此时放$2^{17}, 2^{18}, 2^{17}\\ xor\\ 2^{18}$ 至于为什么选择$2^17$和$2^18$，是为了$2^17\\ xor\\ 2^18$和$2^17\\ xor\\ x\\ xor\\ s$的值始终大于1e5 就是那个$2^17$的最高位是1然后它和别的数那一位是0的数xor之后答案那位是1就保证了比1e5大 D交互题 每次可以查询一个01串和某个给定的01串的hamming distance（编辑距离） 然后要求在15次查询之内确定01串中一定是0的一个位置和一定是1的一个位置即可 要记得flush缓冲区 题意不是要完全确定01串，只要确定一个0一个1即可 这个查询的核心操作是要得到一个区间里的0/1的个数 用类似前缀和的思路，我们先查询全是1的串的答案然后到时候减一下就好了 酱紫之后发现可以再查询$011111…$然后就得到第一个数是0还是1了 之后找另一个数的位置，不难发现可以二分最左侧的那个，即只要不是连续的那么就有一个要找的数出现了 E给a和b两个数列定义f函数并求值 // 公式莫名其妙炸了 $f(j) = |\\sum{i=1}^n(-1)^{(i-1)}*(a_i-b{i+j})|$ 每次区间加一个数 然后 查询所有f(j)的最小值 注意到可以把f(f)的式子拆开变成$|\\sum{i=1}^n{i-1}*a_i+\\sum{i=1}^n(-1)^i*b_{i+j}|$ 然后发现前一项是定值，而且整个式子在绝对值里面，如果前一项值是c，每次只需要找和-c最接近的一个后一项就行了 换言之，可以用一个set维护所有的后一项 对于修改操作，如果修改的区间长是偶数，发现加了多少次就减了多少次 如果是奇数，那就看l的奇偶性判断是加还是减 巧妙之处在于发现求这个最值不需要每次遍历来找，只需要这个值尽可能接近0就行，而且修改是对a操作的b一直不变，所以XD std用了一个非常巧妙的方法在一次循环里得到了对于所有j的第二项和 注意j变到j+1的时候是要取相反数然后对第一个和最后一个数加加减减 F有n个字符串，q个操作 第一种是查询$[a, b]$的某个子区间，使得区间长度乘上区间lcp的值最大 第二种是修改某个字符串 // 先坑着= = 求出相邻的lcp长度，区间lcp等于区间最小值 标程是对h分类，小的用线段树维护，大的直接set 学习了下nbc的代码 不是很懂QAQ","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://ir1d.cf/tags/codeforces/"}]},{"title":"cpppp","slug":"cpppp","date":"2017-09-22T00:38:14.000Z","updated":"2018-06-23T04:50:38.001Z","comments":true,"path":"2017/09/22/cpppp/","link":"","permalink":"https://ir1d.cf/2017/09/22/cpppp/","excerpt":"","text":"计概课对语言知识要求好高 觉得应该着手认认真真的学习c++ 于是借来室友的C++ primer plus学习这一套理论 tag 是 cpppp 的都会是相关的笔记 hmmm 留给程设好了……","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ir1d.cf/categories/笔记/"}],"tags":[{"name":"cpppp","slug":"cpppp","permalink":"https://ir1d.cf/tags/cpppp/"}]},{"title":"LSB","slug":"ctf/LSB","date":"2017-08-25T08:54:53.000Z","updated":"2017-10-12T14:44:41.847Z","comments":true,"path":"2017/08/25/ctf/LSB/","link":"","permalink":"https://ir1d.cf/2017/08/25/ctf/LSB/","excerpt":"","text":"感觉是个有趣的东西 用steganabara-1.1.1.jar过滤 肉眼识别了一波","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"attachment","slug":"ctf/attachment","date":"2017-08-25T08:24:33.000Z","updated":"2017-10-12T14:44:41.847Z","comments":true,"path":"2017/08/25/ctf/attachment/","link":"","permalink":"https://ir1d.cf/2017/08/25/ctf/attachment/","excerpt":"","text":"就是一个txt压成了zip封在php里面 就是图种的感觉= = 学到了这个 foremost -i attachment.php","categories":[],"tags":[]},{"title":"caesar2","slug":"ctf/caesar2","date":"2017-08-25T06:03:41.000Z","updated":"2017-10-12T14:44:41.830Z","comments":true,"path":"2017/08/25/ctf/caesar2/","link":"","permalink":"https://ir1d.cf/2017/08/25/ctf/caesar2/","excerpt":"","text":"先把16进制转换成10进制的ascii码 然后就是枚举偏移量看得到的认不认识 就行了= = guesswork 真的猜不出来= =","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"regex","slug":"ctf/regex","date":"2017-08-24T22:47:57.000Z","updated":"2017-10-12T14:44:41.830Z","comments":true,"path":"2017/08/25/ctf/regex/","link":"","permalink":"https://ir1d.cf/2017/08/25/ctf/regex/","excerpt":"","text":"匹配空字符串：/^$/ 匹配wechall：/^wechall$ 匹配特定文件名的图片后缀：/^wechall4?\\.(?:jpg|gif|tiff|bmp|png)$/ 需要对文件名添加捕获分组：/^(wechall4?)\\.(?:jpg|gif|tiff|bmp|png)$/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"limited_access","slug":"ctf/limited-access","date":"2017-08-23T09:42:56.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/limited-access/","link":"","permalink":"https://ir1d.cf/2017/08/23/ctf/limited-access/","excerpt":"","text":".htaccess里面写限制了GET需要验证123&lt;Limit GET&gt;require valid-user&lt;/Limit&gt; 所以换成POST就好了 POST的新姿势 123&lt;form method=\"POST\" action=\"https://www.wechall.net/challenge/wannabe7331/limited_access/protected/protected.php\"&gt;&lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt; 当然curl也行 curl -v -H &quot;Cookie: [WC=asdf]&quot; -X POST http://www.wechall.net/challenge/wannabe7331/limited_access/protected/protected.php 酱紫","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"auth_bypass2","slug":"ctf/auth-bypass2","date":"2017-08-23T07:07:11.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/auth-bypass2/","link":"","permalink":"https://ir1d.cf/2017/08/23/ctf/auth-bypass2/","excerpt":"","text":"2比1多了一个密码校验的过程 sql里面union可以把select结果合并到一起 username：’union select 1,’admin’,’e10adc3949ba59abbe56e057f20f883 password:123456 把username代入之后得到的是这个 SELECT * FROM users WHERE username=’’union select 1,’admin’,’e10adc3949ba59abbe56e057f20f883’ result中肯定就有 1,’admin’,’e10adc3949ba59abbe56e057f20f883’ 这样就构造出来了 result[&#39;password&#39;] 这里可以试着跑sql指令 https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_columns","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"simplesub1","slug":"ctf/simplesub1","date":"2017-08-23T06:34:41.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/simplesub1/","link":"","permalink":"https://ir1d.cf/2017/08/23/ctf/simplesub1/","excerpt":"","text":"Simple Substitution I http://quipqiup.com/ 这个太厉害了 刚开始找Clues往里填找了半天都不好使 后来删掉了直接solve= = 就出来了","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"globals","slug":"ctf/globals","date":"2017-08-23T06:11:45.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/globals/","link":"","permalink":"https://ir1d.cf/2017/08/23/ctf/globals/","excerpt":"","text":"Register Globals 将所有提交的参数注册为全局变量 注意到这一段 123if (strtolower($login[0]) === 'admin') &#123; $chall-&gt;onChallengeSolved(GWF_Session::getUserID());&#125; 所以直接http://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin 就好了","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"transposition1","slug":"ctf/transposition1","date":"2017-08-23T04:06:40.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/transposition1/","link":"","permalink":"https://ir1d.cf/2017/08/23/ctf/transposition1/","excerpt":"","text":"http://tholman.com/other/transposition/ 然后调那个key length试到2发现好像能看懂= = UPDATE noescvotes SET $who=$who+1 WHERE id=1 把 who 替换成 barack=111,bill=bill 最开始没找到上哪里传这个名字以为只能点按钮= = 然后突然发现地址直接输就好了 这个直接把who改成 barack`=111 会出问题= = 哎这样就好了 ？vote_for=bill`=111;#","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"encodings1","slug":"ctf/encodings1","date":"2017-08-23T01:55:07.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/encodings1/","link":"","permalink":"https://ir1d.cf/2017/08/23/ctf/encodings1/","excerpt":"","text":"这种解密没什么头绪 翻了翻题解 可能要观察到长度是441=7*7*9？ 然后就是把每7位看做一个2进制数 转成ascii就好了 12345678var str = \"101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110\";var message = \"\";while (str != \"\") &#123; i = String.fromCharCode(parseInt(str.substr(0, 7), 2)); message = message + i; str = str.substr(7);&#125;document.write(message);","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"LFI","slug":"ctf/LFI","date":"2017-08-22T12:17:00.000Z","updated":"2017-10-12T14:44:41.795Z","comments":true,"path":"2017/08/22/ctf/LFI/","link":"","permalink":"https://ir1d.cf/2017/08/22/ctf/LFI/","excerpt":"","text":"PHP LFI 坑点是后面会加一个.html http://sp4hack.blogspot.ca/2012/10/we-chall-training-php-lfi.html 这里的思路是加一个%00 Everything after the null byte will be deleted. 太帅了=_^ 好像就是传说中的 Null Byte Injection ？ http://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"programming1","slug":"ctf/programming1","date":"2017-08-22T11:54:06.000Z","updated":"2017-10-12T14:44:41.787Z","comments":true,"path":"2017/08/22/ctf/programming1/","link":"","permalink":"https://ir1d.cf/2017/08/22/ctf/programming1/","excerpt":"","text":"先从一个链接获取文字再用这个文字生成新的链接= = cookie 传不明白了= = 最后一点也不优雅 决定用大佬的直接 ajax 的方法 123456789$.ajax(&#123;url: 'http://www.wechall.net/challenge/training/programming1/index.php?action=request',type: 'get',dataType: 'text',success:function(data)&#123;var newUrl=\"index.php?answer=\"+data;window.location.href=newUrl;&#125;&#125;); 好像自己写的没问题 是因为 wechall 那个锁定IP？","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"auth_bypass1","slug":"ctf/auth-bypass1","date":"2017-08-21T14:19:57.000Z","updated":"2017-10-12T14:44:41.780Z","comments":true,"path":"2017/08/21/ctf/auth-bypass1/","link":"","permalink":"https://ir1d.cf/2017/08/21/ctf/auth-bypass1/","excerpt":"","text":"MySQL Authentication Bypass - The classic 对于 MySQL 不是很了解 写 or 1=1 搞了半天 实际上应该是 or &#39;1&#39;=&#39;1&#39;; 以及这个分号加的…… 没想到","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"PHP-0817","slug":"ctf/PHP-0817","date":"2017-08-21T13:54:38.000Z","updated":"2017-10-12T14:44:41.772Z","comments":true,"path":"2017/08/21/ctf/PHP-0817/","link":"","permalink":"https://ir1d.cf/2017/08/21/ctf/PHP-0817/","excerpt":"","text":"http://www.wechall.net/challenge/php0817/index.php 学习了 LFI 这一套理论 Local File Inclusion 就和之前有人卡评测机的时候用1#include &lt;/etc/passwd&gt; 差不多吧 这个题的巧妙之处在于 php 之中很多东西在 switch 这里都会被转换成 0 所以就水掉了……","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://ir1d.cf/tags/ctf/"}]},{"title":"subject","slug":"notes/subject","date":"2017-08-17T07:41:29.000Z","updated":"2017-10-12T14:44:41.675Z","comments":true,"path":"2017/08/17/notes/subject/","link":"","permalink":"https://ir1d.cf/2017/08/17/notes/subject/","excerpt":"","text":"一晚上接近通宵可能中间睡了一会吧其实深夜也没有什么特别的觉得白天吵闹的话还是因为无法割舍吧深夜不过是提供一个契机来与世隔绝白天又不是不可以晚上一听歌就恐怕是真的不打算睡觉了 唔 定时作息养成规律生活自律给我自由","categories":[],"tags":[]},{"title":"明天","slug":"notes/明天","date":"2017-08-16T07:48:01.000Z","updated":"2017-10-12T14:44:41.663Z","comments":true,"path":"2017/08/16/notes/明天/","link":"","permalink":"https://ir1d.cf/2017/08/16/notes/明天/","excerpt":"","text":"你能扛起明天吗你能养活自己吗那你怎么养活她为什么将会是你凭什么可以是你 学姐你看那麻雀和你好像它也会飞 我好想你好想去找你上一句是假的上一句是假的 会好起来的会的 不放弃也不勉强哪怕比永远还远一点","categories":[],"tags":[]},{"title":"POJ训练计划","slug":"POJ训练计划","date":"2017-07-31T14:03:49.000Z","updated":"2018-06-29T03:50:06.767Z","comments":true,"path":"2017/07/31/POJ训练计划/","link":"","permalink":"https://ir1d.cf/2017/07/31/POJ训练计划/","excerpt":"","text":"3299：公式转换题，需要读题，不能只看样例 2159：判断同构，按频率排序 1083：区间加+单点最值 2739：预处理素数表+尺取法 2262：暴力 1503：高精度加法 3006：暴力 2255：dfs的过程中把两个序列中同一个子树给对应上就好了 3094：模拟 初期基本算法1753：暴力 2965：发现如果’+’位置对应的行和列上每一个位置都进行一次操作,则整个图只有这一’+’位置的符号改变,其余都不会改变. https://xuanwo.org/2014/07/23/POJ-2965-The-Pilots-Brothers-refrigerator/ 1328：贪心策略依然是从左往右，尽量让每颗雷达覆盖最大岛屿数。 将每个海岛转化为能覆盖它的雷达坐标的区间 2109：http://blog.csdn.net/code_pang/article/details/8263971 3295：模拟 求值 1068：模拟 2632：模拟= = RE一时爽 1573：模拟 2993：模拟 不太好写= = 2996：翘了 似乎是模拟就好= = 图算法1860：判有没有负环 3259：判负环 注意边是单向还是双向 好久没写多case的了= =这么生疏 1062：枚举地位建图跑最短路 2253：求最短路上的最大边最小 可以二分答案+并查集 POJ上边不知道为啥有时候G++交是WA而C++交是AC 然后有的时候还反过来= = 还可以改一改最短路= = 注意别把double的变量在传参之类的时候一不小心当int用了酿成惨案 1125：Floyd 2240：spfa找正环 或者直接Floyd看 多case的题调不出来的时候一定要想一想是不是哪里忘记初始化了 1789：prim 2485：prim 1258：prim 3026：prim 写起来挺麻烦的 坐标反的 = = 1094：处理字符别忘记了换行符 可以处理出来元素之间的大小关系 然后就很方便了 3041：把原图的点和边互换构图 然后之前是这样找尽量少的行列覆盖点 现在是找尽量少的点覆盖行列 就是最小点覆盖了 然后发现这个点只与一行一列相关 所以新图是一个二分图 二分图的最小点覆盖数值上等于二分图最大匹配 想了很久还是不是很懂匈牙利的实现里面的一处trick 于是写了dinic跑最大流= = 3020：把每个可以放置的点作为新点 如果两个点在原图相邻那么就可以放 所以连一条边 求的就是最小路径覆盖 拆点构图 得到的是二分图 3436：点有流量限制就拆点就好了 数据结构1035：模拟就好了 很久没写题代码能力捉急= = 3080：后缀数组最长公共子串 注意要求的是字典序最小的 二分答案从前往后找就行了 调了好久发现对后缀数组的理解还是不到位= = 1936：判断s是否是t的子序列 遍历t 同时维护s的一个指针就行了 2388：排序后输出位于中间的就行了 2299：求逆序对 归并就行 3349：hash判重就行 把每个雪花的六个角排序一下= = 3274：给出牛的个数n和总共特征个数k，求最长的区间，使得区间内所有牛的k个特征相加之和都相等。比如样例区间 每个牛内部差分再对序列求前缀和 问题就转化成在前缀和序列中找相等的两个元素 注意一定要先差分的才能将问题转化 从sum[j][0] - sum[i][0] = sum[j][1] - sum[i][1] = …… = sum[j][k] - sum[i][k]变成1234sum[i][1] - sum[i][0] = sum[j][1] - sum[j][0]sum[i][2] - sum[i][0] = sum[j][2] - sum[j][0]……sum[i][k] - sum[i][0] = sum[j][k] - sum[j][0] 2151：概率dp 设dp[i][j][k]表示第i个队在前j道题中解出k道的概率 dp[i][j][k]=dp[i][j-1][k-1]*p[i][j]+dp[i][j-1][k]*(1-p[i][j]); //这两种来源，第j道做出来或者没做出来+前j-1道做k-1或者k道题概率 设s[i][k]表示第i队做出的题小于等于k的概率s[i][k]=dp[i][M][0]+dp[i][M][1]+...+dp[i][M][k]; 每个队至少做出一道题概率为P1=(1-s[1][0])*(1-s[2][0])*...(1-s[T][0]); 每个队做出的题数都在1~N-1的概率为P2=(s[1][N-1]-s[1][0])*(s[2][N-1]-s[2][0])*...(s[T][N-1]-s[T][0]); 最后的答案就是P1-P2，代表至少一个队作出n到以上（1 - 所有队作出0...n-1的概率） 1840：判断方程是否有根 先枚举前两项可能的值再枚举后三个的值看看是否有和为0就行 hash姿势不对会mle 直接用map会tle = = 而且poj还没有unordered_map 2002：问平面上一堆点能组成多少个正方形，正方形的边允许不和坐标轴平行。方法是枚举一条边上的两个点，因为是正方形，此时就可以算出另外两个点，只需要二分一下看看是否存在就好了。注意每个正方形会被计算两次。 2503：应该是想要考哈希+二分，但是map一下就好了。值得一提的是gets会接受空行 3253：求哈夫曼树，priority_queue一波 2513：把字符串映射到点，再判断是否有欧拉通路。因为是无向图，只需要统计顶点度数为奇数的数和判断全图是否联通。至于如何映射字符串到点，用map会多个log超时，选用trie。好久没写并查集忘记了初始化竟然看了好久才发现。 简单搜索2488：爆搜即可，注意字典序的要求，字母用来表示列，就是说要列优先最小，再行最小。具体体现在dx, dy数组的设置上。 12const int dx[] = &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;;const int dy[] = &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;; 3083：bfs很好写，难点在于如何按照左（右）手边靠墙走，核心仍然在于方向数组 12345678910const int dxl[] = &#123;-1, 0, 1, 0&#125;;const int dyl[] = &#123;0, 1, 0, -1&#125;;const int dxr[] = &#123;-1, 0, 1, 0&#125;;const int dyr[] = &#123;0, -1, 0, 1&#125;;// 然后dfs枚举方向的时候：f(i, 0, 4) &#123; t = (i + op + 3) % 4; nx = x + dx[t]; ny = y + dy[t];&#125;// op用来表示方向 发现dxl实际上是从12点方向顺时针转，drl是逆时针转，从而刚好对应位置-1就是要找的方向，取模之后相当于是+3 3009：看起来很吓人但是实际上不难处理，把之前的dfs每次选一步走改成每次选一个方向走就好了。 1321：给一个不规则棋盘问放k个子的方案数，dfs枚举方案。值得注意的是允许当前位置不放子，所以还要记录横竖的vis数组。 2251：三维的地图，bfs或者dfs都可以 3278：bfs思路很好想，但是几年前简直是又wa又t一时爽。注意写法可能会忽略掉n==k的情况。用pair放到queue里写会很慢，不妨把时间戳放到外面开个数组单独记录。 1426：直接爆搜就过了 感觉会有更优美的写法 3126：实际上就是处理出来质数然后bfs就好了，然而筛法写错的我= = 3087：模拟就好了，写法是dfs而已 3414：著名的倒水问题，bfs。注意数组大小 2531：dfs把这堆东西分成两组 1416：找数字的分割方式使得各部分的和与x最近，好像应该dp不过dfs就过了。 2676：计算概论实验班选拔考试考了就懒得再写了= = 1129：给点染色的最小色数 动态规划1837：dp[i][c[k] * d[i] + j] += dp[i - 1][j]; 第二维是两侧重量差（体积）。因为有负的所以平移一波。 1276：01背包和多重背包的混合。考虑每一个多重背包，如果num[i] * c[i]大于体积，那么可以对这个物体看作是完全背包，否则拆成log个，然后当成01背包来做 3267：给一堆词，问一个字符串最少删掉多少字符后可以由这些单词中的某几个（可重复）顺序连接而成。 dp[i] = min(dp[i + 1] + 1, dp[i + match] + (match - len[j])) 其中 match 表示从当前位置开始需要延伸 match 长度来包含 len[j] ，这样 match - len[j] 就是需要删掉的那部分了 dp[i]的含义是从第 i 个位置开始的答案 1836：给一个序列，问最少要删掉多少个，使得每一个元素都有一个性质：向左或向右看不会有&gt;=自己的元素。方法是求两个方向的 LIS，然后求前缀和后缀 max。最后 res = max(l[i] + r[i + 1]) 。注意从 discuss 拿到的这组数据： 8 3 4 5 1 2 5 4 3 答案是 2。换言之允许中间一段是相等的，解决办法可以对l[i]求前缀max，r[i]求后缀max，再去求res 1260：给出每种品质的价格和需求，每多买一种品质需要多加钱，低品质可以用高品质代替。问最少花多少钱。 dp[i] 表示 前 i 种品质最少要花多少钱，转移的时候要么自己买，要么枚举一段相邻的品质用当前品质的价格来买。为什么是连续的呢？因为保证了价格递增，如果不是连续的，那么分成两段可以更便宜。","categories":[{"name":"算法","slug":"算法","permalink":"https://ir1d.cf/categories/算法/"}],"tags":[{"name":"poj","slug":"poj","permalink":"https://ir1d.cf/tags/poj/"}]},{"title":"新的开始","slug":"notes/新的开始","date":"2017-07-30T14:04:32.000Z","updated":"2017-10-12T14:44:41.610Z","comments":true,"path":"2017/07/30/notes/新的开始/","link":"","permalink":"https://ir1d.cf/2017/07/30/notes/新的开始/","excerpt":"","text":"出发去旅行前的一次重装把东西都给整没了，索性也就重新开始写这个blog。 大学加油！希望能有机会成为自己想成为的人！愿不负这时光！","categories":[],"tags":[]}]}