{"meta":{"title":"Neverland","subtitle":"你是我不愿醒来的梦啊<br>真是柔情一场","description":null,"author":"Ir1d","url":"http://ir1d.cf"},"pages":[{"title":"404","date":"2017-11-09T13:17:18.000Z","updated":"2017-11-09T13:17:33.395Z","comments":true,"path":"404/index.html","permalink":"http://ir1d.cf/404/index.html","excerpt":"","text":""},{"title":"About","date":"2017-11-09T13:19:14.000Z","updated":"2018-01-31T10:36:37.323Z","comments":true,"path":"about/index.html","permalink":"http://ir1d.cf/about/index.html","excerpt":"","text":"The only label to find is ‘I don’t like labels’. Best Wishes!"},{"title":"categories","date":"2018-06-22T15:06:32.000Z","updated":"2018-06-22T15:06:32.731Z","comments":true,"path":"categories/index-1.html","permalink":"http://ir1d.cf/categories/index-1.html","excerpt":"","text":""},{"title":"Categories","date":"2017-11-09T13:15:33.000Z","updated":"2018-01-31T10:36:56.452Z","comments":true,"path":"categories/index.html","permalink":"http://ir1d.cf/categories/index.html","excerpt":"","text":""},{"title":"Friends","date":"2017-11-09T13:19:14.000Z","updated":"2018-01-31T10:36:38.947Z","comments":true,"path":"friends/index.html","permalink":"http://ir1d.cf/friends/index.html","excerpt":"","text":"wwyqianqian: https://wwyqianqian.github.io/"},{"title":"Tags","date":"2017-11-09T13:14:50.000Z","updated":"2018-01-31T10:37:33.062Z","comments":true,"path":"tags/index.html","permalink":"http://ir1d.cf/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-22T14:56:00.000Z","updated":"2018-06-22T14:56:00.881Z","comments":true,"path":"tags/index-1.html","permalink":"http://ir1d.cf/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"算导 动态规划部分 笔记","slug":"算导dp笔记","date":"2018-06-25T14:59:18.000Z","updated":"2018-06-26T07:23:51.146Z","comments":true,"path":"2018/06/25/算导dp笔记/","link":"","permalink":"http://ir1d.cf/2018/06/25/算导dp笔记/","excerpt":"动态规划应用于子问题重叠的情况","text":"动态规划应用于子问题重叠的情况 要去刻画最优解的结构特征 尝试递归地定义最优解的值（就是我们常说的考虑从i - 1转移到i） 计算最优解 利用计算出的信息构造一个最优解 钢条切割给定一段钢条，和不同长度的价格，问如何切割使得总价格最大 为了求解规模为n的原问题，我们先求解形式完全一样，但规模更小的子问题。即当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例。我们通过组合相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。 最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解 动态规划的两种实现方法 带备忘的自顶向下法 （记忆化搜索） 自底向上法 （将子问题按规模排序，类似于递推） 算导用子问题图上按照逆拓扑序求解问题，引出记忆化搜索。 重构解（输出方案）：转移的时候记录最优子结构的位置 矩阵链乘法给出n个矩阵的序列，希望计算他们的乘积，问最少需要多少次乘法运算 （认为$p q$的矩阵与$qr$的矩阵相乘代价是$pqr$） 完全括号化方案是指要给出谁先和谁乘 动态规划原理两个要素： 最优子结构具有最优子结构也可能是适合用贪心的方法求解 注意要确保我们考察了最优解中用到的所有子问题 证明问题最优解的第一个组成部分是做出一个选择 对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。 要保持子问题空间尽量简单，只在必要时扩展 最优子结构的不同体现在两个方面： 原问题的最优解中涉及多少个子问题 确定最优解使用哪些子问题时，需要考察多少种选择 子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边 经典问题 无权最短路径 具有最优子结构性质 无权最长（简单）路径 此问题不具有，是NP完全的 区别在于，要保证子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解。 相关 —— 求解一个子问题时用到了某些资源，导致这些资源在求解其他子问题时不可用 子问题重叠子问题空间要足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。 重构最优解存表记录最优分割的位置，就不用重新按照代价来重构 最长公共子序列子序列允许不连续 每个c[i][j]只依赖于c[i - 1][j]、c[i][j - 1]和c[i - 1][j - 1] 记录最优方案的时候可以不需要额外建表（优化空间），因为重新选择一遍（转移过程）也是$O(1)$的 最优二叉搜索树给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小 考虑当一棵子树成为了一个节点的子树时，答案（期望搜索代价）有何变化？ 由于每个节点的深度都增加了1，这棵子树的期望搜索代价的增加值应为所有概率之和 tD / eD 动态规划：状态空间是$O(n^t)$的，每一项依赖其他$O(n^e)$项 经典问题（来自习题）DAG 中的最长简单路径$dp[i] = max(dp[j] + 1), ((j, i) \\in E)$ 最长回文子序列$$dp[i][i + len] =\\begin{cases}dp[i + 1][i + len - 1] + 2, &amp; \\text{if $s[i] == s[i + len]$} \\[2ex]max(dp[i + 1][i + len], dp[i][i + len - 1]), &amp; \\text{else}\\end{cases}$$ 边界：$dp[i][i] = 1$ 注意：$dp[i][j]$ 表示的是闭区间 也可以转化为LCS问题，只需要把a串反转当做b，对a和b求lcs即可 证明在： https://www.zhihu.com/question/34580085/answer/59539708 注意区分子串（要求连续）的问题 最长回文子串$O(n^2)$：$dp[i] = max(dp[j] + 1), s(j + 1 .. i) 是回文$ $(O(n))$： Manacher Manacher $p[i]$ 表示从i向两侧延伸（当然要保证两侧对应位置相等）的最大长度 为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的）#，开头加一个$ 这样得到的回文串长度就保证是奇数了 考虑如果按顺序得到了$p[1 .. i - 1]$，如何计算$p[i]$的值 如果之前有一个位置比如说是id，有p[id] + id &gt; i 那么i这个位置是被覆盖了的，根据id处的对称性，我们找p[id * 2 - i]延伸的部分被p[id]延伸的部分所覆盖的那段，显然这段对称回去之后是可以从i处延伸出去的长度。 如果找不到呢？就先让p[i] = 1吧。 之后再暴力延伸一下。 可以证明是$O(n)$的 至于如何找是否有这么一个id呢？递推的时候存一个max就好了 代码在：https://github.com/Ir1d/Fantasy/blob/master/HDU/3068.cpp ## 双调欧几里得旅行商问题 好像出成了某一年程设期末 upd：其实是推荐练习里面的 书上的提示是：从左到右扫描，对巡游路线的两个部分分别维护可能的最优解 说的就是把回路给拆开吧 思路一： $dp[i][j] 表示\\ 1..i\\ 和\\ 1..j\\ 两条路径$ 我们可以人为要求 $1..i$ 是更快的那一条路径 这样考虑第i个点分给谁 如果是分给快的那条：$dp[i][j] = max(dp[i - 1][j]), j = 1..n$","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://ir1d.cf/tags/矩阵乘法/"},{"name":"算法导论","slug":"算法导论","permalink":"http://ir1d.cf/tags/算法导论/"}]},{"title":"Codeforces Round 492 (Div. 2) [Thanks, uDebug!]","slug":"cf/cf996","date":"2018-06-25T12:45:31.000Z","updated":"2018-06-25T14:14:53.425Z","comments":true,"path":"2018/06/25/cf/cf996/","link":"","permalink":"http://ir1d.cf/2018/06/25/cf/cf996/","excerpt":"花式过 pp ，专业 fst 选手大显身手","text":"花式过 pp ，专业 fst 选手大显身手 A. Hit the Lottery dp肯定是对的，至于为什么可以贪心呢？ B. World Cup 模拟 C. Tesla 半个小时过去没人过的那种…… 写了半天还是WA 题意是一个两排车道，要求把车停到路边（道牙子上），求方案 题解：先把能放的放进去。把双排道看成一个环，如果有空位能转动就一定有解 这种题坐标一定要按照题目要求来，不能题里是1开头你自己用0开头读入 D. Suit and Tie 数据是成对的，但是被打乱了，问最少要操作多少次可以恢复 注意到最开头的那个数没必要动，于是它对应的那个数必须换过来。以此类推，搞定 E. Leaving the Bar 输入一堆向量，问如何给他们定向(1 / -1)，使得他们的和的模长符合条件。 现场写的贪心的，竟然过了pp 然后发现有dalao加了个如果不符合条件就random shuffle之后重新贪心 哎…… 咋就没想到呢 http://codeforces.com/contest/995/submission/39644972 woq…… stm 发现了一个从后往前贪心过了的= = 题解里证明说每三个模长合格的里面总是能找到两个组成一个模长合格的，这样最后直到只剩两个，顶多是$\\sqrt{2} r$","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://ir1d.cf/tags/codeforces/"}]},{"title":"程设期末上机汇总","slug":"cssx/程设期末上机汇总","date":"2018-06-24T11:41:06.000Z","updated":"2018-06-25T09:23:54.710Z","comments":true,"path":"2018/06/24/cssx/程设期末上机汇总/","link":"","permalink":"http://ir1d.cf/2018/06/24/cssx/程设期末上机汇总/","excerpt":"","text":"A02:马走日 dfs的时候别忘了起点也要标记为vis A04:鸣人的影分身 整数划分，允许分出来0 1234567g(i, 1, 20) dp[0][i] = 1;g(i, 1, 20) &#123; g(j, 1, 20) &#123; if (i &gt;= j) dp[i][j] = dp[i][j - 1] + dp[i -j][j]; else dp[i][j] = dp[i][i]; &#125;&#125; B04:猴子摘桃 可以尺取 注意枚举区间的姿势：如果枚举的是闭区间的端点，应该是g(j, l, r) 别漏了 [r..r] 这个 B09:变换的迷宫 注意到不能原地不动，所以还是会有无解的情况= = 忘了输出感叹号了 vis[x][y][ti % k] 来标记是否可以再走 B02:夺宝探险 没什么特别的，dfs就可以了 但是又WA又T 发现自己看题里说第一行第一列就写了个dfs(1, 1, 1)，然而是从0开始读入的 B10:游览规划 枚举天数，二维代价dp ref: https://blog.csdn.net/niwatori1217/article/details/51869474","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://ir1d.cf/tags/程设/"}]},{"title":"Codeforces Round 491 (Div.2)","slug":"cf/cf991","date":"2018-06-23T17:46:29.000Z","updated":"2018-06-25T14:16:17.826Z","comments":true,"path":"2018/06/24/cf/cf991/","link":"","permalink":"http://ir1d.cf/2018/06/24/cf/cf991/","excerpt":"好久没打了，根本不在状态，深夜掉分场","text":"好久没打了，根本不在状态，深夜掉分场 A. If at first you don’t succeed… 坑点在判断数据是否合法，忘了加上$a &lt; c$，$a &lt; n$之类的，WA了一发 B. Getting an A 问最少修改多少个数满足条件 统计个数然后判一判，WA 于是排个序暴力做 double 转 int 竟然是 直接截断 // 埋下伏笔 C. Candies 交了九发= = 题意是一个人每天吃k个，另一个人每天吃$10%$，问最少的k，使得第一个人吃的至少为总共的一半 这题不能用 * 0.1 应该用 / 10 qls: 整数题怎么有人写 double 的 题面写的是“第一个人吃的至少为总共的一半”，如果总数是奇数，是上取整，换言之，要求第一个人吃的比第二个人多 又WA又T一时爽 D. Bishwock 给一个 $2 * n$ 的棋盘，问最多能放多少个L型的块 贪心放就好了，WA了一发少考虑了几种情况 upd: fst…. 少判了几种情况 E. Bus Number 给一个$1e18$范围的数，问选择里面的一部分数字（要求每种都得出现），重排之后能排出来多少种不同的数 当时就写了个爆搜上去 TLE 最后五分钟想起来加个记忆化 最后半分钟发现 hash 函数返回值竟然没写 导致一直过不去样例 加上return s就交，最后一秒钟返回pp upd: fst…. sb了 hmmm 发现又枚举各个数字的个数过了的 题解：http://codeforces.com/blog/entry/60181","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://ir1d.cf/tags/codeforces/"}]},{"title":"程设期末推荐练习","slug":"cssx/程设期末推荐练习","date":"2018-06-23T03:13:56.000Z","updated":"2018-06-26T07:16:06.902Z","comments":true,"path":"2018/06/23/cssx/程设期末推荐练习/","link":"","permalink":"http://ir1d.cf/2018/06/23/cssx/程设期末推荐练习/","excerpt":"","text":"04:What a Ridiculous Election 注意搜的时候到同一个点有不同的状态，判断的时候不是判断是否vis，而是要看当前的step和上一次的比较dp[s][i][j]表示到达s状态用了i次操作一和j次操作二的结果然后注意输出答案的时候要在终点枚举所有的i和j 05:42点 写的时候想得复杂了，其实注意到可以交换顺序，所以这个东西其实只需要每次找两个数操作一下，然后放回去就好了。这样甚至考虑到了括号嵌套的问题 减法和除法是有顺序的，所以要两种都做一下 ref 这个题 这里面还要处理不能整除的情况，要用double = = 06:A Knight’s Journey 深搜注意回退删除标记 = =用时间戳表示vis数组的时候，不是每个 case 开始的时候都清空，需要保证全局唯一 07:Sudoku 数独，多case要初始化，深搜回退要恢复状态= = 10:股票买卖 ll[i] 表示 i 左侧极差rr[i] 表示 i 右侧极差这样答案就是 $max{ll[i], rr[i + 1]}$ 先用 ll[i] 得到 i 左侧最小的数和a[i]的差，然后对ll[i]求个前缀 max 就好了 12:开餐馆 dp[i] 最后一个在 i 开，最大的价值答案是数组的最大值 11:Tour POJ 2677 想了好几天，把一来一回的路径拆开，考虑$dp[i][j] 表示 1..i 和 1..j 两条路径$，然后考虑下一个点（i）是从谁接过来的 https://blog.csdn.net/xiaoxiaoluo/article/details/7636592 这里人为要求 $i \\geq j$ https://blog.csdn.net/ECNU_LZJ/article/details/71211855 这个更直观，把路径反向，方便转移 14:DNA 调了半天，甚至还换了种思路写，最后发现问题是在于求重叠部分的长度又写错了 首先没想到的是，如果一个串被另一个包含了，那么短的直接删掉就好了 思路一：长度很少，枚举全排列，拼起来 思路二：状压dp，$dp[st][i]$表示已经拼了st里面这些字符串i是最后一个的答案，记忆化搜之 求重叠部分的写法： 123456int res = std::min(len[a], len[b]);while (res) &#123; if (strstr(s[b], s[a] + len[a] - res) == s[b]) break; --res;&#125;return res; 论善用strstr的重要性 13:上机 按顺序考虑，前i个人的结果受前i-1个人的结果和第i与第i-1的顺序的影响 设计：$dp[i][l][r]$表示处理到第i个人，左侧 / 右侧有没有人 转移：dp[i][k][t] = std::max(dp[i][k][t], dp[i - 1][j][k ^ 1] + a[i][k + t]); 注意带如果第i个人左侧的状态是k，那么对于第i-1个人而言，他右侧的状态就是k ^ 1 注：用k + t简化，a[i][0]就是都没人，a[i][1]就是有一个,a[i][2]就是两侧都有人 这里的j是不造成影响的，转移的过程中要考虑每一个j（0 / 1）","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://ir1d.cf/tags/程设/"}]},{"title":"openjudge动态规划","slug":"cssx/openjudge动态规划","date":"2018-05-25T11:42:16.000Z","updated":"2018-06-24T11:40:54.559Z","comments":true,"path":"2018/05/25/cssx/openjudge动态规划/","link":"","permalink":"http://ir1d.cf/2018/05/25/cssx/openjudge动态规划/","excerpt":"感觉之前使用md的姿势好像不对 = =","text":"感觉之前使用md的姿势好像不对 = = ref: https://fancypei.github.io/OpenjudgeDP/ LCIS $O(n^2)$ dp[i][j] 表示a串前i个和以b[j]结尾的串的LCIS的长度 转移是： dp[i][j]=max(dp[i][j],dp[i-1][k]+1) a[i]==b[j]&amp;&amp;b[k]&lt;b[j] 1&lt;=k&lt;j dp[i][j]=max(dp[i][j],dp[i-1][j]) a[i]!=b[j] 123456789101112131415for (i = 1; i &lt;= m; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; dp[i][j] = 0; if (x[i] != y[j]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; for (k = 1; k &lt; j; ++k) &#123; if (dp[i][j] &lt; dp[i - 1][k] &amp;&amp; y[k] &lt; y[j]) &#123; dp[i][j] = dp[i - 1][k]; &#125; &#125; dp[i][j] += 1; &#125; &#125;&#125; 第二个式子i从i-1转移过来，所以可以把i放到外层。这样内层循环的时候a[i]是固定的。根据第一个式子，a[i] == b[j] &gt; b[k]，实际上要找的是b[j] &lt; a[i] 的最大的dp[i - 1][j]，在内层循环的同时存一下就好了，不需要再去枚举那个k了。所以平方的复杂度就能做了 1234567891011121314for (i = 1; i &lt;= m; i++) &#123; mlen = 0; for (j = 1; j &lt;= n; j++) &#123; dp[i][j] = dp[i - 1][j]; //更新mlen if (y[j] &lt; x[i] &amp;&amp; dp[i - 1][j] &gt; mlen) &#123; mlen = dp[i - 1][j]; &#125; //计算dp[i][j] if (y[j] == x[i]) &#123; dp[i][j] = mlen + 1; &#125; &#125;&#125; https://github.com/Ir1d/Fantasy/blob/master/POJ/2127.cpp （openjudge没有spj） 记录路径的姿势都忘光了= = 1234567x = n; p = 0;while (ans--) &#123; st[++p] = b[y]; while (a[x] != b[y]) --x; y = pre[x][y]; --x;&#125; ref: http://blog.fly2best.com/algorithm/2013/05/11/longges-common-increasing-subsequence/ 山区建小学 http://noi.openjudge.cn/ch0206/7624/ 四边形不等式 7627 鸡蛋的硬度 f[i][j]=min(1+max(f[i-1][t-1],f[i][j-t]) 1234567for (int i = 1; i &lt;= 100; i++) f[1][i] = i;for (int i = 2; i &lt;= 10; i++)for (int j = 1; j &lt;= 100; j++) &#123; f[i][j] = 1 + max(f[i - 1][0], f[i][j - 1]); for (int t = 2; t &lt;= j; t++) f[i][j] = min(f[i][j], 1 + max(f[i - 1][t - 1], f[i][j - t]));&#125; 9265:取数游戏 自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是相邻的两个不可以同时被取走. 答案是斐波那契数，考虑最后一个取(dp[i - 2])，或者不取（dp[i - 1]）. 9267:核电站 加强，变成不能连续m个 12345g(i, 0, m) dp[i] = 1LL &lt;&lt; i;--dp[m];g(i, m + 1, n) &#123; dp[i] = 2 * dp[i - 1] - dp[i - m - 1];&#125; 9268:酒鬼 不能连续取三个，问取出的最大权值和 123456// f是最远，g是到i结束// 答案是f[n]for (i = 3; i &lt;= n; i++) &#123; g[i] = v[i] + max(f[i - 2], v[i - 1] + f[i - 3]); f[i] = max(g[i], f[i - 1]);&#125; POJ3046 https://blog.csdn.net/jaihk662/article/details/77951670 需要滚动数组 dp[i][j]表示前i个集合取j个数的种类数 然后 $dp[i][j] = \\sum_{k=0}^{min(cnt_i, j)} dp[i - 1][j - k]$ 9288:Zju2061 Buy the Ticket 排队买票 卡特兰数 相当于在一个格点阵列中，从 (0, 0) 点走到 (n, m) 点且不穿过对角线 x = y 的方法数 。 最后答案要乘上排列数（阶乘） 6046:数据包的调度机制 区间dp，dp[i][j] 是把[i, j]这一段的数据包发出去的最小代价，然后转移的时候枚举这一段里面哪一个是最后发出的。因为是个栈，所以最后一个发出的那个包前面的是第一段，那个包后面的是第二段。 https://github.com/Ir1d/Fantasy/blob/master/openjudge/6046.cpp 4149:课程大作业 dp[i][S]表示前i天完成S的最小代价 过不了 dp[S]表示完成S的最小代价，每次枚举第一个完成哪个，记忆化搜索 https://github.com/Ir1d/Fantasy/blob/master/openjudge/4149.cpp 1481 Maximum sum ll[i]为以i为终点rr[i]为以i为起点 ls[i]为前i个rs[i]为后i个 边界数据 12312-1 -1 时间复杂度O(n) 162 Post Office dp[i][j]表示前i个位置放j个post office的最小代价转移是dp[i][j] = min{dp[k][j - 1] + cost[k + 1][i]};cost数组可以v^2p预处理 时间复杂度O(v^2p) 考虑优化：(四边形不等式) 证明略 决策变量k具有单调性 从而优化到O(v^2) 1759 LIS *lower_bound(dp, dp + n, a[i]) = a[i]; 1768 最大子矩阵 枚举起始与终点行，转化为最大子段和 1775 采药 01背包 1808 公共子序列 LCS 1944 吃糖果 Fibonacci 1996 登山 转化成求两遍LIS 2421 Exchange Rates 题目比较坑 dp[i][0], dp[i][1]分别是两种全部转化后最大多少 一定存在一种最优策略是每次全部转化的 2718 移动路线 dp[i][j] += dp[i - 1][j] + dp[i][j - 1]; 2728 摘花生 数字正方形 dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]) + a[i][j]; 2984 数字组合 dp[i][j] 表示前i个数拼成j的方案数 然后滚动数组优化成一维空间 2988 计算字符串距离 dp[i][j] 表示s的前i与t的前j的距离 然后转移就是分各个情况就好 注意和LCS不同之处在于预处理 LCS刷0即可 然而这个地方要12g(i, 1, n) dp[i][0] = i;g(i, 1, m) dp[0][i] = i; 2989 糖果 转移是有条件的 123456g(i, 1, n) f(j, 0, k) &#123; int tee = (j - a[i] % k + k) % k; dp[i][j] = dp[i - 1][j]; if (dp[i - 1][tee] || !tee) dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][(j - a[i] % k + k) % k] + a[i]);&#125; 3531 判断整除 原来这个条件很常见。。。 同上题 ………………刷表法的话就不用特判了= = 3532 最大上升子序列和 LIS 变个形 4977 怪盗基德的滑翔翼 求一下两个方向的LIS求max即可 4978 宠物小精灵之收服 二维费用的01背包问题 背包九讲(https://github.com/tianyicui/pack/blob/master/V2.pdf) 4982 踩方格 爆搜 或者打个表发现 12f[0] = 1,f[1] = 3;f[i] = f[i - 1] * 2 + f[i - 2]; 6045 开餐馆 dp[i]表示到i为止的最大收益 O(n^2T) 8787 数的划分 dp[i][j]表示将i分成j份的方案数dp[i][j]=dp[i-j][1]+dp[i-j][2]+dp[i-j][3]+…+dp[i-j][j-1]+dp[i-j][j]; 时间复杂度是n*k^2 O(n*k)的方法： dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j]; dp[i-1][j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+…+dp[(i-1)-(j-1)][j-1]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1]; 因此， dp[i][j]=dp[i-j][1]+dp[i-j][2]+…+dp[i-j][j-1]+dp[i-j][j]=dp[i-1][j-1]+dp[i-j][j]; 666 放苹果 假如将7个苹果放进3个盘子里，可以分2种情况考虑：1，空着一个盘子不放，即将7个苹果放进2个盘子里；2，先每个盘子均放进一个苹果，再按照本规则继续放下去。 于是有递推公式：F(X,Y)=F(X,Y-1)+F(X-Y,Y) F(X,1)，F(1,Y),F(0,Y),F(X,0)都等于1 当X&lt;Y时，即比如说将5个苹果放进8个盘子里，根据题意，和将5个苹果放进5个盘子是一样的结果 ①最少的盘子放了一个，这样每个盘子至少一个，n个盘子先放上n个，剩下的m-n个可以随便放②最少的盘子没有放，这样剩下的n-1个盘子还是随便放m个 6049 买书 考虑分别记录拼出i这个数最后一个用了啥 注意到拼数的方案与顺序无关，因此可以递增地来考虑 123456789101112131415161718if (i &gt;= 10) &#123;dp[i][0] += dp[i - 10][0];&#125;if (i &gt;= 20) &#123;dp[i][1] += dp[i - 20][0];dp[i][1] += dp[i - 20][1];&#125;if (i &gt;= 50) &#123;dp[i][2] += dp[i - 50][0];dp[i][2] += dp[i - 50][1];dp[i][2] += dp[i - 50][2];&#125;if (i &gt;= 100) &#123;dp[i][3] += dp[i - 100][0];dp[i][3] += dp[i - 100][1];dp[i][3] += dp[i - 100][2];dp[i][3] += dp[i - 100][3];&#125; 6252 通配符字符串匹配 dp[i][j]表示s[1..i]与t[1..j]是否匹配 12345678910g(i, 1, n) &#123; tee = dp[i - 1][0]; if (s[i] == '*') dp[i][0] = tee; g(j, 1, m) &#123; tee |= dp[i - 1][j]; // dp[i][j] if (s[i] == '?' || s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1]; if (s[i] == '*') dp[i][j] = tee; &#125;&#125; 7113 Charm Bracelet 01背包 747 Divisibility 同3531 判断整除 而且数据更强？ 奥妙重重 强烈怀疑3531放了个什么奇怪的数据 刷表法姿势不对竟然也能过= = 1234567891011dp[0][0] = 1;g(i, 1, n) &#123; scanf(\"%d\", &amp;x); x = abs(x); x %= k; f(j, 0, k) if (dp[i - 1][j]) &#123; dp[i][(j + x) % k] = 1; dp[i][((j - x) % k + k) % k] = 1; &#125;&#125;if (dp[n][0]) puts(\"Divisible\"); 7614 最低通行费 dp[i][j][k]表示到(i,j)走了k步的最小代价 7624 山区建小学 同162 Post Office 7625 三角形最佳路径问题 数字三角形 7627 鸡蛋的硬度 http://blog.csdn.net/jerry99s/article/details/48802527 8462 大盗阿福 saffah出过，2014暑假集训中 8464 股票买卖 DP……预处理后缀最大值、最大获利、前缀最大值之类的求一下对应组合的max 8467 鸣人的影分身 同666 8471 切割回文 dp[i]表示s[1..i]最小需要的切割次数 8780 拦截导弹 LIS 8782 乘积最大 dp[i][j]表示前i个分成j份 8785 装箱问题 01背包 90 滑雪 DAG最长路 8786 方格取数 费用流/DP","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"openjudge","slug":"openjudge","permalink":"http://ir1d.cf/tags/openjudge/"},{"name":"dp","slug":"dp","permalink":"http://ir1d.cf/tags/dp/"}]},{"title":"openjudge补习","slug":"cssx/openjudge补习","date":"2018-05-25T05:07:23.000Z","updated":"2018-06-23T04:51:31.883Z","comments":true,"path":"2018/05/25/cssx/openjudge补习/","link":"","permalink":"http://ir1d.cf/2018/05/25/cssx/openjudge补习/","excerpt":"","text":"8758 2的幂次方表示 印象中什么时候好像调了好久的样子，其实就是直接递归的做就好了 整数划分 12345dp[0][0] = 1;g(i, 1, n) &#123; g(j, 1, i) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];&#125;// dp[i][j] 是i分成j份的方案数 zipper 问A和B两个串 能否交叉组合成C，要求AB内部相对顺序不变 dp[i][j] 表示A[1..i]和B[1..j] 能否拼成C[1..i+j] 转移就判一下最后一个字符是否匹配 复杂的整数划分问题 第一行: N划分成K个正整数之和的划分数目第二行: N划分成若干个不同正整数之和的划分数目第三行: N划分成若干个奇正整数之和的划分数目 ref: https://blog.csdn.net/tp7309/article/details/54880495 n划分成可相同的正整数 dp[i][j] 表示把i分成不超过j的数的和dp[i][j] = dp[i][j - 1] + dp[i - j][j]要么每个数都小于j，要么至少有一个等于j，把那个j去掉。 i &lt; j时 dp[i][j] = 0 边界：dp[0][0] = 1; 不相同 dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1]要么每个数都小于j，要么有一个数等于j，把唯一的那个j去掉，剩下的数都小于j了。 k个数 dp[i][j] 表示把i分成j份dp[i][j] = dp[i - j][j] + dp[i - 1][j - 1]要么给之前的j组每个数加一，要么取出来一个1单独装一组 i &lt; j时 dp[i][j] = dp[i][i] 边界：dp[0][i] = 1; 分成奇数 f[i][j] 表示i分成j个正奇数g[i][j] 分成正偶数 g[i][j] = f[i - j][j]偶数来自每一组奇数加一f[i][j] = f[i - 1][j - 1] + g[i - j][j]奇数来自偶数加一，或者最后一个1单独一组边界：f[0][0] = g[0][0] = 1 6047:切蛋糕 dp[i][j[k]表示i*j大小的切k块的答案（最大块面积的最小值） 转移的时候就枚举横竖的切法就可以了 123456789101112131415161718g(i, 1, 20) &#123; g(j, 1, 20) &#123; dp[i][j][1] = i * j; g(k, 2, 20) &#123; dp[i][j][k] = oo; f(r, 1, i) &#123; f(p, 1, k) &#123; dp[i][j][k] = std::min(dp[i][j][k], std::max(dp[r][j][p], dp[i - r][j][k - p])); &#125; &#125; f(c, 1, j) &#123; f(p, 1, k) &#123; dp[i][j][k] = std::min(dp[i][j][k], std::max(dp[i][c][p], dp[i][j - c][k - p])); &#125; &#125; &#125; &#125;&#125; 感觉比之前菜多了…… 重开几页补补题吧QAQ","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"openjudge","slug":"openjudge","permalink":"http://ir1d.cf/tags/openjudge/"}]},{"title":"程设算法上机练习小结","slug":"cssx/程设算法上机练习小结","date":"2018-05-19T13:16:05.000Z","updated":"2018-06-23T04:52:09.816Z","comments":true,"path":"2018/05/19/cssx/程设算法上机练习小结/","link":"","permalink":"http://ir1d.cf/2018/05/19/cssx/程设算法上机练习小结/","excerpt":"","text":"练习一 A:浮点数求高精度幂 正常的高精度快速幂，处理小数点的位置注意一下 B:Integer Inquiry 高精度加法 C:Communication System 每一类选一个使得最后的 最小带宽/总价格 最大 可以枚举最小的带宽是啥 然后贪心找价格最小的 dp的话dp[i][j]表示到第i类，带宽是j的答案 当时一直在想j的范围没给不是很好办，后来看代码发现开到1k就可以了 代码： https://github.com/Ir1d/Fantasy/blob/master/POJ/1018.cpp 注意 POJ 1018 得用 C++ 交，不知道为啥 D:判断闰年 if就好了 E:生理周期 枚举或者CRT F:完美立方 枚举 G:画家问题 枚举第一行的结果，然后之后的操作就确定了，找答案最小的就可以了 H:恼人的青蛙 枚举？ I:放苹果 应该直接组合数吧？ dfs过了 J:古代密码 就是给每个字母的出现次序排个序看能不能对应上","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://ir1d.cf/tags/程设/"}]},{"title":"爬虫小结","slug":"爬虫小结","date":"2018-05-19T02:32:00.000Z","updated":"2018-05-19T02:35:14.446Z","comments":true,"path":"2018/05/19/爬虫小结/","link":"","permalink":"http://ir1d.cf/2018/05/19/爬虫小结/","excerpt":"","text":"爬虫小结 爬了个小站，其实对方主要是在防注入（？），并没有怎么反爬所以其实不太困难，美中不足的是写挂了好多地方，然后有懒得增量更新爬到的结果，所以反反复复算是爬了三次，给服务器带来了不少压力。 其实是第一次用py写模拟登录（惭愧） 首先是患者列表，在翻页的时候抓包发现没有请求，翻开发者工具发现是藏在IndexedDB里面，然后补习了一下导出的姿势 12345678910111213141516171819202122232425var db;var DB_NAME = '';var DB_VERSION = 1;var STORE_NAME = '';var request = indexedDB.open(DB_NAME, DB_VERSION);request.onupgradeneeded = function() &#123; // Create a new object store if this is the first time we're using // this DB_NAME/DB_VERSION combo. request.result.createObjectStore(STORE_NAME, &#123;autoIncrement: true&#125;);&#125;;request.onsuccess = function() &#123; db = request.result; // Enable our buttons once the IndexedDB instance is available.&#125;;var res;var transaction = db.transaction(STORE_NAME, 'readonly');var objectStore = transaction.objectStore(STORE_NAME);if ('getAll' in objectStore) &#123; // IDBObjectStore.getAll() will return the full set of items in our store. objectStore.getAll().onsuccess = function(event) &#123; res = event.target.result; &#125;;&#125; 然后就是常规操作，模拟登录什么的，然后有一个坑点是request库遇到302会跟着重定向过去，但是cookie没有存= = 解决方案是开个Session 12REQ = requests.Session()r = REQ.post(loginUrl, headers=header, data=payload) 对于Cookie的处理选择用dict，然后面向StackOverflow编程学习到了崭新的更新dict的操作 12dic = REQ.cookies.get_dict()cookie = &#123;**cookie, **dic&#125; 然后也学习到了从Chrome的工具里header变成python dict的方法和把dict变成Cookie串的方法= =回想当年自己真的是太naive了呀 1234567# Convert Chrome headers to Python's Requests dictionary dict([[h.partition(':')[0], h.partition(':')[2]] for h in rawheaders.split('\\n')])def gen(s): # Converts dict to cookie string res = \"\" for k in s: res += k + '=' + s[k] + ';' return res 以及regex中加个括号得到group可以只选中匹配出来的字符串的一部分，真的赞！ 捕捉异常的方法：123try:except Exception as e: logging.exception(\"message\") 创建文件夹： 123456if not os.path.exists('&#123;&#125;_res/&#123;&#125;'.format(CRAWL_ID, idx)): try: os.makedirs('&#123;&#125;_res/&#123;&#125;'.format(CRAWL_ID, idx)) except OSError as exc: # Guard against race condition if exc.errno != errno.EEXIST: raise # 套在 try except里面 下载图片： 1234photoRes = requests.get(curUrl, headers=newHeader)# if photoRes.status_code == 200:with open('&#123;&#125;_res/&#123;&#125;/&#123;&#125;.&#123;&#125;'.format(CRAWL_ID, idx, idNum, curName.split('.')[-1]), 'ab') as f: f.write(photoRes.content) 最后一个坑： 1photoNames = [x['picId'] for x in jsonRes['result'] if \"X光\" in str(x['tags'])] 注意到x[&#39;tags&#39;]可以是None 所以加上 str","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://ir1d.cf/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://ir1d.cf/tags/python/"}]},{"title":"程设语言部分笔记","slug":"cssx/程设语言部分笔记","date":"2018-05-19T02:27:43.000Z","updated":"2018-06-23T04:52:19.889Z","comments":true,"path":"2018/05/19/cssx/程设语言部分笔记/","link":"","permalink":"http://ir1d.cf/2018/05/19/cssx/程设语言部分笔记/","excerpt":"","text":"断更了好久…… 其实也说不清在忙什么…… 莫名其妙的…… 雾：下文内含大量typo（拼音输入法） OpenJudge - B:按距离排序 给struct重载() 来当比较器传给std::sort OpenJudge - G:你真的搞清楚为啥 while(cin &gt;&gt; n) 能成立了吗？ 123operator bool() &#123; // 重载强制类型转换&#125; 修改指针一定要小心，尤其是模板里面 *a = *b 注意指针指向的地址是否变了 是否只改变了值 OpenJudge - C:山寨版istream_iteratoroperator *() 重载解引用运算符 operator ++(int) 是后缀自增运算符 OpenJudge - E:很难蒙混过关的CArray3d三维数组模板类 写得很痛苦，的确没有蒙混过关，还是应该老实的…… 建议做法： a[i][j][k] 这个表达式的第一个[]返回一个内部类的对象，该内部类也重载了[],且返回值为指针。 必要时需重载对象到指针的强制类型转换运算符 OpenJudge - F:我自己的 ostream_iterator 刚开始一直在想怎么让他赋值进去就直接能输出，后来发现实际上是后面有一个++的过程，++的时候输出就好了。然后再就是*x=*a重载的是*运算符不是等号= = OpenJudge - A:List 简直惨痛。。。 merge自己到自己的操作要忽略掉就好了= = 果然还是应该写对拍 OpenJudge - F:冷血格斗场 听说是当年pkusc的题，就是找lowerbound 然后再找前面的一个 比较比较就好了 没考虑到的地方是可能lowerbound的前面找到的那个并不是id最小的，要再lowerbound一下= = OpenJudge - 08:编程填空：维护平面点 OpenJudge - H:编程填空：数据库内的学生信息 比较器的写法 123456789template &lt;class T&gt;struct Greater &#123; bool operator() (const T&amp; x, const T&amp; y) const &#123; return x &gt; y; &#125; typedef T first_argument_type; typedef T second_argument_type; typedef bool result_type;&#125;; upd：重写了 后三个typedef 不是必须的OpenJudge - 11:编程填空：数据库内的学生信息 太难了= = static的初始化方式 printf – %x 十六进制 期中复习 常引用：不是引用的内容不能修改，是不能通过常引用修改const T 或者 const T &amp;类型不能用来初始化 T&amp;类型，除非经过了强制类型转换调用内联函数的语句前必须已经出现内联函数的定义（整个函数体），不能只有声明同名函数只有参数表不同才算是重载，两个同名函数的参数表相同而返回值不同不是重载，是重复定义new分配的空间一定要delete释放，否则程序运行结束后也不会被系统收回一个string对象的大小（sizeof）是固定的（在不同编译器中并不相同，与字符串长度无关）string对象中只存放地址和其他信息大写字母ASCII码小于小写字母struct默认公有，class默认私有局部变量存储空间是动态分配在栈中的CTest* pArray[3] = {new CTest(4), new CTest(1, 2)}; 只生成了两个对象，第三个没有生成复制构造函数的参数一般用const引用，这样既能以常量对象，也能以非常量对象作为参数函数的参数对象以及作为函数返回值的对象，在消亡时也会引发析构函数调用12345678910CDemo::CDemo(int a, int b) &#123;// 构造函数&#125;CDemo dl;CDemo Test() &#123; // 返回值是临时对象 foo(); return dl;&#125;CDemo d4;d4 = 6; // 这里6先被转换成临时对象，然后再赋值。语句执行完毕后临时对象消亡，调用析构函数 并非所有对象生成的时候都通过上面的构造函数初始化，作为参数和返回值的时候是调用复制构造函数，需要另外再写不能通过对常量对象调用普通成员函数，但是可以调用const的两个成员函数的名字和参数表相同，但是一个const，另一个不是，算重载封闭类生成的时候先执行所有成员对象的构造函数，再执行封闭类自己的构造函数消亡的时候是先执行封闭类的析构函数，后执行成员对象的。常量型成员变量和引用型必须要在构造函数的初始化列表中初始化友元函数内部可以访问该类对象的private不能吧其他类的私有成员函数声明为友元交叉调用的时候允许写一个提前声明class s;但是在定义出现之前，不允许任何会导致该类对象被生成的语句。使用该类的指针或者引用是没有问题的可以声明另一个类是自己的友元友元关系不能传递类的非内联成员函数的函数体只能出现在某一个.cpp文件中，不能放在头文件中被多个.cpp文件包含，否则链接时会发生重复定义的错误如果编写了构造函数，则编译器不自动生成默认构造函数，一个类不一定会有默认（无参）构造函数，但是一定会有复制构造函数=只能重载为成员函数在delete之前判断是否是NULL注意赋值给自己的时候的指针的处理参数os只能是ostream的引用，而不能使ostream对象，是因为ostream的复制构造函数是私有的，不能生成参数对象类型强制转换运算符是单目运算符，只能被重载为成员函数 operator double() {}++a或者--a前置：CDemo&amp; operator ++();a++或者a--后置：CDemo operator ++(int);运算符重载不改变优先级不能被重载的运算符：. .*（成员指针访问运算符） :: ?: sizeof重载() [] -&gt;或者 赋值=时，只能重载为成员函数派生类的成员函数只能访问所作用的那个对象（this指向的）的基类保护成员，不能访问其他基类对象的基类保护成员如果一个派生类对象使用默认复制构造函数初始化的，那么他内部包含的基类对象也要用基类的复制构造函数初始化封闭类类似派生类对象生成的时候，先从上至下执行所有基类的构造函数，再按照成员对象的定义顺序执行各个成员对象的构造函数，最后执行自身的消亡时，先执行自身的，后面与够早的次序相反如果是public派生，派生类对象也是基类对象，如果是private或者protected，就不成立多态的函数调用语句被称为是动态联编的虚函数表的地址在对象存储空间的最前端成员函数（静态成员函数、构造函数、析构函数除外）中调用其他虚成员函数是多态的析构函数和构造函数中调用的虚函数不是多态只要基类中的某个函数被声明成虚函数，则派生类中的同名、同参数表的成员函数及时前面没写virtual也是虚函数虚析构函数：只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual声明，都是虚析构函数一个类如果定义了虚函数，则最好将析构函数也定义成虚函数独立的抽象类的对象不存在，但是被包含在派生类对象中的抽象类的对象是可以存在的抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能cerr clog 不能被重定向cerr 不使用缓冲区 clog 使用while (cin &gt;&gt; n) 是因为把ostream到bool的转换重载了 顺序容器：vector, deque, list关联容器：set, multiset, map, multimap容器适配器：stack, queue, priority_queuerend():只想容器中的第一个元素前面的位置的反向迭代器1for (auto it = v.rbegin(); it != v.rend(); ++it); 容器 迭代器功能 vector 随机 deque 随机 list 双向 set/ multiset 双向 map/ multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器 12345ostream_iterator&lt;int&gt; output(cout,\" \");copy (v.begin(), v.end(), output);std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dest1)); 考完试： 1234567template&lt;class T, int sz&gt;class A &#123; public: static int c;&#125;;template &lt; &gt; int A &lt;int, 40&gt;::c = 0;template &lt; &gt; int A &lt;int, 50&gt;::c = 1; const算不算重载什么时候需要在初始化列表里初始化","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://ir1d.cf/tags/程设/"},{"name":"C++","slug":"C","permalink":"http://ir1d.cf/tags/C/"}]},{"title":"efb转发微信消息到tg","slug":"efb转发微信消息到tg","date":"2018-03-10T15:57:50.000Z","updated":"2018-06-23T04:50:32.629Z","comments":true,"path":"2018/03/10/efb转发微信消息到tg/","link":"","permalink":"http://ir1d.cf/2018/03/10/efb转发微信消息到tg/","excerpt":"","text":"折腾很多坑 在NanoApe指点下得知应该装v1.6.6 然后就很好办啦 ref: https://konano.github.io/2018/02/17/EFB-use/ upd(2018.5.19): 经常掉线 其实很不好用= =","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"ehForwarderBot","slug":"ehForwarderBot","permalink":"http://ir1d.cf/tags/ehForwarderBot/"},{"name":"telegram","slug":"telegram","permalink":"http://ir1d.cf/tags/telegram/"}]},{"title":"安装wxPython","slug":"安装wxPython","date":"2018-02-28T23:55:54.000Z","updated":"2018-06-23T04:47:38.430Z","comments":true,"path":"2018/03/01/安装wxPython/","link":"","permalink":"http://ir1d.cf/2018/03/01/安装wxPython/","excerpt":"","text":"你可能需要这个【 https://github.com/wxWidgets/Phoenix/issues/412#issuecomment-346273560 甚至可能需要手动编译整个wxwidgets","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"wxPython","slug":"wxPython","permalink":"http://ir1d.cf/tags/wxPython/"}]},{"title":"telegram-bots","slug":"telegram-bots","date":"2018-02-24T03:49:44.000Z","updated":"2018-06-23T04:46:57.857Z","comments":true,"path":"2018/02/24/telegram-bots/","link":"","permalink":"http://ir1d.cf/2018/02/24/telegram-bots/","excerpt":"","text":"写 Telegram bot 的时候遇到了问题，一直在纠结为什么我的 bot 需要 /asdf@bot 而不是 /asdf 就行= = 最后发现问题在这里：https://core.telegram.org/bots#privacy-mode 官方API：https://core.telegram.org/bots/api 一些现成的整理：https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets 以及 TG bot 传文件大小是50M= = 图片是10M","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"telegram","slug":"telegram","permalink":"http://ir1d.cf/tags/telegram/"}]},{"title":"机器学习记录","slug":"机器学习记录","date":"2018-02-09T08:03:20.000Z","updated":"2018-06-23T04:47:43.635Z","comments":true,"path":"2018/02/09/机器学习记录/","link":"","permalink":"http://ir1d.cf/2018/02/09/机器学习记录/","excerpt":"","text":"[done] Andrew NG coursera 机器学习 cs229 https://see.stanford.edu/course/cs229 UFLDLUFLDL2西瓜书《机器学习》 机器学习实战 机器学习基石（林轩田）机器学习技法 李宏毅 配合着台湾林轩田的《机器学习基石+技法》把李航的《统计学习方法》这本书走一遍 http://speech.ee.ntu.edu.tw/~tlkagk/courses.htmlhttps://www.youtube.com/channel/UC2ggjtuuWvxrHHHiaDH1dlQ/playlists 花书 Neural Network for Machine Learning-coursera-多伦多大学 cs224n cs231n Neural Networks for NLP http://neuralnetworksanddeeplearning.com/chap1.html deeplearning http://speech.ee.ntu.edu.tw/~tlkagk/courses.htmlhttp://blog.csdn.net/zouxy09/article/details/8775360https://www.cs.ox.ac.uk/people/nando.defreitas/machinelearning/ drl CS 294 MIT 6.S191 (bilibili未搬运) https://www.youtube.com/watch?v=JN6H4rQvwgY&amp;index=1&amp;list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI David Silver https://www.coursera.org/specializations/machine-learning deeplearning.ai coursera http://gameaibook.org 《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》Machine Learning A Probabilistic Perspective Learning http://deeplearning.net/reading-list/","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ir1d.cf/tags/机器学习/"}]},{"title":"2017小结","slug":"notes/2017小结","date":"2018-02-08T04:11:09.000Z","updated":"2018-06-23T04:49:37.255Z","comments":true,"path":"2018/02/08/notes/2017小结/","link":"","permalink":"http://ir1d.cf/2018/02/08/notes/2017小结/","excerpt":"","text":"今天小年偶然看到学妹发的WC2018的节目，发现时间原来过得好快这三年WC上24OI都有节目，也算是很妙的一件事吧 好在一届更比一届强，并非不务正业XD本来以为都忘记了的事，突然发现原来记得清清楚楚翻了翻知乎上几个OI相关的问题，pyc问的时候我还是个上台拿衣服的孩子吧= =转眼间，大半的答主都不认识了高三一年下来，不那么跳了，写了很久的很长的东西，却还是完全没有剖析清楚内心出了些意外，不过还好无大碍高考还算可以，靠着pkusc的运气还是混进了园子还是很喜欢你可能每次写回忆录写得都是一篇流水 也并没有什么特别值得叙说的事就当是结局圆满吧2018 愿安 希望可以变得自信点愿大家诸事顺遂，永远行走在光明向上的路上。","categories":[{"name":"回忆录","slug":"回忆录","permalink":"http://ir1d.cf/categories/回忆录/"}],"tags":[]},{"title":"20180206comments","slug":"notes/20180206comments","date":"2018-02-06T14:24:42.000Z","updated":"2018-06-23T04:49:42.947Z","comments":true,"path":"2018/02/06/notes/20180206comments/","link":"","permalink":"http://ir1d.cf/2018/02/06/notes/20180206comments/","excerpt":"","text":"高中同学聚会，见到大家其实很开心 有人喝酒 听到了不少劲爆的消息 有个老哥还喝醉了 喝醉的老哥感觉很爱面子 一直反复在说高考 是梦魔吧……sigh 愿安 很容易就想起你了","categories":[{"name":"回忆录","slug":"回忆录","permalink":"http://ir1d.cf/categories/回忆录/"}],"tags":[]},{"title":"cprimerplus","slug":"cprimerplus","date":"2018-02-05T14:10:39.000Z","updated":"2018-06-23T04:50:36.553Z","comments":true,"path":"2018/02/05/cprimerplus/","link":"","permalink":"http://ir1d.cf/2018/02/05/cprimerplus/","excerpt":"","text":"八进制 023 %o %lo 十六进制0xdbf %x %lx &#39;\\007&#39;, &#39;\\07&#39;, &#39;\\7&#39;都是八进制表示 3.4l表示使数字成为long double类型，默认是double c只保证float有6位精度 当缓冲区满、遇到换行符、需要输入的时候刷新缓冲区 或者使用fflush()函数 %p输出指针 %% 百分号 %5.2f是字符宽度为5，小数点后2位的浮点数 %10d是右对齐 %-10d是左对齐 printf返回值是输出成功的个数printf的float和double都是%f而scanf的float是%fdouble是%lf","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"C","slug":"C","permalink":"http://ir1d.cf/tags/C/"}]},{"title":"bsgs","slug":"bsgs","date":"2018-01-28T04:06:16.000Z","updated":"2018-06-23T04:49:58.592Z","comments":true,"path":"2018/01/28/bsgs/","link":"","permalink":"http://ir1d.cf/2018/01/28/bsgs/","excerpt":"","text":"BSGS 可以用来求离散对数 http://kzoacn.is-programmer.com/posts/97193.html http://blog.csdn.net/FromATP/article/details/56013530 注意朴素的 BSGS 要求 a 和 c 互质 POJ 2471 用 map 很容易 TLE ，手动开 -O2 过的 #pragma GCC optimize(&quot;O2&quot;)交G++ 扩展BSGS是不断提取a和c的公因子直到互质 http://blog.csdn.net/clove_unique/article/details/51227328 简易hash= =把冲突的往后一个位置堆直到不冲突= =","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"BSGS","slug":"BSGS","permalink":"http://ir1d.cf/tags/BSGS/"}]},{"title":"矩阵乘法小优化","slug":"矩阵乘法小优化","date":"2018-01-27T23:56:59.000Z","updated":"2018-06-25T15:00:01.811Z","comments":true,"path":"2018/01/28/矩阵乘法小优化/","link":"","permalink":"http://ir1d.cf/2018/01/28/矩阵乘法小优化/","excerpt":"看叉姐的repo翻到矩阵相关的板子","text":"看叉姐的repo翻到矩阵相关的板子 然后发现里面有这样一句话 乘法的时候将$B$数组转置一下然后$C[i][j] = \\sum{A[i][k]\\times B[j][k]}$会有奇效。 然后操作了一番发现的确是这么回事 Qrz%%% 1234567891011121314srand(time(0));f(i, 0, 233) f(j, 0, 233) a[i][j] = rand(), b[i][j] = rand();double st = clock();f(i, 0, 233) f(j, 0, 233) f(k, 0, 233) c[i][j] += a[i][k] * b[k][j];double ed = clock();f(i, 0, 233) f(j, 0, 233) &#123; d[i][j] = b[j][i]; c[i][j] = 0;&#125;f(i, 0, 233) f(j, 0, 233) f(k, 0, 233) c[i][j] += a[i][k] * d[j][k];double e2 = clock();printf(\"%lf\\n\", ((e2 - ed) - (ed - st)) / CLOCKS_PER_SEC);printf(\"%d\\n\", CLOCKS_PER_SEC); 本机大概能差0.02s 以及惊讶地发现CLOCKS_PER_SEC在新电脑上是1e6了","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://ir1d.cf/tags/矩阵乘法/"}]},{"title":"大连六重","slug":"大连六重","date":"2018-01-27T23:28:40.000Z","updated":"2018-06-24T13:00:59.045Z","comments":true,"path":"2018/01/28/大连六重/","link":"","permalink":"http://ir1d.cf/2018/01/28/大连六重/","excerpt":"https://www.jianshu.com/p/d4881b876b8a","text":"https://www.jianshu.com/p/d4881b876b8a 忙了20多天组织完这个六重 也不知道是否值得 就当是神奇的经历吧 感谢大家的帮助 当天赶完了战报 想了好多 写起来感觉大学国文真的是白学了QAQ 准备的过程和出锅的时候甚至是满满的无力感 有种那年NOI的时候的flashback 可我怎么就没想到呢= = 不过好在是在大连做的 我们甚至可以拆了补一补做成正儿八经的六重 表白大连蓝军 2018.1.27.12:51 - 2018.1.28 14:42","categories":[{"name":"Ingress","slug":"Ingress","permalink":"http://ir1d.cf/categories/Ingress/"}],"tags":[{"name":"竹笋","slug":"竹笋","permalink":"http://ir1d.cf/tags/竹笋/"},{"name":"大连","slug":"大连","permalink":"http://ir1d.cf/tags/大连/"}]},{"title":"离散数学基础笔记","slug":"离散数学基础笔记","date":"2018-01-25T11:34:07.000Z","updated":"2018-06-23T04:52:44.237Z","comments":true,"path":"2018/01/25/离散数学基础笔记/","link":"","permalink":"http://ir1d.cf/2018/01/25/离散数学基础笔记/","excerpt":"","text":"完美的数学终于“自我相关”数理逻辑 – 用计算的方法代替人们思维中的逻辑推理过程命题演算、谓词演算悖论不能作为命题 – 真值不存在 – “这句话是错的”命题非真即假 – 这是个基本假设排中律 – 具有属性 / 不具有属性反证法就是利用的排中律 – 非假即真有穷事物可以逐个验证来判断真假 – 但是无穷事物无法逐一检验原子命题、复合命题、逻辑连接词形式化的第一步 – 抽象 – 仅关注命题的本质属性（真值）异或 – p xor q == $(p \\land \\lnot q) \\lor (\\lnot p \\land q)$p 蕴含 q – 仅在 p真q假 时为假命题公式用来把真值连接 可以看做是一个真值函数自然语言命题的形式化 – 经过抽象形式化为命题公式假言易位 – 逆否命题 – $a\\to b &lt;=&gt; \\lnot b \\to \\lnot a$归谬论 – $(a\\to b) \\land (a\\to \\lnot b) &lt;=&gt; \\lnot a$重言式代入原理 – 将重言式A的某个变元p替换为B 仍然是重言式命题公式的替换原理 – 将子公式的部分出现替换为逻辑等价的公式 得到的新命题公式和原来的逻辑等价证明逻辑等价式和逻辑蕴含式 – 真值表法、对赋值进行讨论、推演法（利用已知的，运用代入原理和替换原理）范式 – 把蕴含这个连接词去掉范式用于重言式和矛盾式的识别重言式识别：合取范式的每个析取子句都包含了至少一个互补文字对矛盾式识别：析取范式的每个析取子句都包含了至少一个互补文字对p蕴含q 利用蕴含等值式变成 $\\lnot p \\lor q$p双向蕴含q 利用等价等值式变为$(\\lnot p \\lor q)\\land(p \\lor \\lnot q)$或者$(p\\land q) \\lor (\\lnot p\\land\\lnot q)$利用德摩根律把否定词放到括号里（作用于文字）最后再用分配律一个公式的析取范式或合取范式都不是唯一的析取范式也可以同时是合取范式最为规范的范式 – 唯一性 – 主范式主析取范式 – 每个合取子句均恰好出现一次主合取范式 – 每个析取子句均恰好出现一次极小项只有唯一的成真赋值主析取范式包含的极小项的成真赋值也是主析取范式的成真赋值具有相同主析取范式的公式是等值的 – 属于同一个等值类主合取范式对应极大项和成假赋值等值类与真值函数一一对应功能完备集去掉冗余连接词得到极小的功能完备集 – 可以表示所有的真值函数Peirce记号 – $p \\downarrow q = \\lnot (p \\lor q)$形式系统 – 符号体系证明是演绎在公式集合为空集的时候的特例命题演算形式系统(PC)的公理 $A1:A\\to (B\\to A)$ $A2:(A\\to (B\\to C))\\to ((A\\to B)\\to (A\\to C))$ $A3:(\\lnot A\\to \\lnot b)\\to (B\\to A)$ 推理规则 – 分离规则$A, A\\to B / B$ 即A成立且已知A蕴含B时可以得到B成立PC的定理 – 有一个证明序列 – 是重言式演绎结果 – 存在演绎结果元（meta）定理 演绎公理 – $\\gamma \\vdash A \\to B \\iff \\gamma \\bigcup {A} \\vdash B$ 归谬定理 – $\\gamma \\bigcup {\\lnot A} \\vdash B, r \\bigcup {\\lnot A} \\vdash \\lnot B$，那么$\\gamma \\vdash A$ 穷举定理 – $\\gamma \\bigcup {\\lnot A} \\vdash B, \\gamma \\bigcup {A} \\vdash B$，那么$\\gamma \\vdash B$成立","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://ir1d.cf/tags/离散数学/"},{"name":"MOOC","slug":"MOOC","permalink":"http://ir1d.cf/tags/MOOC/"}]},{"title":"ubuntu视频加速","slug":"ubuntu视频加速","date":"2018-01-20T10:14:35.000Z","updated":"2018-06-23T04:47:26.718Z","comments":true,"path":"2018/01/20/ubuntu视频加速/","link":"","permalink":"http://ir1d.cf/2018/01/20/ubuntu视频加速/","excerpt":"","text":"mplayer -af scaletempo 用[和]控制速度 scaletempo是防止走音","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://ir1d.cf/tags/ubuntu/"}]},{"title":"ubuntu16.04安装pycaffe","slug":"ubuntu16-04安装pycaffe","date":"2018-01-18T08:44:44.000Z","updated":"2018-06-23T04:47:06.917Z","comments":true,"path":"2018/01/18/ubuntu16-04安装pycaffe/","link":"","permalink":"http://ir1d.cf/2018/01/18/ubuntu16-04安装pycaffe/","excerpt":"","text":"https://github.com/BVLC/caffe/wiki/Ubuntu-16.04-or-15.10-Installation-Guide 装pycaffe的时候要改Makefile.config的很多地方= = http://caffe.berkeleyvision.org/installation.html#python https://gist.github.com/titipata/f0ef48ad2f0ebc07bcb9","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://ir1d.cf/tags/ubuntu/"},{"name":"caffe","slug":"caffe","permalink":"http://ir1d.cf/tags/caffe/"}]},{"title":"程设笔记","slug":"cssx/程设笔记","date":"2018-01-16T01:46:37.000Z","updated":"2018-06-23T04:52:05.440Z","comments":true,"path":"2018/01/16/cssx/程设笔记/","link":"","permalink":"http://ir1d.cf/2018/01/16/cssx/程设笔记/","excerpt":"","text":"函数指针命令行参数位运算引用 - 引用作为函数的返回值不可通过常量指针修改其指向的内容动态分配空间内联函数、函数重载、缺省参数缺省参数可以在扩充函数参数是避免对原有的调用语句的修改类、成员函数、内联成员函数构造函数析构函数静态成员 – 全局 – 易于维护成员对象 – 封闭类友元函数、友元类 友元类关系不能传递、不能继承this指针比如有一个class C12C *p = NULL;p-&gt;magic(); 等价于12C *p = NULL;magic(p); 如果后一种语句合法那么前一种就合法常量对象常亮成员函数不应修改对象，也不能调用非常亮成员函数（静态除外）常引用避免构造函数的开销=返回值最好为引用 复制构造函数也要避免浅拷贝运算符可以重载为友元函数继承、派生继承关系、复合关系protected虚函数、多态 virtual关键字构造函数和析构函数中调用虚函数不是多态虚函数表会占用空间也有额外的时间开销 – 多态的函数调用过程是查询虚函数表一个基类的指针删除派生类对象的时候希望先调用派生类析构函数再调用基类的析构函数不允许虚函数作为构造函数抽象类中成员函数允许调用纯虚函数，但是构造函数、析构函数中不允许函数模板 – 泛型程序设计STL123std::ostream_iterator&lt;int&gt; output(std::cout, \" \");std::copy(a.begin(), a.end(), output);// 相当于是用 cout 输出 a 里面的元素，用空格分隔开 copy到vector的时候它不会自动扩空间智能指针 shared_ptr 不能托管数组的指针不能取地址的表达式是右值lambda表达式强制类型转换异常 八数码中不改变排列的奇偶性","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://ir1d.cf/tags/程设/"}]},{"title":"git代理","slug":"git代理","date":"2018-01-13T08:01:05.000Z","updated":"2018-06-23T04:46:27.635Z","comments":true,"path":"2018/01/13/git代理/","link":"","permalink":"http://ir1d.cf/2018/01/13/git代理/","excerpt":"","text":"123git config --global http.proxy socks5://127.0.0.1:1080git config --global --unset http.proxy","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ir1d.cf/tags/git/"},{"name":"代理","slug":"代理","permalink":"http://ir1d.cf/tags/代理/"}]},{"title":"ubuntu下解压文件乱码解决","slug":"ubuntu下解压文件乱码解决","date":"2017-11-23T10:03:33.000Z","updated":"2018-06-23T04:47:18.486Z","comments":true,"path":"2017/11/23/ubuntu下解压文件乱码解决/","link":"","permalink":"http://ir1d.cf/2017/11/23/ubuntu下解压文件乱码解决/","excerpt":"","text":"rar卸掉 unrar-free 安装 p7zip p7zip-full zipunzip -O GBK filename","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://ir1d.cf/tags/ubuntu/"},{"name":"解压","slug":"解压","permalink":"http://ir1d.cf/tags/解压/"}]},{"title":"icpc2017北京站","slug":"icpc2017北京站","date":"2017-11-20T12:10:54.000Z","updated":"2017-11-20T12:31:55.732Z","comments":true,"path":"2017/11/20/icpc2017北京站/","link":"","permalink":"http://ir1d.cf/2017/11/20/icpc2017北京站/","excerpt":"转自知乎","text":"转自知乎 如何评价？大概就是震惊！竟然在体育馆里走了60k步！ 很长时间一直在想是为什么要做这些事情 可能是因为会沾上光有大量的太阳卡 可能是因为有机会近距离向大佬掉头 可能是因为被女队圈粉 …… 后来感觉 可能是因为我也曾和你们一样吧 =_+ 我也曾对某些事情抱有十足的热情 但是如今却没有勇气了 看到各位 就好像自己真的也在赛场上潇潇洒洒 感谢大家这次精彩的区域赛 接了很多锅，后来解决了大部分也还是很妙的 各种bug似乎也没什么需要说明的【都过去啦 补：封榜后的气球嘛，到时间的时候现场的老师说不发了，后来好像裁判组老师过来要求发的。并不是志愿者自作主张鸽掉了气球 &gt;_&lt; 首先感谢科协主席郑学长，表面上看他只是主持抽奖环节，其实是他协调安排了大部分工作。 感谢小句读老师、卿学姐解答窝奇怪的问题。 感谢志愿者、工作人员的努力和大家的配合。 最后，希望wf可以工作组织更合理我们真的可以办好XD 话说， 本来说好十点炸群，其实是我找不到怎么解散群才拖了辣么久= = 匿了 祝大家今后顺利 后会有期 永远相信美好的事情即将发生","categories":[{"name":"回忆录","slug":"回忆录","permalink":"http://ir1d.cf/categories/回忆录/"}],"tags":[{"name":"icpc","slug":"icpc","permalink":"http://ir1d.cf/tags/icpc/"}]},{"title":"opencv作业笔记","slug":"Opencv","date":"2017-11-11T16:50:36.000Z","updated":"2018-06-23T04:46:36.360Z","comments":true,"path":"2017/11/12/Opencv/","link":"","permalink":"http://ir1d.cf/2017/11/12/Opencv/","excerpt":"","text":"计算概论花了一课时讲了下opencv 但是配置作业环境废了好大劲 最后放弃了vs的项目 而是转用ubuntu下直接安装opencv linux下边的安装看这个链接就好= = https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://ir1d.cf/tags/opencv/"}]},{"title":"travis调试笔记","slug":"travis调试笔记","date":"2017-11-10T18:36:03.000Z","updated":"2018-06-23T04:47:02.969Z","comments":true,"path":"2017/11/11/travis调试笔记/","link":"","permalink":"http://ir1d.cf/2017/11/11/travis调试笔记/","excerpt":"下午用TravisCI来实现自动部署到Github Release，踩了不少坑","text":"下午用TravisCI来实现自动部署到Github Release，踩了不少坑 after_script 是在 deploy 段结束之后执行的，after_success 或者 before_deploy 是在 deploy 之前，文档里面写得很清楚 别的文章里大多写得很详细，就是不能把自己 Github 账号的 Access Token 给 push 到 repo 里。我当时 push 的时候没有注意到加了进去，不过收到了 Github 的邮件说检测到 Token 被泄露，当前这个被自动注销掉了。 推荐使用travis setup releases 来完成.travis.yml的deploy部分的编写 1sudo gem install travis -v 1.8.8 --no-rdoc --no-ri 两步验证也是个坑，简而言之就是用上边这个travis工具来写deploy部分，不要去自己到处生成Token。记得选那个secure key。 如果build的时候出现HEAD detached 应该是需要在deploy里面加上skip_cleanup: true，不清楚为什么那个工具不能自己加上。 on tags: true的作用是只对打tag的build进行deploy操作 如果需要sudo要加上sudo: enabled 检查yml写得对不对可以去 http://lint.travis-ci.org/ 话说一个build是没有时间限制的，只不过如果长时间没有输出或者类似状况会被停掉 以及build是可以设置成定时进行的，要注意的地方是Github对一次commit的状态更新次数有限制，并不能无限制地 大概就这些 有点记不清了 反正还有问题可以再问嘛","categories":[{"name":"操作","slug":"操作","permalink":"http://ir1d.cf/categories/操作/"}],"tags":[{"name":"travis","slug":"travis","permalink":"http://ir1d.cf/tags/travis/"}]},{"title":"教学计划整理-文科","slug":"collections/教学计划整理-文科","date":"2017-09-29T14:57:44.000Z","updated":"2017-10-12T14:44:41.595Z","comments":true,"path":"2017/09/29/collections/教学计划整理-文科/","link":"","permalink":"http://ir1d.cf/2017/09/29/collections/教学计划整理-文科/","excerpt":"","text":"中文系汉语言文学专业历史学系世界史专业外国语学院法语专业精读 视听说 历史 国家的地区概况 笔译 口译 报刊选读 写作 文体学 语法 英语专业文学史 普通语言学 精读 写作 视听 口语 …… 还有好多 Qrz 艺术学院没找到美术 Qrz 经济学院学科基础课 数学 高数线代概统 经济 经济学原理 微观宏观经济学 计量经济学 太多了 就不整理了 只是一点缥缈的兴趣 在如山的作业和无尽的期许面前 加油 说不定就真的成了一名理论计算机科学家","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"http://ir1d.cf/tags/课程整理/"}]},{"title":"教学计划整理-理科","slug":"collections/教学计划整理-理科","date":"2017-09-29T13:43:41.000Z","updated":"2017-10-12T14:44:41.587Z","comments":true,"path":"2017/09/29/collections/教学计划整理-理科/","link":"","permalink":"http://ir1d.cf/2017/09/29/collections/教学计划整理-理科/","excerpt":"","text":"教学计划包括四部分： 公共与基础课、核心课程、限选课程、通识与自主选修课程 公共与基础课包括全校公共必修课和学科基础课程；核心课程指以该专业中最核心的理论和技能为内容的课程；限选课程包括原部分专业必修课、专业限选课程、跨院系课程；通识与自主选修课程包括专业选修课、本科生科研训练、跨院系课程或院系自主设立的其他课程模块 数院数学与应用数学分基础数学方向（宽口径），金融数学方向保研要求 基础数学9门选修课在三年级结束时完成5门 金融数学要求所有必选课 基础：突变函数、泛函分析、偏微分方程、拓扑学、微分几何、微分流形、数论基础、群与表示、基础代数几何 金融：数理统计、金融数学引论、应用随机过程、寿险精算、证券投资学、衍生证券基础 限选中选修1门：突变与泛函（或实变函数）、金融经济学、金融数据分析导论、非寿险精算、风险理论、应用随机分析 统计学概率论方向（可分流到数学与应用数学专业）必选：数理统计、应用随机过程 限选：实变函数、应用多元统计分析、偏微分方程、微分几何、测度论、应用随机分析、泛函分析、应用回归分析、拓扑学 统计学方向专业必选：数理统计、应用随机过程 限选：应用回归分析、抽样调查、实验设计、贝叶斯统计、应用多元统计分析、应用时间序列分析、统计学习、统计计算、非参数统计 生物统计学方向（可按照应用统计学专业审核学生毕业）必选：数理统计、应用回归分析 限选：贝叶斯统计、应用多元统计分析、应用时间序列分析、统计学习、统计计算、非参数统计、应用生存分析、生物信息学方法和应用、应用随机过程 保研准备略去 信息与计算科学计算数学方向必选：数值分析、数值代数 限选：突变函数、泛函分析、最优化方法、偏微分方程、流体力学引论、偏微分方程数值解、大数据分析中的算法 信息科学必选：信息科学基础、理论计算机科学基础、数理逻辑、集合论与图论、数字信号处理 限选：程序设计技术与方法、密码学、计算机图形学、计算机图像处理、软件工程、操作系统、数据库概论、算法设计与分析、信息安全、人工智能、机器学习 这还要信科有什么用。。。 数据科学与大数据必选：数理统计、应用多元统计分析 限选：突变函数、应用回归分析、贝叶斯统计、应用时间序列分析、统计计算、统计学习或机器学习、程序设计实习、数据结构与算法、并行程序设计原理、数据整合与清理、算法设计与分析、数据库概论、自然语言处理导论、数据库仓库与数据挖掘、最优化方法或凸优化 信科 有纸质版的所以略过元培（跨学科类）数据科学与大数据技术专业核心：数据科学导引、概率论、数理统计、数值与计算方法、分布与并行计算、人工智能、深度学习、统计机器学习、大数据分析中的算法、最优化方法或者凸优化","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"http://ir1d.cf/tags/课程整理/"}]},{"title":"通识教育整理-理科","slug":"collections/通识教育整理-理科","date":"2017-09-29T06:01:05.000Z","updated":"2017-10-12T14:44:41.578Z","comments":true,"path":"2017/09/29/collections/通识教育整理-理科/","link":"","permalink":"http://ir1d.cf/2017/09/29/collections/通识教育整理-理科/","excerpt":"","text":"数学科学学院高等代数《高等代数》 北京大学数学力学系几何与代数教研室代数小组 抽象代数《抽象代数》 赵春来《代数学引论》 丁石孙 几何学《解析几何》 尤承业《解析几何》 丘维声 概率论《概率论》 何书元 《概率论引论》 汪仁官 《随机数学》钱，敏平 叶俊 《概率论基础》 李贤平 复变函数《复变函数》 谭小江 伍胜健Complex Analysis, Ahlfors L.V, 《简明复分析》 龚升 常微分方程《微分方程定性理论》 丁同仁 数学模型《数学模型讲义》 雷功炎 物理学院数学物理方法《数学物理方法》 吴崇试《数学物理方法习题集》 武仁Advanced Calculus for Applications, F.B.Hildebrand 理论力学《理论力学》 刘川Classical Mechangics, Herbert GoldsteinMechanics, L.D.Landau and E.M.Lifshitz 热力学与统计物理《热力学统计物理》 汪志诚《热力学与统计物理学》 林宗涵 平衡态统计物理// 同上 电动力学《电动力学简明教程》 俞允强 量子力学《量子力学导论》 曾谨言 固体物理学《固体物理学》 韩汝琦 《固体物理基础》 阎守胜 近代物理实验《近代物理实验》 吴思 核物理与粒子物理专题实验《辐射物理》 丁富荣 《核物理实验方法》 吴治华 前沿物理实验综合物理实验激光实验《激光实验》 北京大学物理学院基础物理教学实验中心 北京大学物理学院光学所 激光实验教学组 计算物理学《数值分析与算法》 喻文健《数值分析》 李庆扬 基础天文《天文学新概论》 苏宜 《天文学教程》 胡中为Fundamental Astronomy 天体物理《天体物理导论》 徐仁新 宇宙探测新技术引论Principles of Long Baseline Stellar Interferometry Ed. By P.R.LawsonInterferometry and Synthesis in Radio Astronomy A.R.Thompson 化院生科城环地空跳过Qrz心理与认知科学学院普通心理学《心理学与生活》 格里格·津巴多 心理统计《心理与行为科学统计》 甘怡群，张轶文，邹玲《现代心理与教育统计学》 张厚璨 社会心理学《社会心理学》 戴维·迈尔斯 实验心理学《实验心理学》 朱滢 心理测量Psychological testing: principles, applications, and issues 《心理学论文写作规范》 Handbook of Psychological Assessment 发展心理学《发展心理学：探索人生发展的轨迹》《发展心理学——人的毕生发展》 生理心理学Physiology of Behavior 认知心理学《认知心理学》 组织管理心理学《组织管理心理学》王垒 变态心理学《变态心理学》钱铭怡 信科数学分析信息科学技术概论程序设计实习数据结构与算法集合论与凸轮《离散数学教程》 耿素云 计算机系统导论csapp 代数结构与组合数学《离散数学教程》 Fundamental Approach oto Discrete Mathematics Discrete Mathematics Structures 算法设计与分析计算机组成与系统结构实习概率论与随机过程数学物理方法概率统计量子力学工学院环科跳过","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"http://ir1d.cf/tags/课程整理/"}]},{"title":"通识教育整理-文科","slug":"collections/通识教育整理-文科","date":"2017-09-28T14:51:09.000Z","updated":"2017-10-12T14:44:41.551Z","comments":true,"path":"2017/09/28/collections/通识教育整理-文科/","link":"","permalink":"http://ir1d.cf/2017/09/28/collections/通识教育整理-文科/","excerpt":"","text":"从元培大佬获得核心课程手册 整理一下通识教育 先写文科的吧 好向往的 中国语言文学系古代汉语阅读古代文献 《古代汉语》 郭锡良 现代汉语现代汉语语法学的入门知识 《现代汉语》 北京大学中文系现代汉语教研室编 中国古代文学史中文系主干基础课 《中国古代文学史》 袁世硕，陈文新（“马克思主义理论研究和建设工程”教材） 《中国文学史》 袁行霈 《中国文学史参考资料简编》 北京大学古代文学教研室 语言学概论讲解语言学基础知识 《语言学纲要》 叶蜚声 徐通锵 中国现代文学史《中国现代文学三十年（修订本）》 钱理群 温儒敏 吴福辉 中国当代文学《中国当代文学史》 洪子诚 《中国当代文学作品精选》 谢冕 洪子诚 文学原理主干基础课 《文学理论》 童庆炳 李准（”马克思主义理论研究和建设工程“教材）《文学原理》董学文 张永刚 《文学理论的未来》 拉尔夫·科恩 《当代学术入门——文学理论》乔纳森·卡勒 《论语》选读《孟子》选读经典讲读《中国古代典籍导读》 鲁惟一 中文工具书《中文工具书教程》朱天俊 李国新 中国古代文化《中国文化史纲要》 吴小如，刘宁 《中国古代文化史》 古代典籍概要《史部要籍解题》 王树民 《四库全书总目》 永瑢 比较文学原理《比较文学概论》 曹顺庆 孙景尧《比较文学原理新编》 张辉 陈跃红 民间文学概论《民间文学教程》 段宝林 阅读与写作《新编大学实用写作训练》 中国现代文学中国当代文学作品中国民俗与社会生活中国古代文化基础《中国古代文化史》 阴法鲁 中国人文地理《中国文化地理概述》胡兆量《中国历史人文地理》邹逸麟 考古历史哲学跳过外国语学院摘录窝感兴趣的法语精读《法语教程》 王文融 《大学法语课本》 杨维仪 法国文学史和文学选读《法国文学选集》《欧洲文学史》 西班牙语精读《现代西班牙语》 董燕生 西班牙语文学史和文学选读《西班牙文学史》沈石岩 《西班牙文学选集》刘永信《西班牙文学》（黄金世纪研究） 陈众议《二十世纪西班牙小说》王军 拉丁美洲文学史和文学选读《拉丁美洲文学史》 赵德明《拉丁美洲文学选集》 郑书九《西班牙与西班牙语美洲诗歌导论》 赵振江 英语精读《College English(2)》 周珊凤 张祥保 《北大英语精读》 韩敏中 英国文学史The Norton Anthology of English Literature M.H. Abrams et al. The Norton Anthology of English Literature, volumes D - F, Stephen Greenblatt 普通语言学General Linguistics Robins, R.H. Linguistics: A Course Book Hu Zhuangling 英译汉《大学英汉翻译教程》 王治奎《翻译技巧指导》 黄龙《中国译学理论史稿》 汉译英《新编汉英翻译教程》 陈宏微 李亚丹 美国文学史与选读Norton Anthology of American Literature. Norton Editors 法语精读《大学法语课本》 齐香 法语试听说《法语教程》 王文融《Festival 2》 Sylvie Poisson-Quinton《走遍法国》(Reflets II) 卡佩勒 欧洲史《欧洲史》 诺曼·戴维斯 世界史通论《世界文明史》 高毅 《世界史》 齐世荣 《全球通史——1500年后的世界》 外国史学史《西方史学史》 张广智 艺术史概论《什么事艺术学》朱青生 中国古代史《中国式纲要》翦伯赞 《中国古代简史》张帆 中国历史文选《新编中国历史文选》 中世纪欧洲史《欧洲中世纪史》 朱迪斯·本内特 艺术学院艺术学原理《艺术学原理》王一川 美术概论《艺术发展史》贡布里希 《中国绘画三千年》 杨新 《西方美术史十五讲》 丁宁 音乐概论自编讲义 参考： A history of Western Music, An Outline History Of Music, 中国传统音乐概论， 民族音乐概论，音乐人类学导论，中国传统音乐概论，20世纪西方音乐 影视理论与批评《影视批评学》 李道新 《影视鉴赏》 陈旭光 《中国电影批评史（1897-2004）》李道新 创意写作文化产业导论《文化产业导论》 向勇 艺术心理学《心理学史》 赫尔穆特·E.吕克 跨文化艺术传播学《跨文化艺术传播》 林一 Communication Between Cultures, Samovar Larry A. 中西方音乐专题《西方文明中的音乐》 保尔·亨利·朗Western Music in Context, Walter Frisch《乐贼心弦：中国音乐》 刘小龙 世界美术简史《加德纳世界艺术史 Gardner’s Art Through the Ages》 西方艺术学原著导读The Art of Art History: A Critical Anthology 中国艺术学原著导读人间词话及评论会变 中国美学史大纲 古话品录 六朝画论研究 文心雕龙注 书谱译注 司空图二十四诗品辩伪 林泉高致 画禅室随笔 石涛画学本义 中国艺术精神 意境 国关法院信管社会政管新传经济光华国发跳过","categories":[],"tags":[{"name":"课程整理","slug":"课程整理","permalink":"http://ir1d.cf/tags/课程整理/"}]},{"title":"初等数论及其应用 - 第一章","slug":"enti1","date":"2017-09-28T07:19:06.000Z","updated":"2018-06-23T04:46:16.035Z","comments":true,"path":"2017/09/28/enti1/","link":"","permalink":"http://ir1d.cf/2017/09/28/enti1/","excerpt":"","text":"算术基本定理：没个正整数可以按递增次序唯一地写成素数的乘积 现代数论的发展始于高斯 二次互反律 这个定律把素数$p$是否为模另一个素数$q$的完全平方与$q$是否为$p$的完全平方联系起来 找出大素数和分解大数在时间上的强反差是$RSA$密码系统的基石 $RSA$系统中，用户公私两把秘钥，每个用户可以用别人的公钥来加密信息，但只有拥有相应私钥的用户才能解密 一个方程若要求解为整数，则成为丢番图方程 费马大定理 $$x^n + y^n = z^n$$若$n$是大于$2$的整数，这个方程没有整数解$(x, y, z)$，这里$xyz \\neq 0$ 1995年由怀尔斯（Wiles）给出第一个证明 梅森（Mersenne）素数 形为$2^p - 1$ 看起来就是BOINC里面的某个项目= = 动手实验是研究数论所不可缺少的一部分 数学归纳法是数论（和许多数学分支）的最重要证明方法之一 整数在数论的研究中扮演着重要的角色 良序性质(The Well-Ordering Property) 每个非空的正整数集合都有一个最小元 良序性质可以作为定义正整数集合的公理 如果存在整数$p$和$q \\neq 0$，使得$r=\\fracpq$，则称实数$r$是有理数。如果$r$不是有理的，啧称为无理数 证明$\\sqrt(2)$是无理数 假设 数$\\alpha$称为代数数，如果它是整数系多项式的根；也就是说，$\\alpha$是代数数，如果存在整数$a_0, \\cdots, a_n$，使得$a_n\\alpha^n+a_{n-1}\\alpha^{n-1}+\\cdots+a_0 = 0.$如果$\\alpha不是代数数，称之为超越数$","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"初等数论及其应用","slug":"初等数论及其应用","permalink":"http://ir1d.cf/tags/初等数论及其应用/"}]},{"title":"笔记","slug":"笔记","date":"2017-09-28T07:14:39.000Z","updated":"2018-06-23T04:49:11.698Z","comments":true,"path":"2017/09/28/笔记/","link":"","permalink":"http://ir1d.cf/2017/09/28/笔记/","excerpt":"","text":"用来统计挖的坑 初等数论及其应用 网络科学引论 算法导论 Multivariable Calculus","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/tags/笔记/"}]},{"title":"Codeforces Round 435 (Div. 2)","slug":"cf/cf862","date":"2017-09-26T14:49:31.000Z","updated":"2018-06-23T17:56:53.720Z","comments":true,"path":"2017/09/26/cf/cf862/","link":"","permalink":"http://ir1d.cf/2017/09/26/cf/cf862/","excerpt":"Codeforces Round #435 (Div. 2) 100场div1指日可待【","text":"Codeforces Round #435 (Div. 2) 100场div1指日可待【 A问最少对集合修改几次，使得集合的mex值是给定的值 从小到大处理即可 B A loop is an edge, which connects a node with itself. Graph doesn’t contain multiple edges when for each pair of nodes there is no more than one edge between them. A cycle and a loop aren’t the same . 问可以往一个树最多加多少边使得新图仍然是二分图 注意到树本身是二分图，加边必然是在两个点集之间，而这些边最多有$l * r$条，已经有了$n - 1$条，所以答案显然 注意建树要加双向边，以及爆int的问题别忘了开long long C要求构造一个大小为n的集合使得集合里的数xor和为x 且集合里的数不超过1e6 注意到n是1e5而数是1e6这个限制条件，就是暗示$2^17$可以用来区分（不会重复而且不会超出） 然后就可以先放$1, 2, 3, \\cdots, n - 3$ 记它们的xor和是s 那么此时后三个数的xor和是$s xor x$ 就可以放$0， 2^17， 2^17 xor s xor x$ 注意题中要求所有数不能相同，所以如果s和x是相等的，后两个数就相等了就不合题意了 所以此时放$2^17, 2^18, 2^17 xor 2^18$ 至于为什么选择$2^17$和$2^18$，是为了$2^17 xor 2^18$和$2^17 xor x xor s$的值始终大于1e5 就是那个$2^17$的最高位是1然后它和别的数那一位是0的数xor之后答案那位是1就保证了比1e5大 D交互题 每次可以查询一个01串和某个给定的01串的hamming distance（编辑距离） 然后要求在15次查询之内确定01串中一定是0的一个位置和一定是1的一个位置即可 要记得flush缓冲区 题意不是要完全确定01串，只要确定一个0一个1即可 这个查询的核心操作是要得到一个区间里的0/1的个数 用类似前缀和的思路，我们先查询全是1的串的答案然后到时候减一下就好了 酱紫之后发现可以再查询$011111…$然后就得到第一个数是0还是1了 之后找另一个数的位置，不难发现可以二分最左侧的那个，即只要不是连续的那么就有一个要找的数出现了 E给a和b两个数列定义f函数并求值 $f(j) = |\\sum_{i=1}^n(-1)^{(i-1)}*(a_i-b_{i+j})|$ 每次区间加一个数 然后 查询所有f(j)的最小值 注意到可以把f(f)的式子拆开变成$|\\sum_{i=1}^n{i-1}a_i+\\sum_{i=1}^n(-1)^ib_{i+j}|$ 然后发现前一项是定值，而且整个式子在绝对值里面，如果前一项值是c，每次只需要找和-c最接近的一个后一项就行了 换言之，可以用一个set维护所有的后一项 对于修改操作，如果修改的区间长是偶数，发现加了多少次就减了多少次 如果是奇数，那就看l的奇偶性判断是加还是减 巧妙之处在于发现求这个最值不需要每次遍历来找，只需要这个值尽可能接近0就行，而且修改是对a操作的b一直不变，所以XD std用了一个非常巧妙的方法在一次循环里得到了对于所有j的第二项和 注意j变到j+1的时候是要取相反数然后对第一个和最后一个数加加减减 F有n个字符串，q个操作 第一种是查询$[a, b]$的某个子区间，使得区间长度乘上区间lcp的值最大 第二种是修改某个字符串 // 先坑着= = 求出相邻的lcp长度，区间lcp等于区间最小值 标程是对h分类，小的用线段树维护，大的直接set 学习了下nbc的代码 不是很懂QAQ","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://ir1d.cf/tags/codeforces/"}]},{"title":"cpppp","slug":"cpppp","date":"2017-09-22T00:38:14.000Z","updated":"2018-06-23T04:50:38.001Z","comments":true,"path":"2017/09/22/cpppp/","link":"","permalink":"http://ir1d.cf/2017/09/22/cpppp/","excerpt":"","text":"计概课对语言知识要求好高 觉得应该着手认认真真的学习c++ 于是借来室友的C++ primer plus学习这一套理论 tag 是 cpppp 的都会是相关的笔记 hmmm 留给程设好了……","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ir1d.cf/categories/笔记/"}],"tags":[{"name":"cpppp","slug":"cpppp","permalink":"http://ir1d.cf/tags/cpppp/"}]},{"title":"LSB","slug":"ctf/LSB","date":"2017-08-25T08:54:53.000Z","updated":"2017-10-12T14:44:41.847Z","comments":true,"path":"2017/08/25/ctf/LSB/","link":"","permalink":"http://ir1d.cf/2017/08/25/ctf/LSB/","excerpt":"","text":"感觉是个有趣的东西 用steganabara-1.1.1.jar过滤 肉眼识别了一波","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"attachment","slug":"ctf/attachment","date":"2017-08-25T08:24:33.000Z","updated":"2017-10-12T14:44:41.847Z","comments":true,"path":"2017/08/25/ctf/attachment/","link":"","permalink":"http://ir1d.cf/2017/08/25/ctf/attachment/","excerpt":"","text":"就是一个txt压成了zip封在php里面 就是图种的感觉= = 学到了这个 foremost -i attachment.php","categories":[],"tags":[]},{"title":"caesar2","slug":"ctf/caesar2","date":"2017-08-25T06:03:41.000Z","updated":"2017-10-12T14:44:41.830Z","comments":true,"path":"2017/08/25/ctf/caesar2/","link":"","permalink":"http://ir1d.cf/2017/08/25/ctf/caesar2/","excerpt":"","text":"先把16进制转换成10进制的ascii码 然后就是枚举偏移量看得到的认不认识 就行了= = guesswork 真的猜不出来= =","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"regex","slug":"ctf/regex","date":"2017-08-24T22:47:57.000Z","updated":"2017-10-12T14:44:41.830Z","comments":true,"path":"2017/08/25/ctf/regex/","link":"","permalink":"http://ir1d.cf/2017/08/25/ctf/regex/","excerpt":"","text":"匹配空字符串：/^$/ 匹配wechall：/^wechall$ 匹配特定文件名的图片后缀：/^wechall4?\\.(?:jpg|gif|tiff|bmp|png)$/ 需要对文件名添加捕获分组：/^(wechall4?)\\.(?:jpg|gif|tiff|bmp|png)$/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"limited_access","slug":"ctf/limited-access","date":"2017-08-23T09:42:56.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/limited-access/","link":"","permalink":"http://ir1d.cf/2017/08/23/ctf/limited-access/","excerpt":"","text":".htaccess里面写限制了GET需要验证123&lt;Limit GET&gt;require valid-user&lt;/Limit&gt; 所以换成POST就好了 POST的新姿势 123&lt;form method=\"POST\" action=\"https://www.wechall.net/challenge/wannabe7331/limited_access/protected/protected.php\"&gt;&lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt; 当然curl也行 curl -v -H &quot;Cookie: [WC=asdf]&quot; -X POST http://www.wechall.net/challenge/wannabe7331/limited_access/protected/protected.php 酱紫","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"auth_bypass2","slug":"ctf/auth-bypass2","date":"2017-08-23T07:07:11.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/auth-bypass2/","link":"","permalink":"http://ir1d.cf/2017/08/23/ctf/auth-bypass2/","excerpt":"","text":"2比1多了一个密码校验的过程 sql里面union可以把select结果合并到一起 username：’union select 1,’admin’,’e10adc3949ba59abbe56e057f20f883 password:123456 把username代入之后得到的是这个 SELECT * FROM users WHERE username=’’union select 1,’admin’,’e10adc3949ba59abbe56e057f20f883’ result中肯定就有 1,’admin’,’e10adc3949ba59abbe56e057f20f883’ 这样就构造出来了 result[&#39;password&#39;] 这里可以试着跑sql指令 https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_columns","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"simplesub1","slug":"ctf/simplesub1","date":"2017-08-23T06:34:41.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/simplesub1/","link":"","permalink":"http://ir1d.cf/2017/08/23/ctf/simplesub1/","excerpt":"","text":"Simple Substitution I http://quipqiup.com/ 这个太厉害了 刚开始找Clues往里填找了半天都不好使 后来删掉了直接solve= = 就出来了","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"globals","slug":"ctf/globals","date":"2017-08-23T06:11:45.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/globals/","link":"","permalink":"http://ir1d.cf/2017/08/23/ctf/globals/","excerpt":"","text":"Register Globals 将所有提交的参数注册为全局变量 注意到这一段 123if (strtolower($login[0]) === 'admin') &#123; $chall-&gt;onChallengeSolved(GWF_Session::getUserID());&#125; 所以直接http://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin 就好了","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"transposition1","slug":"ctf/transposition1","date":"2017-08-23T04:06:40.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/transposition1/","link":"","permalink":"http://ir1d.cf/2017/08/23/ctf/transposition1/","excerpt":"","text":"http://tholman.com/other/transposition/ 然后调那个key length试到2发现好像能看懂= = UPDATE noescvotes SET $who=$who+1 WHERE id=1 把 who 替换成 barack=111,bill=bill 最开始没找到上哪里传这个名字以为只能点按钮= = 然后突然发现地址直接输就好了 这个直接把who改成 barack`=111 会出问题= = 哎这样就好了 ？vote_for=bill`=111;#","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"encodings1","slug":"ctf/encodings1","date":"2017-08-23T01:55:07.000Z","updated":"2017-10-12T14:44:41.815Z","comments":true,"path":"2017/08/23/ctf/encodings1/","link":"","permalink":"http://ir1d.cf/2017/08/23/ctf/encodings1/","excerpt":"","text":"这种解密没什么头绪 翻了翻题解 可能要观察到长度是441=7*7*9？ 然后就是把每7位看做一个2进制数 转成ascii就好了 12345678var str = \"101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110\";var message = \"\";while (str != \"\") &#123; i = String.fromCharCode(parseInt(str.substr(0, 7), 2)); message = message + i; str = str.substr(7);&#125;document.write(message);","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"LFI","slug":"ctf/LFI","date":"2017-08-22T12:17:00.000Z","updated":"2017-10-12T14:44:41.795Z","comments":true,"path":"2017/08/22/ctf/LFI/","link":"","permalink":"http://ir1d.cf/2017/08/22/ctf/LFI/","excerpt":"","text":"PHP LFI 坑点是后面会加一个.html http://sp4hack.blogspot.ca/2012/10/we-chall-training-php-lfi.html 这里的思路是加一个%00 Everything after the null byte will be deleted. 太帅了=_^ 好像就是传说中的 Null Byte Injection ？ http://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"programming1","slug":"ctf/programming1","date":"2017-08-22T11:54:06.000Z","updated":"2017-10-12T14:44:41.787Z","comments":true,"path":"2017/08/22/ctf/programming1/","link":"","permalink":"http://ir1d.cf/2017/08/22/ctf/programming1/","excerpt":"","text":"先从一个链接获取文字再用这个文字生成新的链接= = cookie 传不明白了= = 最后一点也不优雅 决定用大佬的直接 ajax 的方法 123456789$.ajax(&#123;url: 'http://www.wechall.net/challenge/training/programming1/index.php?action=request',type: 'get',dataType: 'text',success:function(data)&#123;var newUrl=\"index.php?answer=\"+data;window.location.href=newUrl;&#125;&#125;); 好像自己写的没问题 是因为 wechall 那个锁定IP？","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"auth_bypass1","slug":"ctf/auth-bypass1","date":"2017-08-21T14:19:57.000Z","updated":"2017-10-12T14:44:41.780Z","comments":true,"path":"2017/08/21/ctf/auth-bypass1/","link":"","permalink":"http://ir1d.cf/2017/08/21/ctf/auth-bypass1/","excerpt":"","text":"MySQL Authentication Bypass - The classic 对于 MySQL 不是很了解 写 or 1=1 搞了半天 实际上应该是 or &#39;1&#39;=&#39;1&#39;; 以及这个分号加的…… 没想到","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"PHP-0817","slug":"ctf/PHP-0817","date":"2017-08-21T13:54:38.000Z","updated":"2017-10-12T14:44:41.772Z","comments":true,"path":"2017/08/21/ctf/PHP-0817/","link":"","permalink":"http://ir1d.cf/2017/08/21/ctf/PHP-0817/","excerpt":"","text":"http://www.wechall.net/challenge/php0817/index.php 学习了 LFI 这一套理论 Local File Inclusion 就和之前有人卡评测机的时候用1#include &lt;/etc/passwd&gt; 差不多吧 这个题的巧妙之处在于 php 之中很多东西在 switch 这里都会被转换成 0 所以就水掉了……","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://ir1d.cf/tags/ctf/"}]},{"title":"subject","slug":"notes/subject","date":"2017-08-17T07:41:29.000Z","updated":"2017-10-12T14:44:41.675Z","comments":true,"path":"2017/08/17/notes/subject/","link":"","permalink":"http://ir1d.cf/2017/08/17/notes/subject/","excerpt":"","text":"一晚上接近通宵可能中间睡了一会吧其实深夜也没有什么特别的觉得白天吵闹的话还是因为无法割舍吧深夜不过是提供一个契机来与世隔绝白天又不是不可以晚上一听歌就恐怕是真的不打算睡觉了 唔 定时作息养成规律生活自律给我自由","categories":[],"tags":[]},{"title":"明天","slug":"notes/明天","date":"2017-08-16T07:48:01.000Z","updated":"2017-10-12T14:44:41.663Z","comments":true,"path":"2017/08/16/notes/明天/","link":"","permalink":"http://ir1d.cf/2017/08/16/notes/明天/","excerpt":"","text":"你能扛起明天吗你能养活自己吗那你怎么养活她为什么将会是你凭什么可以是你 学姐你看那麻雀和你好像它也会飞 我好想你好想去找你上一句是假的上一句是假的 会好起来的会的 不放弃也不勉强哪怕比永远还远一点","categories":[],"tags":[]},{"title":"POJ训练计划","slug":"POJ训练计划","date":"2017-07-31T14:03:49.000Z","updated":"2018-06-23T04:51:40.331Z","comments":true,"path":"2017/07/31/POJ训练计划/","link":"","permalink":"http://ir1d.cf/2017/07/31/POJ训练计划/","excerpt":"","text":"3299：公式转换题，需要读题，不能只看样例 2159：判断同构，按频率排序 1083：区间加+单点最值 2739：预处理素数表+尺取法 2262：暴力 1503：高精度加法 3006：暴力 2255：dfs的过程中把两个序列中同一个子树给对应上就好了 3094：模拟 初期基本算法1753：暴力 2965：发现如果’+’位置对应的行和列上每一个位置都进行一次操作,则整个图只有这一’+’位置的符号改变,其余都不会改变. https://xuanwo.org/2014/07/23/POJ-2965-The-Pilots-Brothers&#39;-refrigerator/ 1328：贪心策略依然是从左往右，尽量让每颗雷达覆盖最大岛屿数。 将每个海岛转化为能覆盖它的雷达坐标的区间 2109：http://blog.csdn.net/code_pang/article/details/8263971 3295：模拟 求值 1068：模拟 2632：模拟= = RE一时爽 1573：模拟 2993：模拟 不太好写= = 2996：翘了 似乎是模拟就好= = 图算法1860：判有没有负环 3259：判负环 注意边是单向还是双向 好久没写多case的了= =这么生疏 1062：枚举地位建图跑最短路 2253：求最短路上的最大边最小 可以二分答案+并查集 POJ上边不知道为啥有时候G++交是WA而C++交是AC 然后有的时候还反过来= = 还可以改一改最短路= = 注意别把double的变量在传参之类的时候一不小心当int用了酿成惨案 1125：Floyd 2240：spfa找正环 或者直接Floyd看 多case的题调不出来的时候一定要想一想是不是哪里忘记初始化了 1789：prim 2485：prim 1258：prim 3026：prim 写起来挺麻烦的 坐标反的 = = 1094：处理字符别忘记了换行符 可以处理出来元素之间的大小关系 然后就很方便了 3041：把原图的点和边互换构图 然后之前是这样找尽量少的行列覆盖点 现在是找尽量少的点覆盖行列 就是最小点覆盖了 然后发现这个点只与一行一列相关 所以新图是一个二分图 二分图的最小点覆盖数值上等于二分图最大匹配 想了很久还是不是很懂匈牙利的实现里面的一处trick 于是写了dinic跑最大流= = 3020：把每个可以放置的点作为新点 如果两个点在原图相邻那么就可以放 所以连一条边 求的就是最小路径覆盖 拆点构图 得到的是二分图 3436：点有流量限制就拆点就好了 数据结构1035：模拟就好了 很久没写题代码能力捉急= = 3080：后缀数组最长公共子串 注意要求的是字典序最小的 二分答案从前往后找就行了 调了好久发现对后缀数组的理解还是不到位= = 1936：判断s是否是t的子序列 遍历t 同时维护s的一个指针就行了 2388：排序后输出位于中间的就行了 2299：求逆序对 归并就行 3349：hash判重就行 把每个雪花的六个角排序一下= = 3274：给出牛的个数n和总共特征个数k，求最长的区间，使得区间内所有牛的k个特征相加之和都相等。比如样例区间 每个牛内部差分再对序列求前缀和 问题就转化成在前缀和序列中找相等的两个元素 注意一定要先差分的才能将问题转化 从sum[j][0] - sum[i][0] = sum[j][1] - sum[i][1] = …… = sum[j][k] - sum[i][k]变成1234sum[i][1] - sum[i][0] = sum[j][1] - sum[j][0]sum[i][2] - sum[i][0] = sum[j][2] - sum[j][0]……sum[i][k] - sum[i][0] = sum[j][k] - sum[j][0] 2151：概率dp 设dp[i][j][k]表示第i个队在前j道题中解出k道的概率 dp[i][j][k]=dp[i][j-1][k-1]*p[i][j]+dp[i][j-1][k]*(1-p[i][j]); //这两种来源，第j道做出来或者没做出来+前j-1道做k-1或者k道题概率 设s[i][k]表示第i队做出的题小于等于k的概率s[i][k]=dp[i][M][0]+dp[i][M][1]+...+dp[i][M][k]; 每个队至少做出一道题概率为P1=(1-s[1][0])*(1-s[2][0])*...(1-s[T][0]); 每个队做出的题数都在1~N-1的概率为P2=(s[1][N-1]-s[1][0])*(s[2][N-1]-s[2][0])*...(s[T][N-1]-s[T][0]); 最后的答案就是P1-P2，代表至少一个队作出n到以上（1 - 所有队作出0...n-1的概率） 1840：判断方程是否有根 先枚举前两项可能的值再枚举后三个的值看看是否有和为0就行 hash姿势不对会mle 直接用map会tle = = 而且poj还没有unordered_map 2002：问平面上一堆点能组成多少个正方形，正方形的边允许不和坐标轴平行。方法是枚举一条边上的两个点，因为是正方形，此时就可以算出另外两个点，只需要二分一下看看是否存在就好了。注意每个正方形会被计算两次。 2503：应该是想要考哈希+二分，但是map一下就好了。值得一提的是gets会接受空行 3253：求哈夫曼树，priority_queue一波 2513：把字符串映射到点，再判断是否有欧拉通路。因为是无向图，只需要统计顶点度数为奇数的数和判断全图是否联通。至于如何映射字符串到点，用map会多个log超时，选用trie。好久没写并查集忘记了初始化竟然看了好久才发现。 简单搜索2488：爆搜即可，注意字典序的要求，字母用来表示列，就是说要列优先最小，再行最小。具体体现在dx, dy数组的设置上。 12const int dx[] = &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;;const int dy[] = &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;; 3083：bfs很好写，难点在于如何按照左（右）手边靠墙走，核心仍然在于方向数组 12345678910const int dxl[] = &#123;-1, 0, 1, 0&#125;;const int dyl[] = &#123;0, 1, 0, -1&#125;;const int dxr[] = &#123;-1, 0, 1, 0&#125;;const int dyr[] = &#123;0, -1, 0, 1&#125;;// 然后dfs枚举方向的时候：f(i, 0, 4) &#123; t = (i + op + 3) % 4; nx = x + dx[t]; ny = y + dy[t];&#125;// op用来表示方向 发现dxl实际上是从12点方向顺时针转，drl是逆时针转，从而刚好对应位置-1就是要找的方向，取模之后相当于是+3 3009：看起来很吓人但是实际上不难处理，把之前的dfs每次选一步走改成每次选一个方向走就好了。 1321：给一个不规则棋盘问放k个子的方案数，dfs枚举方案。值得注意的是允许当前位置不放子，所以还要记录横竖的vis数组。 2251：三维的地图，bfs或者dfs都可以 3278：bfs思路很好想，但是几年前简直是又wa又t一时爽。注意写法可能会忽略掉n==k的情况。用pair放到queue里写会很慢，不妨把时间戳放到外面开个数组单独记录。 1426：直接爆搜就过了 感觉会有更优美的写法 3126：实际上就是处理出来质数然后bfs就好了，然而筛法写错的我= = 3087：模拟就好了，写法是dfs而已 3414：著名的倒水问题，bfs。注意数组大小 2531：dfs把这堆东西分成两组 1416：找数字的分割方式使得各部分的和与x最近，好像应该dp不过dfs就过了。 2676：计算概论实验班选拔考试考了就懒得再写了= = 1129：给点染色的最小色数 动态规划1837：dp[i][c[k] * d[i] + j] += dp[i - 1][j]; 第二维是两侧重量差（体积）。因为有负的所以平移一波。 1276：01背包和多重背包的混合。考虑每一个多重背包，如果num[i] * c[i]大于体积，那么可以对这个物体看作是完全背包，否则拆成log个，然后当成01背包来做 3267：给一堆词，问一个字符串最少删掉多少字符后可以由这些单词中的某几个（可重复）顺序连接而成。 dp[i] = min(dp[i + 1] + 1, dp[i + match] + (match - len[j])) 其中 match 表示从当前位置开始需要延伸 match 长度来包含 len[j] ，这样 len[j] - match 就是需要删掉的那部分了 dp[i]的含义是从第 i 个位置开始的答案 1836：给一个序列，问最少要删掉多少个，使得每一个元素都有一个性质：向左或向右看不会有&gt;=自己的元素。方法是求两个方向的 LIS，然后求前缀和后缀 max。最后 res = max(l[i] + r[i + 1]) 。注意从 discuss 拿到的这组数据： 8 3 4 5 1 2 5 4 3 答案是 21260：给出每种品质的价格和需求，没多买一种品质需要多加钱，低品质可以用高品质代替。问最少花多少钱。 dp[i] 表示 前 i 种品质最少要花多少钱，转移的时候要么自己买，要么枚举一段相邻的品质用当前品质的价格来买。为什么是连续的呢？因为保证了价格递增，如果不是连续的，那么分成两段可以更便宜。","categories":[{"name":"算法","slug":"算法","permalink":"http://ir1d.cf/categories/算法/"}],"tags":[{"name":"poj","slug":"poj","permalink":"http://ir1d.cf/tags/poj/"}]},{"title":"新的开始","slug":"notes/新的开始","date":"2017-07-30T14:04:32.000Z","updated":"2017-10-12T14:44:41.610Z","comments":true,"path":"2017/07/30/notes/新的开始/","link":"","permalink":"http://ir1d.cf/2017/07/30/notes/新的开始/","excerpt":"","text":"出发去旅行前的一次重装把东西都给整没了，索性也就重新开始写这个blog。 大学加油！希望能有机会成为自己想成为的人！愿不负这时光！","categories":[],"tags":[]}]}